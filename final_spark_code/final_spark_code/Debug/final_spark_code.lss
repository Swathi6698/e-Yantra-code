
final_spark_code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001e02  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000a  00800060  00001e02  00001e96  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000a9  0080006a  0080006a  00001ea0  2**0
                  ALLOC
  3 .stab         00001be4  00000000  00000000  00001ea0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000583  00000000  00000000  00003a84  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00004008  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002aee  00000000  00000000  000040c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000479  00000000  00000000  00006bb6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000c8c  00000000  00000000  0000702f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000884  00000000  00000000  00007cbc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000008f0  00000000  00000000  00008540  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000021a1  00000000  00000000  00008e30  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000160  00000000  00000000  0000afd1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 cd 02 	jmp	0x59a	; 0x59a <__vector_1>
       8:	0c 94 f2 02 	jmp	0x5e4	; 0x5e4 <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 d7 07 	jmp	0xfae	; 0xfae <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 7f 09 	jmp	0x12fe	; 0x12fe <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e0       	ldi	r30, 0x02	; 2
      68:	fe e1       	ldi	r31, 0x1E	; 30
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 36       	cpi	r26, 0x6A	; 106
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	aa e6       	ldi	r26, 0x6A	; 106
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 31       	cpi	r26, 0x13	; 19
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <main>
      8a:	0c 94 ff 0e 	jmp	0x1dfe	; 0x1dfe <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <do_task>:
		green_side[i]=0;
	}
}
void do_task()
{	
	if(task==1)//red
      92:	80 91 75 00 	lds	r24, 0x0075
      96:	81 30       	cpi	r24, 0x01	; 1
      98:	f1 f4       	brne	.+60     	; 0xd6 <do_task+0x44>
	{	
		red_nodes[r]=path1.path[t];
      9a:	90 91 64 00 	lds	r25, 0x0064
      9e:	80 91 76 00 	lds	r24, 0x0076
      a2:	e8 ec       	ldi	r30, 0xC8	; 200
      a4:	f0 e0       	ldi	r31, 0x00	; 0
      a6:	e8 0f       	add	r30, r24
      a8:	f1 1d       	adc	r31, r1
      aa:	80 81       	ld	r24, Z
      ac:	e3 ef       	ldi	r30, 0xF3	; 243
      ae:	f0 e0       	ldi	r31, 0x00	; 0
      b0:	e9 0f       	add	r30, r25
      b2:	f1 1d       	adc	r31, r1
      b4:	80 83       	st	Z, r24
		red_side[rs]=side;
      b6:	80 91 63 00 	lds	r24, 0x0063
      ba:	20 91 74 00 	lds	r18, 0x0074
      be:	ef ef       	ldi	r30, 0xFF	; 255
      c0:	f0 e0       	ldi	r31, 0x00	; 0
      c2:	e8 0f       	add	r30, r24
      c4:	f1 1d       	adc	r31, r1
      c6:	20 83       	st	Z, r18
		r++;
      c8:	9f 5f       	subi	r25, 0xFF	; 255
      ca:	90 93 64 00 	sts	0x0064, r25
		rs++;
      ce:	8f 5f       	subi	r24, 0xFF	; 255
      d0:	80 93 63 00 	sts	0x0063, r24
      d4:	1f c0       	rjmp	.+62     	; 0x114 <do_task+0x82>
		
	}
	else if(task==2)//green
      d6:	82 30       	cpi	r24, 0x02	; 2
      d8:	e9 f4       	brne	.+58     	; 0x114 <do_task+0x82>
	{
		green_nodes[gn]=path1.path[t];
      da:	90 91 62 00 	lds	r25, 0x0062
      de:	80 91 76 00 	lds	r24, 0x0076
      e2:	e8 ec       	ldi	r30, 0xC8	; 200
      e4:	f0 e0       	ldi	r31, 0x00	; 0
      e6:	e8 0f       	add	r30, r24
      e8:	f1 1d       	adc	r31, r1
      ea:	80 81       	ld	r24, Z
      ec:	e2 e8       	ldi	r30, 0x82	; 130
      ee:	f0 e0       	ldi	r31, 0x00	; 0
      f0:	e9 0f       	add	r30, r25
      f2:	f1 1d       	adc	r31, r1
      f4:	80 83       	st	Z, r24
		green_side[gs]=side;
      f6:	80 91 61 00 	lds	r24, 0x0061
      fa:	20 91 74 00 	lds	r18, 0x0074
      fe:	e0 ea       	ldi	r30, 0xA0	; 160
     100:	f0 e0       	ldi	r31, 0x00	; 0
     102:	e8 0f       	add	r30, r24
     104:	f1 1d       	adc	r31, r1
     106:	20 83       	st	Z, r18
		gn++;
     108:	9f 5f       	subi	r25, 0xFF	; 255
     10a:	90 93 62 00 	sts	0x0062, r25
		gs++;
     10e:	8f 5f       	subi	r24, 0xFF	; 255
     110:	80 93 61 00 	sts	0x0061, r24
		
	}
	if(task==3)
     114:	80 91 75 00 	lds	r24, 0x0075
     118:	83 30       	cpi	r24, 0x03	; 3
     11a:	01 f5       	brne	.+64     	; 0x15c <do_task+0xca>
     11c:	87 e9       	ldi	r24, 0x97	; 151
     11e:	90 e0       	ldi	r25, 0x00	; 0
	{
		for(int i=0;i<=150;i++)   //back
		{
			PORTB=PORTB|0x20;//0010 0000 pb5
     120:	c5 9a       	sbi	0x18, 5	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     122:	e9 e9       	ldi	r30, 0x99	; 153
     124:	f3 e0       	ldi	r31, 0x03	; 3
     126:	31 97       	sbiw	r30, 0x01	; 1
     128:	f1 f7       	brne	.-4      	; 0x126 <do_task+0x94>
     12a:	00 c0       	rjmp	.+0      	; 0x12c <do_task+0x9a>
			_delay_ms(0.5);
			PORTB=PORTB & 0xDF;//1101 1111
     12c:	c5 98       	cbi	0x18, 5	; 24
     12e:	e6 e6       	ldi	r30, 0x66	; 102
     130:	fc e8       	ldi	r31, 0x8C	; 140
     132:	31 97       	sbiw	r30, 0x01	; 1
     134:	f1 f7       	brne	.-4      	; 0x132 <do_task+0xa0>
     136:	00 00       	nop
     138:	01 97       	sbiw	r24, 0x01	; 1
		gs++;
		
	}
	if(task==3)
	{
		for(int i=0;i<=150;i++)   //back
     13a:	91 f7       	brne	.-28     	; 0x120 <do_task+0x8e>
     13c:	87 e9       	ldi	r24, 0x97	; 151
     13e:	90 e0       	ldi	r25, 0x00	; 0
		}


		for(int i=0;i<=150;i++)  //front
		{
			PORTB=PORTB|0x20;//0010 0000 pb5
     140:	c5 9a       	sbi	0x18, 5	; 24
     142:	ee e1       	ldi	r30, 0x1E	; 30
     144:	f6 e0       	ldi	r31, 0x06	; 6
     146:	31 97       	sbiw	r30, 0x01	; 1
     148:	f1 f7       	brne	.-4      	; 0x146 <do_task+0xb4>
     14a:	00 c0       	rjmp	.+0      	; 0x14c <do_task+0xba>
			_delay_ms(0.85);
			PORTB=PORTB & 0xDF;//1101 1111
     14c:	c5 98       	cbi	0x18, 5	; 24
     14e:	e1 ee       	ldi	r30, 0xE1	; 225
     150:	f9 e8       	ldi	r31, 0x89	; 137
     152:	31 97       	sbiw	r30, 0x01	; 1
     154:	f1 f7       	brne	.-4      	; 0x152 <do_task+0xc0>
     156:	00 00       	nop
     158:	01 97       	sbiw	r24, 0x01	; 1
			_delay_ms(19.5);
			
		}


		for(int i=0;i<=150;i++)  //front
     15a:	91 f7       	brne	.-28     	; 0x140 <do_task+0xae>
	}
	if(red_side[0]==1 && red_side[1]==1)
	{
		buzzer_beep();
	}*/
	task=0;
     15c:	10 92 75 00 	sts	0x0075, r1
	side=0;
     160:	10 92 74 00 	sts	0x0074, r1
	PORTC=PORTC& 0x8F;//1000 1111
     164:	85 b3       	in	r24, 0x15	; 21
     166:	8f 78       	andi	r24, 0x8F	; 143
     168:	85 bb       	out	0x15, r24	; 21
	//buzzer_beep();
}
     16a:	08 95       	ret

0000016c <buzzer_pin_config>:
#include <util/delay.h>

//Function to initialize Buzzer 
void buzzer_pin_config (void)
{
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     16c:	a3 9a       	sbi	0x14, 3	; 20
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     16e:	ab 98       	cbi	0x15, 3	; 21
}
     170:	08 95       	ret

00000172 <port_init_buzzer>:

void port_init_buzzer (void)
{
 buzzer_pin_config();
     172:	0e 94 b6 00 	call	0x16c	; 0x16c <buzzer_pin_config>
}
     176:	08 95       	ret

00000178 <buzzer_on>:

void buzzer_on (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     178:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore | 0x08;
     17a:	88 60       	ori	r24, 0x08	; 8
 PORTC = port_restore;
     17c:	85 bb       	out	0x15, r24	; 21
}
     17e:	08 95       	ret

00000180 <buzzer_off>:

void buzzer_off (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     180:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore & 0xF7;
     182:	87 7f       	andi	r24, 0xF7	; 247
 PORTC = port_restore;
     184:	85 bb       	out	0x15, r24	; 21
}
     186:	08 95       	ret

00000188 <buzzer_beep>:
void buzzer_beep()
{
	buzzer_on();
     188:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
     18c:	8f ef       	ldi	r24, 0xFF	; 255
     18e:	9f e7       	ldi	r25, 0x7F	; 127
     190:	a4 e0       	ldi	r26, 0x04	; 4
     192:	81 50       	subi	r24, 0x01	; 1
     194:	90 40       	sbci	r25, 0x00	; 0
     196:	a0 40       	sbci	r26, 0x00	; 0
     198:	e1 f7       	brne	.-8      	; 0x192 <buzzer_beep+0xa>
     19a:	00 c0       	rjmp	.+0      	; 0x19c <buzzer_beep+0x14>
     19c:	00 00       	nop
	_delay_ms(200);
	buzzer_off();
     19e:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
     1a2:	8f ef       	ldi	r24, 0xFF	; 255
     1a4:	9f e7       	ldi	r25, 0x7F	; 127
     1a6:	a4 e0       	ldi	r26, 0x04	; 4
     1a8:	81 50       	subi	r24, 0x01	; 1
     1aa:	90 40       	sbci	r25, 0x00	; 0
     1ac:	a0 40       	sbci	r26, 0x00	; 0
     1ae:	e1 f7       	brne	.-8      	; 0x1a8 <buzzer_beep+0x20>
     1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <buzzer_beep+0x2a>
     1b2:	00 00       	nop
	_delay_ms(200);
}
     1b4:	08 95       	ret

000001b6 <init_devices_buzzer>:
void init_devices_buzzer (void)
{
 cli(); 			//Clears the global interrupts
     1b6:	f8 94       	cli
 port_init_buzzer();
     1b8:	0e 94 b9 00 	call	0x172	; 0x172 <port_init_buzzer>
 sei(); 			//Enables the global interrupts
     1bc:	78 94       	sei
}
     1be:	08 95       	ret

000001c0 <main_function7>:




struct Path_Array main_function7(unsigned char start, unsigned char finish)
{
     1c0:	cf 92       	push	r12
     1c2:	df 92       	push	r13
     1c4:	ef 92       	push	r14
     1c6:	ff 92       	push	r15
     1c8:	0f 93       	push	r16
     1ca:	1f 93       	push	r17
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	cd b7       	in	r28, 0x3d	; 61
     1d2:	de b7       	in	r29, 0x3e	; 62
     1d4:	2f 97       	sbiw	r28, 0x0f	; 15
     1d6:	0f b6       	in	r0, 0x3f	; 63
     1d8:	f8 94       	cli
     1da:	de bf       	out	0x3e, r29	; 62
     1dc:	0f be       	out	0x3f, r0	; 63
     1de:	cd bf       	out	0x3d, r28	; 61
     1e0:	08 2f       	mov	r16, r24
     1e2:	f9 2e       	mov	r15, r25
     1e4:	26 2f       	mov	r18, r22
	struct Path_Array path;
unsigned char friend; 
signed char k =(((start-1)/7)-((finish-1)/7));
     1e6:	c4 2e       	mov	r12, r20
     1e8:	dd 24       	eor	r13, r13
     1ea:	86 2f       	mov	r24, r22
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	01 97       	sbiw	r24, 0x01	; 1
     1f0:	e7 e0       	ldi	r30, 0x07	; 7
     1f2:	f0 e0       	ldi	r31, 0x00	; 0
     1f4:	bf 01       	movw	r22, r30
     1f6:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <__divmodhi4>
     1fa:	36 2f       	mov	r19, r22
     1fc:	c6 01       	movw	r24, r12
     1fe:	01 97       	sbiw	r24, 0x01	; 1
     200:	bf 01       	movw	r22, r30
     202:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <__divmodhi4>
     206:	36 1b       	sub	r19, r22
     208:	53 2f       	mov	r21, r19
if(k>0)
     20a:	13 16       	cp	r1, r19
     20c:	3c f4       	brge	.+14     	; 0x21c <main_function7+0x5c>
{
	friend=((k*7)+finish);
     20e:	13 2f       	mov	r17, r19
     210:	11 0f       	add	r17, r17
     212:	11 0f       	add	r17, r17
     214:	11 0f       	add	r17, r17
     216:	13 1b       	sub	r17, r19
     218:	14 0f       	add	r17, r20
     21a:	06 c0       	rjmp	.+12     	; 0x228 <main_function7+0x68>
}
else
{
	friend=(finish-(k*(-1))*7);
     21c:	13 2f       	mov	r17, r19
     21e:	11 0f       	add	r17, r17
     220:	11 0f       	add	r17, r17
     222:	11 0f       	add	r17, r17
     224:	13 1b       	sub	r17, r19
     226:	14 0f       	add	r17, r20
}
signed char l=0;
unsigned char m=0;
 unsigned char st =start;
l=(friend - start);
     228:	31 2f       	mov	r19, r17
     22a:	32 1b       	sub	r19, r18
     22c:	e3 2e       	mov	r14, r19

if(l>0)
     22e:	13 16       	cp	r1, r19
     230:	0c f0       	brlt	.+2      	; 0x234 <main_function7+0x74>
     232:	ad c0       	rjmp	.+346    	; 0x38e <main_function7+0x1ce>
{
	for(unsigned char i = 0;i<=l;i++)
     234:	e3 2f       	mov	r30, r19
     236:	ff 27       	eor	r31, r31
     238:	e7 fd       	sbrc	r30, 7
     23a:	f0 95       	com	r31
     23c:	ff 23       	and	r31, r31
     23e:	9c f0       	brlt	.+38     	; 0x266 <main_function7+0xa6>
     240:	80 e0       	ldi	r24, 0x00	; 0
     242:	90 e0       	ldi	r25, 0x00	; 0
     244:	60 e0       	ldi	r22, 0x00	; 0
	{path.path[i]=st;
     246:	a1 e0       	ldi	r26, 0x01	; 1
     248:	b0 e0       	ldi	r27, 0x00	; 0
     24a:	ac 0f       	add	r26, r28
     24c:	bd 1f       	adc	r27, r29
     24e:	8a 0f       	add	r24, r26
     250:	9b 1f       	adc	r25, r27
     252:	76 2f       	mov	r23, r22
     254:	72 0f       	add	r23, r18
     256:	dc 01       	movw	r26, r24
     258:	7c 93       	st	X, r23
 unsigned char st =start;
l=(friend - start);

if(l>0)
{
	for(unsigned char i = 0;i<=l;i++)
     25a:	6f 5f       	subi	r22, 0xFF	; 255
     25c:	86 2f       	mov	r24, r22
     25e:	90 e0       	ldi	r25, 0x00	; 0
     260:	e8 17       	cp	r30, r24
     262:	f9 07       	cpc	r31, r25
     264:	84 f7       	brge	.-32     	; 0x246 <main_function7+0x86>
	{path.path[i]=st;
	st++;
	}
	if(k>0)	
     266:	15 16       	cp	r1, r21
     268:	0c f0       	brlt	.+2      	; 0x26c <main_function7+0xac>
     26a:	47 c0       	rjmp	.+142    	; 0x2fa <main_function7+0x13a>
	{   
		if(friend > finish)
     26c:	41 17       	cp	r20, r17
     26e:	18 f5       	brcc	.+70     	; 0x2b6 <main_function7+0xf6>
		{
			m=((friend-finish)/7);
     270:	81 2f       	mov	r24, r17
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	8c 19       	sub	r24, r12
     276:	9d 09       	sbc	r25, r13
     278:	67 e0       	ldi	r22, 0x07	; 7
     27a:	70 e0       	ldi	r23, 0x00	; 0
     27c:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     280:	66 23       	and	r22, r22
     282:	09 f4       	brne	.+2      	; 0x286 <main_function7+0xc6>
     284:	34 c1       	rjmp	.+616    	; 0x4ee <__stack+0x8f>
     286:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     288:	ec 0f       	add	r30, r28
     28a:	fd 1f       	adc	r31, r29
     28c:	32 96       	adiw	r30, 0x02	; 2
     28e:	83 2f       	mov	r24, r19
     290:	99 27       	eor	r25, r25
     292:	87 fd       	sbrc	r24, 7
     294:	90 95       	com	r25
     296:	23 e0       	ldi	r18, 0x03	; 3
     298:	30 e0       	ldi	r19, 0x00	; 0
     29a:	2c 0f       	add	r18, r28
     29c:	3d 1f       	adc	r19, r29
     29e:	82 0f       	add	r24, r18
     2a0:	93 1f       	adc	r25, r19
     2a2:	26 2f       	mov	r18, r22
     2a4:	21 50       	subi	r18, 0x01	; 1
     2a6:	82 0f       	add	r24, r18
     2a8:	91 1d       	adc	r25, r1
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     2aa:	11 93       	st	Z+, r17
     2ac:	17 50       	subi	r17, 0x07	; 7
	if(k>0)	
	{   
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     2ae:	e8 17       	cp	r30, r24
     2b0:	f9 07       	cpc	r31, r25
     2b2:	d9 f7       	brne	.-10     	; 0x2aa <main_function7+0xea>
     2b4:	1c c1       	rjmp	.+568    	; 0x4ee <__stack+0x8f>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     2b6:	c6 01       	movw	r24, r12
     2b8:	81 1b       	sub	r24, r17
     2ba:	91 09       	sbc	r25, r1
     2bc:	67 e0       	ldi	r22, 0x07	; 7
     2be:	70 e0       	ldi	r23, 0x00	; 0
     2c0:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     2c4:	66 23       	and	r22, r22
     2c6:	09 f4       	brne	.+2      	; 0x2ca <main_function7+0x10a>
     2c8:	12 c1       	rjmp	.+548    	; 0x4ee <__stack+0x8f>
     2ca:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     2cc:	ec 0f       	add	r30, r28
     2ce:	fd 1f       	adc	r31, r29
     2d0:	32 96       	adiw	r30, 0x02	; 2
     2d2:	83 2f       	mov	r24, r19
     2d4:	99 27       	eor	r25, r25
     2d6:	87 fd       	sbrc	r24, 7
     2d8:	90 95       	com	r25
     2da:	a3 e0       	ldi	r26, 0x03	; 3
     2dc:	b0 e0       	ldi	r27, 0x00	; 0
     2de:	ac 0f       	add	r26, r28
     2e0:	bd 1f       	adc	r27, r29
     2e2:	8a 0f       	add	r24, r26
     2e4:	9b 1f       	adc	r25, r27
     2e6:	26 2f       	mov	r18, r22
     2e8:	21 50       	subi	r18, 0x01	; 1
     2ea:	82 0f       	add	r24, r18
     2ec:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     2ee:	11 93       	st	Z+, r17
     2f0:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     2f2:	e8 17       	cp	r30, r24
     2f4:	f9 07       	cpc	r31, r25
     2f6:	d9 f7       	brne	.-10     	; 0x2ee <main_function7+0x12e>
     2f8:	fa c0       	rjmp	.+500    	; 0x4ee <__stack+0x8f>
				path.path[l+i+1]=friend+((7*i)+7);
			}
		}
		
	}
	else if(k<0)
     2fa:	55 23       	and	r21, r21
     2fc:	0c f0       	brlt	.+2      	; 0x300 <main_function7+0x140>
     2fe:	f4 c0       	rjmp	.+488    	; 0x4e8 <__stack+0x89>
	{ if(friend > finish)
     300:	41 17       	cp	r20, r17
     302:	18 f5       	brcc	.+70     	; 0x34a <main_function7+0x18a>
		{	
			m=((friend-finish)/7);
     304:	81 2f       	mov	r24, r17
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	8c 19       	sub	r24, r12
     30a:	9d 09       	sbc	r25, r13
     30c:	67 e0       	ldi	r22, 0x07	; 7
     30e:	70 e0       	ldi	r23, 0x00	; 0
     310:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     314:	66 23       	and	r22, r22
     316:	09 f4       	brne	.+2      	; 0x31a <main_function7+0x15a>
     318:	ea c0       	rjmp	.+468    	; 0x4ee <__stack+0x8f>
     31a:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     31c:	ec 0f       	add	r30, r28
     31e:	fd 1f       	adc	r31, r29
     320:	32 96       	adiw	r30, 0x02	; 2
     322:	83 2f       	mov	r24, r19
     324:	99 27       	eor	r25, r25
     326:	87 fd       	sbrc	r24, 7
     328:	90 95       	com	r25
     32a:	23 e0       	ldi	r18, 0x03	; 3
     32c:	30 e0       	ldi	r19, 0x00	; 0
     32e:	2c 0f       	add	r18, r28
     330:	3d 1f       	adc	r19, r29
     332:	82 0f       	add	r24, r18
     334:	93 1f       	adc	r25, r19
     336:	26 2f       	mov	r18, r22
     338:	21 50       	subi	r18, 0x01	; 1
     33a:	82 0f       	add	r24, r18
     33c:	91 1d       	adc	r25, r1
	{ if(friend > finish)
		{	
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     33e:	11 93       	st	Z+, r17
     340:	17 50       	subi	r17, 0x07	; 7
	}
	else if(k<0)
	{ if(friend > finish)
		{	
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     342:	e8 17       	cp	r30, r24
     344:	f9 07       	cpc	r31, r25
     346:	d9 f7       	brne	.-10     	; 0x33e <main_function7+0x17e>
     348:	d2 c0       	rjmp	.+420    	; 0x4ee <__stack+0x8f>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     34a:	c6 01       	movw	r24, r12
     34c:	81 1b       	sub	r24, r17
     34e:	91 09       	sbc	r25, r1
     350:	67 e0       	ldi	r22, 0x07	; 7
     352:	70 e0       	ldi	r23, 0x00	; 0
     354:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     358:	66 23       	and	r22, r22
     35a:	09 f4       	brne	.+2      	; 0x35e <main_function7+0x19e>
     35c:	c8 c0       	rjmp	.+400    	; 0x4ee <__stack+0x8f>
     35e:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     360:	ec 0f       	add	r30, r28
     362:	fd 1f       	adc	r31, r29
     364:	32 96       	adiw	r30, 0x02	; 2
     366:	83 2f       	mov	r24, r19
     368:	99 27       	eor	r25, r25
     36a:	87 fd       	sbrc	r24, 7
     36c:	90 95       	com	r25
     36e:	a3 e0       	ldi	r26, 0x03	; 3
     370:	b0 e0       	ldi	r27, 0x00	; 0
     372:	ac 0f       	add	r26, r28
     374:	bd 1f       	adc	r27, r29
     376:	8a 0f       	add	r24, r26
     378:	9b 1f       	adc	r25, r27
     37a:	26 2f       	mov	r18, r22
     37c:	21 50       	subi	r18, 0x01	; 1
     37e:	82 0f       	add	r24, r18
     380:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     382:	11 93       	st	Z+, r17
     384:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     386:	e8 17       	cp	r30, r24
     388:	f9 07       	cpc	r31, r25
     38a:	d9 f7       	brne	.-10     	; 0x382 <main_function7+0x1c2>
     38c:	b0 c0       	rjmp	.+352    	; 0x4ee <__stack+0x8f>
		
	}
	
}
else
{ l=(l*(-1));
     38e:	e3 2e       	mov	r14, r19
     390:	e1 94       	neg	r14
	for(unsigned char i = 0;i<=(l);i++)
     392:	ee 2d       	mov	r30, r14
     394:	ff 27       	eor	r31, r31
     396:	e7 fd       	sbrc	r30, 7
     398:	f0 95       	com	r31
     39a:	ff 23       	and	r31, r31
     39c:	9c f0       	brlt	.+38     	; 0x3c4 <main_function7+0x204>
     39e:	80 e0       	ldi	r24, 0x00	; 0
     3a0:	90 e0       	ldi	r25, 0x00	; 0
     3a2:	30 e0       	ldi	r19, 0x00	; 0
	{path.path[i]=st;
     3a4:	61 e0       	ldi	r22, 0x01	; 1
     3a6:	70 e0       	ldi	r23, 0x00	; 0
     3a8:	6c 0f       	add	r22, r28
     3aa:	7d 1f       	adc	r23, r29
     3ac:	86 0f       	add	r24, r22
     3ae:	97 1f       	adc	r25, r23
     3b0:	62 2f       	mov	r22, r18
     3b2:	63 1b       	sub	r22, r19
     3b4:	dc 01       	movw	r26, r24
     3b6:	6c 93       	st	X, r22
	}
	
}
else
{ l=(l*(-1));
	for(unsigned char i = 0;i<=(l);i++)
     3b8:	3f 5f       	subi	r19, 0xFF	; 255
     3ba:	83 2f       	mov	r24, r19
     3bc:	90 e0       	ldi	r25, 0x00	; 0
     3be:	e8 17       	cp	r30, r24
     3c0:	f9 07       	cpc	r31, r25
     3c2:	84 f7       	brge	.-32     	; 0x3a4 <main_function7+0x1e4>
	{path.path[i]=st;
		st--;
	}
	if(k>0)
     3c4:	15 16       	cp	r1, r21
     3c6:	0c f0       	brlt	.+2      	; 0x3ca <main_function7+0x20a>
     3c8:	47 c0       	rjmp	.+142    	; 0x458 <main_function7+0x298>
	{  
		if(friend > finish)
     3ca:	41 17       	cp	r20, r17
     3cc:	18 f5       	brcc	.+70     	; 0x414 <main_function7+0x254>
		{
			m=((friend-finish)/7);
     3ce:	81 2f       	mov	r24, r17
     3d0:	90 e0       	ldi	r25, 0x00	; 0
     3d2:	8c 19       	sub	r24, r12
     3d4:	9d 09       	sbc	r25, r13
     3d6:	67 e0       	ldi	r22, 0x07	; 7
     3d8:	70 e0       	ldi	r23, 0x00	; 0
     3da:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     3de:	66 23       	and	r22, r22
     3e0:	09 f4       	brne	.+2      	; 0x3e4 <main_function7+0x224>
     3e2:	85 c0       	rjmp	.+266    	; 0x4ee <__stack+0x8f>
     3e4:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     3e6:	ec 0f       	add	r30, r28
     3e8:	fd 1f       	adc	r31, r29
     3ea:	32 96       	adiw	r30, 0x02	; 2
     3ec:	8e 2d       	mov	r24, r14
     3ee:	99 27       	eor	r25, r25
     3f0:	87 fd       	sbrc	r24, 7
     3f2:	90 95       	com	r25
     3f4:	23 e0       	ldi	r18, 0x03	; 3
     3f6:	30 e0       	ldi	r19, 0x00	; 0
     3f8:	2c 0f       	add	r18, r28
     3fa:	3d 1f       	adc	r19, r29
     3fc:	82 0f       	add	r24, r18
     3fe:	93 1f       	adc	r25, r19
     400:	26 2f       	mov	r18, r22
     402:	21 50       	subi	r18, 0x01	; 1
     404:	82 0f       	add	r24, r18
     406:	91 1d       	adc	r25, r1
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     408:	11 93       	st	Z+, r17
     40a:	17 50       	subi	r17, 0x07	; 7
	if(k>0)
	{  
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     40c:	e8 17       	cp	r30, r24
     40e:	f9 07       	cpc	r31, r25
     410:	d9 f7       	brne	.-10     	; 0x408 <main_function7+0x248>
     412:	6d c0       	rjmp	.+218    	; 0x4ee <__stack+0x8f>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     414:	c6 01       	movw	r24, r12
     416:	81 1b       	sub	r24, r17
     418:	91 09       	sbc	r25, r1
     41a:	67 e0       	ldi	r22, 0x07	; 7
     41c:	70 e0       	ldi	r23, 0x00	; 0
     41e:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     422:	66 23       	and	r22, r22
     424:	09 f4       	brne	.+2      	; 0x428 <main_function7+0x268>
     426:	63 c0       	rjmp	.+198    	; 0x4ee <__stack+0x8f>
     428:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     42a:	ec 0f       	add	r30, r28
     42c:	fd 1f       	adc	r31, r29
     42e:	32 96       	adiw	r30, 0x02	; 2
     430:	8e 2d       	mov	r24, r14
     432:	99 27       	eor	r25, r25
     434:	87 fd       	sbrc	r24, 7
     436:	90 95       	com	r25
     438:	a3 e0       	ldi	r26, 0x03	; 3
     43a:	b0 e0       	ldi	r27, 0x00	; 0
     43c:	ac 0f       	add	r26, r28
     43e:	bd 1f       	adc	r27, r29
     440:	8a 0f       	add	r24, r26
     442:	9b 1f       	adc	r25, r27
     444:	26 2f       	mov	r18, r22
     446:	21 50       	subi	r18, 0x01	; 1
     448:	82 0f       	add	r24, r18
     44a:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     44c:	11 93       	st	Z+, r17
     44e:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     450:	e8 17       	cp	r30, r24
     452:	f9 07       	cpc	r31, r25
     454:	d9 f7       	brne	.-10     	; 0x44c <main_function7+0x28c>
     456:	4b c0       	rjmp	.+150    	; 0x4ee <__stack+0x8f>
			{
				path.path[l+i+1]=friend+((7*i)+7);
			}
		}
	}
	else  if(k<0)
     458:	55 23       	and	r21, r21
     45a:	0c f0       	brlt	.+2      	; 0x45e <main_function7+0x29e>
     45c:	47 c0       	rjmp	.+142    	; 0x4ec <__stack+0x8d>
	{
		if(friend > finish)
     45e:	41 17       	cp	r20, r17
     460:	10 f5       	brcc	.+68     	; 0x4a6 <__stack+0x47>
		{
			m=((friend-finish)/7);
     462:	81 2f       	mov	r24, r17
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	8c 19       	sub	r24, r12
     468:	9d 09       	sbc	r25, r13
     46a:	67 e0       	ldi	r22, 0x07	; 7
     46c:	70 e0       	ldi	r23, 0x00	; 0
     46e:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     472:	66 23       	and	r22, r22
     474:	e1 f1       	breq	.+120    	; 0x4ee <__stack+0x8f>
     476:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     478:	ec 0f       	add	r30, r28
     47a:	fd 1f       	adc	r31, r29
     47c:	32 96       	adiw	r30, 0x02	; 2
     47e:	8e 2d       	mov	r24, r14
     480:	99 27       	eor	r25, r25
     482:	87 fd       	sbrc	r24, 7
     484:	90 95       	com	r25
     486:	23 e0       	ldi	r18, 0x03	; 3
     488:	30 e0       	ldi	r19, 0x00	; 0
     48a:	2c 0f       	add	r18, r28
     48c:	3d 1f       	adc	r19, r29
     48e:	82 0f       	add	r24, r18
     490:	93 1f       	adc	r25, r19
     492:	26 2f       	mov	r18, r22
     494:	21 50       	subi	r18, 0x01	; 1
     496:	82 0f       	add	r24, r18
     498:	91 1d       	adc	r25, r1
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     49a:	11 93       	st	Z+, r17
     49c:	17 50       	subi	r17, 0x07	; 7
	else  if(k<0)
	{
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     49e:	e8 17       	cp	r30, r24
     4a0:	f9 07       	cpc	r31, r25
     4a2:	d9 f7       	brne	.-10     	; 0x49a <__stack+0x3b>
     4a4:	24 c0       	rjmp	.+72     	; 0x4ee <__stack+0x8f>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     4a6:	c6 01       	movw	r24, r12
     4a8:	81 1b       	sub	r24, r17
     4aa:	91 09       	sbc	r25, r1
     4ac:	67 e0       	ldi	r22, 0x07	; 7
     4ae:	70 e0       	ldi	r23, 0x00	; 0
     4b0:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     4b4:	66 23       	and	r22, r22
     4b6:	d9 f0       	breq	.+54     	; 0x4ee <__stack+0x8f>
     4b8:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     4ba:	ec 0f       	add	r30, r28
     4bc:	fd 1f       	adc	r31, r29
     4be:	32 96       	adiw	r30, 0x02	; 2
     4c0:	8e 2d       	mov	r24, r14
     4c2:	99 27       	eor	r25, r25
     4c4:	87 fd       	sbrc	r24, 7
     4c6:	90 95       	com	r25
     4c8:	a3 e0       	ldi	r26, 0x03	; 3
     4ca:	b0 e0       	ldi	r27, 0x00	; 0
     4cc:	ac 0f       	add	r26, r28
     4ce:	bd 1f       	adc	r27, r29
     4d0:	8a 0f       	add	r24, r26
     4d2:	9b 1f       	adc	r25, r27
     4d4:	26 2f       	mov	r18, r22
     4d6:	21 50       	subi	r18, 0x01	; 1
     4d8:	82 0f       	add	r24, r18
     4da:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     4dc:	11 93       	st	Z+, r17
     4de:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     4e0:	e8 17       	cp	r30, r24
     4e2:	f9 07       	cpc	r31, r25
     4e4:	d9 f7       	brne	.-10     	; 0x4dc <__stack+0x7d>
     4e6:	03 c0       	rjmp	.+6      	; 0x4ee <__stack+0x8f>
else
{
	friend=(finish-(k*(-1))*7);
}
signed char l=0;
unsigned char m=0;
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	01 c0       	rjmp	.+2      	; 0x4ee <__stack+0x8f>
     4ec:	60 e0       	ldi	r22, 0x00	; 0
		}
		
	}
	
}
 max = l+m;
     4ee:	6e 0d       	add	r22, r14
     4f0:	60 93 80 00 	sts	0x0080, r22
 for(unsigned char i=(l+m+1);i<15;i++)
     4f4:	6f 5f       	subi	r22, 0xFF	; 255
     4f6:	6f 30       	cpi	r22, 0x0F	; 15
     4f8:	50 f4       	brcc	.+20     	; 0x50e <__stack+0xaf>
 {
	 path.path[i]=0;
     4fa:	e1 e0       	ldi	r30, 0x01	; 1
     4fc:	f0 e0       	ldi	r31, 0x00	; 0
     4fe:	ec 0f       	add	r30, r28
     500:	fd 1f       	adc	r31, r29
     502:	e6 0f       	add	r30, r22
     504:	f1 1d       	adc	r31, r1
     506:	10 82       	st	Z, r1
		
	}
	
}
 max = l+m;
 for(unsigned char i=(l+m+1);i<15;i++)
     508:	6f 5f       	subi	r22, 0xFF	; 255
     50a:	6f 30       	cpi	r22, 0x0F	; 15
     50c:	b1 f7       	brne	.-20     	; 0x4fa <__stack+0x9b>
 {
	 path.path[i]=0;
 }

	
	return path;
     50e:	e0 2f       	mov	r30, r16
     510:	ff 2d       	mov	r31, r15
     512:	de 01       	movw	r26, r28
     514:	11 96       	adiw	r26, 0x01	; 1
     516:	8f e0       	ldi	r24, 0x0F	; 15
     518:	0d 90       	ld	r0, X+
     51a:	01 92       	st	Z+, r0
     51c:	81 50       	subi	r24, 0x01	; 1
     51e:	e1 f7       	brne	.-8      	; 0x518 <__stack+0xb9>
}
     520:	80 2f       	mov	r24, r16
     522:	9f 2d       	mov	r25, r15
     524:	2f 96       	adiw	r28, 0x0f	; 15
     526:	0f b6       	in	r0, 0x3f	; 63
     528:	f8 94       	cli
     52a:	de bf       	out	0x3e, r29	; 62
     52c:	0f be       	out	0x3f, r0	; 63
     52e:	cd bf       	out	0x3d, r28	; 61
     530:	df 91       	pop	r29
     532:	cf 91       	pop	r28
     534:	1f 91       	pop	r17
     536:	0f 91       	pop	r16
     538:	ff 90       	pop	r15
     53a:	ef 90       	pop	r14
     53c:	df 90       	pop	r13
     53e:	cf 90       	pop	r12
     540:	08 95       	ret

00000542 <motion_pin_config_pos>:
volatile unsigned int Degrees; //to accept angle in degrees for turning

//Function to configure ports to enable robot's motion
void motion_pin_config_pos (void) 
{
 DDRB = DDRB | 0x0F;   //set direction of the PORTB3 to PORTB0 pins as output
     542:	87 b3       	in	r24, 0x17	; 23
     544:	8f 60       	ori	r24, 0x0F	; 15
     546:	87 bb       	out	0x17, r24	; 23
 PORTB = PORTB & 0xF0; // set initial value of the PORTB3 to PORTB0 pins to logic 0
     548:	88 b3       	in	r24, 0x18	; 24
     54a:	80 7f       	andi	r24, 0xF0	; 240
     54c:	88 bb       	out	0x18, r24	; 24
 DDRD = DDRD | 0x30;   //Setting PD4 and PD5 pins as output for PWM generation
     54e:	81 b3       	in	r24, 0x11	; 17
     550:	80 63       	ori	r24, 0x30	; 48
     552:	81 bb       	out	0x11, r24	; 17
 PORTD = PORTD | 0x30; //PD4 and PD5 pins are for velocity control using PWM
     554:	82 b3       	in	r24, 0x12	; 18
     556:	80 63       	ori	r24, 0x30	; 48
     558:	82 bb       	out	0x12, r24	; 18
}
     55a:	08 95       	ret

0000055c <left_encoder_pin_config>:

//Function to configure INT1 (PORTD 3) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xF7;  //Set the direction of the PORTD 3 pin as input
     55c:	8b 98       	cbi	0x11, 3	; 17
 PORTD = PORTD | 0x08; //Enable internal pull-up for PORTD 3 pin
     55e:	93 9a       	sbi	0x12, 3	; 18
}
     560:	08 95       	ret

00000562 <right_encoder_pin_config>:

//Function to configure INT0 (PORTD 2) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xFB;  //Set the direction of the PORTD 2 pin as input
     562:	8a 98       	cbi	0x11, 2	; 17
 PORTD = PORTD | 0x04; //Enable internal pull-up for PORTD 2 pin
     564:	92 9a       	sbi	0x12, 2	; 18
}
     566:	08 95       	ret

00000568 <port_init_pos>:

//Function to initialize ports
void port_init_pos()
{
 motion_pin_config_pos();          //robot motion pins config
     568:	0e 94 a1 02 	call	0x542	; 0x542 <motion_pin_config_pos>
 left_encoder_pin_config();    //left encoder pin config
     56c:	0e 94 ae 02 	call	0x55c	; 0x55c <left_encoder_pin_config>
 right_encoder_pin_config();   //right encoder pin config	
     570:	0e 94 b1 02 	call	0x562	; 0x562 <right_encoder_pin_config>
}
     574:	08 95       	ret

00000576 <left_position_encoder_interrupt_init>:

void left_position_encoder_interrupt_init (void) //Interrupt 1 enable
{
 cli(); //Clears the global interrupt
     576:	f8 94       	cli
 MCUCR = MCUCR | 0x08; // INT1 is set to trigger with falling edge
     578:	85 b7       	in	r24, 0x35	; 53
     57a:	88 60       	ori	r24, 0x08	; 8
     57c:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x80;   // Enable Interrupt INT1 for left position encoder
     57e:	8b b7       	in	r24, 0x3b	; 59
     580:	80 68       	ori	r24, 0x80	; 128
     582:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     584:	78 94       	sei
}
     586:	08 95       	ret

00000588 <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 0 enable
{
 cli(); //Clears the global interrupt
     588:	f8 94       	cli
 MCUCR = MCUCR | 0x02; // INT0 is set to trigger with falling edge
     58a:	85 b7       	in	r24, 0x35	; 53
     58c:	82 60       	ori	r24, 0x02	; 2
     58e:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x40;   // Enable Interrupt INT5 for right position encoder
     590:	8b b7       	in	r24, 0x3b	; 59
     592:	80 64       	ori	r24, 0x40	; 64
     594:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     596:	78 94       	sei
}
     598:	08 95       	ret

0000059a <__vector_1>:

//ISR for right position encoder
ISR(INT0_vect)  
{
     59a:	1f 92       	push	r1
     59c:	0f 92       	push	r0
     59e:	0f b6       	in	r0, 0x3f	; 63
     5a0:	0f 92       	push	r0
     5a2:	11 24       	eor	r1, r1
     5a4:	8f 93       	push	r24
     5a6:	9f 93       	push	r25
     5a8:	af 93       	push	r26
     5aa:	bf 93       	push	r27
 ShaftCountRight++;  //increment right shaft position count
     5ac:	80 91 78 00 	lds	r24, 0x0078
     5b0:	90 91 79 00 	lds	r25, 0x0079
     5b4:	a0 91 7a 00 	lds	r26, 0x007A
     5b8:	b0 91 7b 00 	lds	r27, 0x007B
     5bc:	01 96       	adiw	r24, 0x01	; 1
     5be:	a1 1d       	adc	r26, r1
     5c0:	b1 1d       	adc	r27, r1
     5c2:	80 93 78 00 	sts	0x0078, r24
     5c6:	90 93 79 00 	sts	0x0079, r25
     5ca:	a0 93 7a 00 	sts	0x007A, r26
     5ce:	b0 93 7b 00 	sts	0x007B, r27
}
     5d2:	bf 91       	pop	r27
     5d4:	af 91       	pop	r26
     5d6:	9f 91       	pop	r25
     5d8:	8f 91       	pop	r24
     5da:	0f 90       	pop	r0
     5dc:	0f be       	out	0x3f, r0	; 63
     5de:	0f 90       	pop	r0
     5e0:	1f 90       	pop	r1
     5e2:	18 95       	reti

000005e4 <__vector_2>:

//ISR for left position encoder
ISR(INT1_vect)
{
     5e4:	1f 92       	push	r1
     5e6:	0f 92       	push	r0
     5e8:	0f b6       	in	r0, 0x3f	; 63
     5ea:	0f 92       	push	r0
     5ec:	11 24       	eor	r1, r1
     5ee:	8f 93       	push	r24
     5f0:	9f 93       	push	r25
     5f2:	af 93       	push	r26
     5f4:	bf 93       	push	r27
 ShaftCountLeft++;  //increment left shaft position count
     5f6:	80 91 7c 00 	lds	r24, 0x007C
     5fa:	90 91 7d 00 	lds	r25, 0x007D
     5fe:	a0 91 7e 00 	lds	r26, 0x007E
     602:	b0 91 7f 00 	lds	r27, 0x007F
     606:	01 96       	adiw	r24, 0x01	; 1
     608:	a1 1d       	adc	r26, r1
     60a:	b1 1d       	adc	r27, r1
     60c:	80 93 7c 00 	sts	0x007C, r24
     610:	90 93 7d 00 	sts	0x007D, r25
     614:	a0 93 7e 00 	sts	0x007E, r26
     618:	b0 93 7f 00 	sts	0x007F, r27
}
     61c:	bf 91       	pop	r27
     61e:	af 91       	pop	r26
     620:	9f 91       	pop	r25
     622:	8f 91       	pop	r24
     624:	0f 90       	pop	r0
     626:	0f be       	out	0x3f, r0	; 63
     628:	0f 90       	pop	r0
     62a:	1f 90       	pop	r1
     62c:	18 95       	reti

0000062e <motion_set_pos>:
void motion_set_pos (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortBRestore = PORTB; 		// reading the PORT original status
     62e:	98 b3       	in	r25, 0x18	; 24
 PortBRestore &= 0xF0; 		// making lower direction nibbel to 0
     630:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set_pos (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
     632:	8f 70       	andi	r24, 0x0F	; 15
 PortBRestore = PORTB; 		// reading the PORT original status
 PortBRestore &= 0xF0; 		// making lower direction nibbel to 0
 PortBRestore |= Direction; // adding lower nibbel for forward command and restoring the PORTB status
     634:	98 2b       	or	r25, r24
 PORTB = PortBRestore; 		// executing the command
     636:	98 bb       	out	0x18, r25	; 24
}
     638:	08 95       	ret

0000063a <forward_pos>:

void forward_pos (void) //both wheels forward
{
  motion_set_pos(0x06);
     63a:	86 e0       	ldi	r24, 0x06	; 6
     63c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     640:	08 95       	ret

00000642 <back_pos>:

void back_pos (void) //both wheels backward
{
  motion_set_pos(0x09);
     642:	89 e0       	ldi	r24, 0x09	; 9
     644:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     648:	08 95       	ret

0000064a <left_pos>:

void left_pos (void) //Left wheel backward, Right wheel forward
{
  motion_set_pos(0x05);
     64a:	85 e0       	ldi	r24, 0x05	; 5
     64c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     650:	08 95       	ret

00000652 <right_pos>:

void right_pos (void) //Left wheel forward, Right wheel backward
{
  motion_set_pos(0x0A);
     652:	8a e0       	ldi	r24, 0x0A	; 10
     654:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     658:	08 95       	ret

0000065a <soft_left_pos>:

void soft_left_pos (void) //Left wheel stationary, Right wheel forward
{
 motion_set_pos(0x04);
     65a:	84 e0       	ldi	r24, 0x04	; 4
     65c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     660:	08 95       	ret

00000662 <soft_right_pos>:

void soft_right_pos (void) //Left wheel forward, Right wheel is stationary
{
 motion_set_pos(0x02);
     662:	82 e0       	ldi	r24, 0x02	; 2
     664:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     668:	08 95       	ret

0000066a <soft_left_2_pos>:

void soft_left_2_pos (void) //Left wheel backward, right wheel stationary
{
 motion_set_pos(0x01);
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     670:	08 95       	ret

00000672 <soft_right_2_pos>:

void soft_right_2_pos (void) //Left wheel stationary, Right wheel backward
{
 motion_set_pos(0x08);
     672:	88 e0       	ldi	r24, 0x08	; 8
     674:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     678:	08 95       	ret

0000067a <stop_pos>:

void stop_pos (void)
{
  motion_set_pos(0x00);
     67a:	80 e0       	ldi	r24, 0x00	; 0
     67c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     680:	08 95       	ret

00000682 <angle_rotate>:


//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     682:	0f 93       	push	r16
     684:	1f 93       	push	r17
     686:	cf 93       	push	r28
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = (float) Degrees/ 12.85; // division by resolution to get shaft count 
     688:	bc 01       	movw	r22, r24
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	90 e0       	ldi	r25, 0x00	; 0
     68e:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <__floatunsisf>
     692:	2a e9       	ldi	r18, 0x9A	; 154
     694:	39 e9       	ldi	r19, 0x99	; 153
     696:	4d e4       	ldi	r20, 0x4D	; 77
     698:	51 e4       	ldi	r21, 0x41	; 65
     69a:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <__divsf3>
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     69e:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <__fixunssfsi>
     6a2:	dc 01       	movw	r26, r24
     6a4:	cb 01       	movw	r24, r22
     6a6:	a0 e0       	ldi	r26, 0x00	; 0
     6a8:	b0 e0       	ldi	r27, 0x00	; 0
 ShaftCountRight = 0; 
     6aa:	10 92 78 00 	sts	0x0078, r1
     6ae:	10 92 79 00 	sts	0x0079, r1
     6b2:	10 92 7a 00 	sts	0x007A, r1
     6b6:	10 92 7b 00 	sts	0x007B, r1
 ShaftCountLeft = 0; 
     6ba:	10 92 7c 00 	sts	0x007C, r1
     6be:	10 92 7d 00 	sts	0x007D, r1
     6c2:	10 92 7e 00 	sts	0x007E, r1
     6c6:	10 92 7f 00 	sts	0x007F, r1

 while (1)
 {
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     6ca:	f1 e0       	ldi	r31, 0x01	; 1
     6cc:	c0 e0       	ldi	r28, 0x00	; 0
     6ce:	40 91 78 00 	lds	r20, 0x0078
     6d2:	50 91 79 00 	lds	r21, 0x0079
     6d6:	60 91 7a 00 	lds	r22, 0x007A
     6da:	70 91 7b 00 	lds	r23, 0x007B
     6de:	00 91 7c 00 	lds	r16, 0x007C
     6e2:	10 91 7d 00 	lds	r17, 0x007D
     6e6:	20 91 7e 00 	lds	r18, 0x007E
     6ea:	30 91 7f 00 	lds	r19, 0x007F
     6ee:	ef 2f       	mov	r30, r31
     6f0:	48 17       	cp	r20, r24
     6f2:	59 07       	cpc	r21, r25
     6f4:	6a 07       	cpc	r22, r26
     6f6:	7b 07       	cpc	r23, r27
     6f8:	08 f4       	brcc	.+2      	; 0x6fc <angle_rotate+0x7a>
     6fa:	ec 2f       	mov	r30, r28
     6fc:	ee 23       	and	r30, r30
     6fe:	49 f4       	brne	.+18     	; 0x712 <angle_rotate+0x90>
     700:	4f 2f       	mov	r20, r31
     702:	08 17       	cp	r16, r24
     704:	19 07       	cpc	r17, r25
     706:	2a 07       	cpc	r18, r26
     708:	3b 07       	cpc	r19, r27
     70a:	08 f4       	brcc	.+2      	; 0x70e <angle_rotate+0x8c>
     70c:	4c 2f       	mov	r20, r28
     70e:	44 23       	and	r20, r20
     710:	f1 f2       	breq	.-68     	; 0x6ce <angle_rotate+0x4c>
  break;
 }
 stop_pos(); //Stop robot
     712:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
}
     716:	cf 91       	pop	r28
     718:	1f 91       	pop	r17
     71a:	0f 91       	pop	r16
     71c:	08 95       	ret

0000071e <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = DistanceInMM / 12.92; // division by resolution to get shaft count
     71e:	bc 01       	movw	r22, r24
     720:	80 e0       	ldi	r24, 0x00	; 0
     722:	90 e0       	ldi	r25, 0x00	; 0
     724:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <__floatunsisf>
     728:	22 e5       	ldi	r18, 0x52	; 82
     72a:	38 eb       	ldi	r19, 0xB8	; 184
     72c:	4e e4       	ldi	r20, 0x4E	; 78
     72e:	51 e4       	ldi	r21, 0x41	; 65
     730:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <__divsf3>
 ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     734:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <__fixunssfsi>
     738:	46 2f       	mov	r20, r22
     73a:	57 2f       	mov	r21, r23
     73c:	68 2f       	mov	r22, r24
     73e:	79 2f       	mov	r23, r25
  
 ShaftCountRight = 0;
     740:	10 92 78 00 	sts	0x0078, r1
     744:	10 92 79 00 	sts	0x0079, r1
     748:	10 92 7a 00 	sts	0x007A, r1
     74c:	10 92 7b 00 	sts	0x007B, r1
 while(1)
 {
  if(ShaftCountRight > ReqdShaftCountInt)
     750:	80 91 78 00 	lds	r24, 0x0078
     754:	90 91 79 00 	lds	r25, 0x0079
     758:	a0 91 7a 00 	lds	r26, 0x007A
     75c:	b0 91 7b 00 	lds	r27, 0x007B
     760:	48 17       	cp	r20, r24
     762:	59 07       	cpc	r21, r25
     764:	6a 07       	cpc	r22, r26
     766:	7b 07       	cpc	r23, r27
     768:	98 f7       	brcc	.-26     	; 0x750 <linear_distance_mm+0x32>
  {
  	break;
  }
 } 
 stop_pos(); //Stop robot
     76a:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
}
     76e:	08 95       	ret

00000770 <forward_mm>:

void forward_mm(unsigned int DistanceInMM)
{
     770:	cf 93       	push	r28
     772:	df 93       	push	r29
     774:	ec 01       	movw	r28, r24
 forward_pos();
     776:	0e 94 1d 03 	call	0x63a	; 0x63a <forward_pos>
 linear_distance_mm(DistanceInMM);
     77a:	ce 01       	movw	r24, r28
     77c:	0e 94 8f 03 	call	0x71e	; 0x71e <linear_distance_mm>
}
     780:	df 91       	pop	r29
     782:	cf 91       	pop	r28
     784:	08 95       	ret

00000786 <back_mm>:

void back_mm(unsigned int DistanceInMM)
{
     786:	cf 93       	push	r28
     788:	df 93       	push	r29
     78a:	ec 01       	movw	r28, r24
 back_pos();
     78c:	0e 94 21 03 	call	0x642	; 0x642 <back_pos>
 linear_distance_mm(DistanceInMM);
     790:	ce 01       	movw	r24, r28
     792:	0e 94 8f 03 	call	0x71e	; 0x71e <linear_distance_mm>
}
     796:	df 91       	pop	r29
     798:	cf 91       	pop	r28
     79a:	08 95       	ret

0000079c <left_degrees>:

void left_degrees(unsigned int Degrees) 
{
     79c:	cf 93       	push	r28
     79e:	df 93       	push	r29
     7a0:	ec 01       	movw	r28, r24
// 28 pulses for 360 degrees rotation 12.92 degrees per count
 left_pos(); //Turn left
     7a2:	0e 94 25 03 	call	0x64a	; 0x64a <left_pos>
 angle_rotate(Degrees);
     7a6:	ce 01       	movw	r24, r28
     7a8:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     7ac:	df 91       	pop	r29
     7ae:	cf 91       	pop	r28
     7b0:	08 95       	ret

000007b2 <right_degrees>:



void right_degrees(unsigned int Degrees)
{
     7b2:	cf 93       	push	r28
     7b4:	df 93       	push	r29
     7b6:	ec 01       	movw	r28, r24
// 28 pulses for 360 degrees rotation 12.92 degrees per count
 right_pos(); //Turn right
     7b8:	0e 94 29 03 	call	0x652	; 0x652 <right_pos>
 angle_rotate(Degrees);
     7bc:	ce 01       	movw	r24, r28
     7be:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     7c2:	df 91       	pop	r29
     7c4:	cf 91       	pop	r28
     7c6:	08 95       	ret

000007c8 <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)
{
     7c8:	cf 93       	push	r28
     7ca:	df 93       	push	r29
     7cc:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_left_pos(); //Turn soft left
     7ce:	0e 94 2d 03 	call	0x65a	; 0x65a <soft_left_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     7d2:	ce 01       	movw	r24, r28
     7d4:	88 0f       	add	r24, r24
     7d6:	99 1f       	adc	r25, r25
     7d8:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     7dc:	df 91       	pop	r29
     7de:	cf 91       	pop	r28
     7e0:	08 95       	ret

000007e2 <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
     7e2:	cf 93       	push	r28
     7e4:	df 93       	push	r29
     7e6:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_right_pos();  //Turn soft right
     7e8:	0e 94 31 03 	call	0x662	; 0x662 <soft_right_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     7ec:	ce 01       	movw	r24, r28
     7ee:	88 0f       	add	r24, r24
     7f0:	99 1f       	adc	r25, r25
     7f2:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     7f6:	df 91       	pop	r29
     7f8:	cf 91       	pop	r28
     7fa:	08 95       	ret

000007fc <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
     7fc:	cf 93       	push	r28
     7fe:	df 93       	push	r29
     800:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_left_2_pos(); //Turn reverse soft left
     802:	0e 94 35 03 	call	0x66a	; 0x66a <soft_left_2_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     806:	ce 01       	movw	r24, r28
     808:	88 0f       	add	r24, r24
     80a:	99 1f       	adc	r25, r25
     80c:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     810:	df 91       	pop	r29
     812:	cf 91       	pop	r28
     814:	08 95       	ret

00000816 <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
     816:	cf 93       	push	r28
     818:	df 93       	push	r29
     81a:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_right_2_pos();  //Turn reverse soft right
     81c:	0e 94 39 03 	call	0x672	; 0x672 <soft_right_2_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     820:	ce 01       	movw	r24, r28
     822:	88 0f       	add	r24, r24
     824:	99 1f       	adc	r25, r25
     826:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     82a:	df 91       	pop	r29
     82c:	cf 91       	pop	r28
     82e:	08 95       	ret

00000830 <init_devices_pos>:

//Function to initialize all the devices
void init_devices_pos()
{
 cli(); //Clears the global interrupt
     830:	f8 94       	cli
 port_init_pos();  //Initializes all the ports
     832:	0e 94 b4 02 	call	0x568	; 0x568 <port_init_pos>
 left_position_encoder_interrupt_init();
     836:	0e 94 bb 02 	call	0x576	; 0x576 <left_position_encoder_interrupt_init>
 right_position_encoder_interrupt_init();
     83a:	0e 94 c4 02 	call	0x588	; 0x588 <right_position_encoder_interrupt_init>
 sei();   // Enables the global interrupt 
     83e:	78 94       	sei
}
     840:	08 95       	ret

00000842 <servo1_pin_config>:
#include <util/delay.h>

//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
	DDRD  = DDRD | 0x80;  //making PORTB 5 pin output
     842:	8f 9a       	sbi	0x11, 7	; 17
	PORTD = PORTD | 0x80; //setting PORTB 5 pin to logic 1
     844:	97 9a       	sbi	0x12, 7	; 18
}
     846:	08 95       	ret

00000848 <port_init_servo>:
void port_init_servo(void)
{
	servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
     848:	0e 94 21 04 	call	0x842	; 0x842 <servo1_pin_config>
	
}
     84c:	08 95       	ret

0000084e <timer2_init>:
void timer2_init(void)
{
 TCCR2= 0x00; //stop
     84e:	15 bc       	out	0x25, r1	; 37
 TCNT2 = 0xFE;
     850:	8e ef       	ldi	r24, 0xFE	; 254
     852:	84 bd       	out	0x24, r24	; 36
 OCR2 = 0x8F;
     854:	8f e8       	ldi	r24, 0x8F	; 143
     856:	83 bd       	out	0x23, r24	; 35
 TCCR2= (1<< COM21)|(1<<WGM20)|(1<<WGM21);
     858:	88 e6       	ldi	r24, 0x68	; 104
     85a:	85 bd       	out	0x25, r24	; 37
 //OCR2 = 0x8F;	//Output compare Register high value for servo 1
 
 
 
 
 TCCR2|= (1<<CS22)|(1<<CS20);
     85c:	85 b5       	in	r24, 0x25	; 37
     85e:	85 60       	ori	r24, 0x05	; 5
     860:	85 bd       	out	0x25, r24	; 37
 
}
     862:	08 95       	ret

00000864 <init_devices_servo>:
void init_devices_servo(void)
{
	cli(); //disable all interrupts
     864:	f8 94       	cli
	port_init_servo();
     866:	0e 94 24 04 	call	0x848	; 0x848 <port_init_servo>
	timer2_init();
     86a:	0e 94 27 04 	call	0x84e	; 0x84e <timer2_init>
	sei(); //re-enable interrupts
     86e:	78 94       	sei
}
     870:	08 95       	ret

00000872 <servo_1>:

void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
     872:	68 2f       	mov	r22, r24
     874:	70 e0       	ldi	r23, 0x00	; 0
     876:	80 e0       	ldi	r24, 0x00	; 0
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <__floatunsisf>
     87e:	2b e7       	ldi	r18, 0x7B	; 123
     880:	34 e1       	ldi	r19, 0x14	; 20
     882:	4e ee       	ldi	r20, 0xEE	; 238
     884:	5f e3       	ldi	r21, 0x3F	; 63
     886:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <__divsf3>
     88a:	20 e0       	ldi	r18, 0x00	; 0
     88c:	30 e0       	ldi	r19, 0x00	; 0
     88e:	4c e0       	ldi	r20, 0x0C	; 12
     890:	52 e4       	ldi	r21, 0x42	; 66
     892:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <__addsf3>
	
	//OCR1AH = 0x00;
	OCR2 = (unsigned char) PositionPanServo;
     896:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <__fixunssfsi>
     89a:	63 bd       	out	0x23, r22	; 35
}
     89c:	08 95       	ret

0000089e <servo_1_free>:
void servo_1_free (void) //makes servo 1 free rotating
{
	//OCR1AH = 0x03;
	OCR2 = 0x8F; //Servo 1 off
     89e:	8f e8       	ldi	r24, 0x8F	; 143
     8a0:	83 bd       	out	0x23, r24	; 35
}
     8a2:	08 95       	ret

000008a4 <adc_pin_config_sharp>:
}*/

//ADC pin configuration
void adc_pin_config_sharp (void)
{
 DDRA = 0x00;  //set PORTF direction as input
     8a4:	1a ba       	out	0x1a, r1	; 26
 PORTA = 0x00; //set PORTF pins floating
     8a6:	1b ba       	out	0x1b, r1	; 27
}
     8a8:	08 95       	ret

000008aa <ultrsonic_trigger_config>:

void ultrsonic_trigger_config(void)
{
 DDRD = DDRD | 0x40;   //all the LCD pin's direction set as output
     8aa:	8e 9a       	sbi	0x11, 6	; 17
 PORTD = PORTD & 0x00; // all the LCD pins are set to logic 0 except PORTC 7
     8ac:	82 b3       	in	r24, 0x12	; 18
     8ae:	12 ba       	out	0x12, r1	; 18
}
     8b0:	08 95       	ret

000008b2 <port_init_sharp>:

//Function to Initialize PORTs
void port_init_sharp()
{
 //lcd_port_config();
 adc_pin_config_sharp();		
     8b2:	0e 94 52 04 	call	0x8a4	; 0x8a4 <adc_pin_config_sharp>
 ultrsonic_trigger_config();
     8b6:	0e 94 55 04 	call	0x8aa	; 0x8aa <ultrsonic_trigger_config>
}
     8ba:	08 95       	ret

000008bc <adc_init_sharp>:

//Function to Initialize ADC
void adc_init_sharp()
{
 ADCSRA = 0x00;
     8bc:	16 b8       	out	0x06, r1	; 6
 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     8be:	80 e2       	ldi	r24, 0x20	; 32
     8c0:	87 b9       	out	0x07, r24	; 7
 ACSR = 0x80;
     8c2:	80 e8       	ldi	r24, 0x80	; 128
     8c4:	88 b9       	out	0x08, r24	; 8
 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     8c6:	86 e8       	ldi	r24, 0x86	; 134
     8c8:	86 b9       	out	0x06, r24	; 6
}
     8ca:	08 95       	ret

000008cc <ADC_Conversion_sharp>:

//This Function accepts the Channel Number and returns the corresponding Analog Value 
unsigned char ADC_Conversion_sharp(unsigned char Ch)
{
 unsigned char a;
 Ch = Ch & 0x07;  			
     8cc:	87 70       	andi	r24, 0x07	; 7
 ADMUX= 0x20| Ch;	   		
     8ce:	80 62       	ori	r24, 0x20	; 32
     8d0:	87 b9       	out	0x07, r24	; 7
 ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     8d2:	36 9a       	sbi	0x06, 6	; 6
 while((ADCSRA&0x10)==0);	    //Wait for ADC conversion to complete
     8d4:	34 9b       	sbis	0x06, 4	; 6
     8d6:	fe cf       	rjmp	.-4      	; 0x8d4 <ADC_Conversion_sharp+0x8>
 a=ADCH;
     8d8:	85 b1       	in	r24, 0x05	; 5
 ADCSRA = ADCSRA|0x10;          //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     8da:	34 9a       	sbi	0x06, 4	; 6
 return a;
}
     8dc:	08 95       	ret

000008de <ultrasonic_trigger>:

// Ultrasonic sensor are connected in chaining mode. This function rise a 
// trigger pulse of >20usec to command ringing.     
void ultrasonic_trigger(void)                 
{
 PORTD = PORTD | 0x40;  // make high the Trigger input for Ultrasonic sensor
     8de:	96 9a       	sbi	0x12, 6	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     8e0:	8b e7       	ldi	r24, 0x7B	; 123
     8e2:	8a 95       	dec	r24
     8e4:	f1 f7       	brne	.-4      	; 0x8e2 <ultrasonic_trigger+0x4>
 _delay_us(50);         // Wait for >20usec
 PORTD = PORTD & 0xBF;  // make low the Trigger input for Ultrasonic sensor
     8e6:	96 98       	cbi	0x12, 6	; 18
}
     8e8:	08 95       	ret

000008ea <init_devices_sharp>:

void init_devices_sharp (void)
{
 cli();           //Clears the global interrupts
     8ea:	f8 94       	cli
 port_init_sharp();
     8ec:	0e 94 59 04 	call	0x8b2	; 0x8b2 <port_init_sharp>
 adc_init_sharp();
     8f0:	0e 94 5e 04 	call	0x8bc	; 0x8bc <adc_init_sharp>
 sei();           //Enables the global interrupts
     8f4:	78 94       	sei
}
     8f6:	08 95       	ret

000008f8 <servo100>:
unsigned char Left_white_line = 0;
unsigned char Center_white_line = 0;
unsigned char Right_white_line = 0;

void servo100()
{
     8f8:	cf 93       	push	r28
     8fa:	cf e5       	ldi	r28, 0x5F	; 95
	for(int i=95;i<=180;i=i+3)
	{
		init_devices_sharp();
     8fc:	0e 94 75 04 	call	0x8ea	; 0x8ea <init_devices_sharp>
		//			lcd_set_4bit();
		//			lcd_init();
		for (int i=0;i<2;i++)
		{
			Center_ultrasonic_Sensor = ADC_Conversion_sharp(1) * 2;
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	0e 94 66 04 	call	0x8cc	; 0x8cc <ADC_Conversion_sharp>
     906:	88 0f       	add	r24, r24
     908:	80 93 d8 00 	sts	0x00D8, r24
     90c:	81 e0       	ldi	r24, 0x01	; 1
     90e:	0e 94 66 04 	call	0x8cc	; 0x8cc <ADC_Conversion_sharp>
     912:	88 0f       	add	r24, r24
     914:	80 93 d8 00 	sts	0x00D8, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     918:	8f ef       	ldi	r24, 0xFF	; 255
     91a:	9f e3       	ldi	r25, 0x3F	; 63
     91c:	a2 e0       	ldi	r26, 0x02	; 2
     91e:	81 50       	subi	r24, 0x01	; 1
     920:	90 40       	sbci	r25, 0x00	; 0
     922:	a0 40       	sbci	r26, 0x00	; 0
     924:	e1 f7       	brne	.-8      	; 0x91e <servo100+0x26>
     926:	00 c0       	rjmp	.+0      	; 0x928 <servo100+0x30>
     928:	00 00       	nop
			//lcd_print(2,12,Center_ultrasonic_Sensor,3);       // In Inches
			
		}
		_delay_ms(100);
		
		init_devices_servo();
     92a:	0e 94 32 04 	call	0x864	; 0x864 <init_devices_servo>
		servo_1(i);
     92e:	8c 2f       	mov	r24, r28
     930:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     934:	af ef       	ldi	r26, 0xFF	; 255
     936:	b7 e4       	ldi	r27, 0x47	; 71
     938:	11 97       	sbiw	r26, 0x01	; 1
     93a:	f1 f7       	brne	.-4      	; 0x938 <servo100+0x40>
     93c:	00 c0       	rjmp	.+0      	; 0x93e <servo100+0x46>
     93e:	00 00       	nop
		_delay_ms(10);
		
		
		if(Center_ultrasonic_Sensor>200 )
     940:	80 91 d8 00 	lds	r24, 0x00D8
     944:	89 3c       	cpi	r24, 0xC9	; 201
     946:	d0 f0       	brcs	.+52     	; 0x97c <servo100+0x84>
		{
			/*servo_1(i);
			_delay_ms(1000);*/
			//buzzer_beep();
			side=100;
     948:	84 e6       	ldi	r24, 0x64	; 100
     94a:	80 93 74 00 	sts	0x0074, r24
			color_sensor_work();
     94e:	0e 94 bb 08 	call	0x1176	; 0x1176 <color_sensor_work>
     952:	8f ef       	ldi	r24, 0xFF	; 255
     954:	9f e3       	ldi	r25, 0x3F	; 63
     956:	a2 e0       	ldi	r26, 0x02	; 2
     958:	81 50       	subi	r24, 0x01	; 1
     95a:	90 40       	sbci	r25, 0x00	; 0
     95c:	a0 40       	sbci	r26, 0x00	; 0
     95e:	e1 f7       	brne	.-8      	; 0x958 <servo100+0x60>
     960:	00 c0       	rjmp	.+0      	; 0x962 <servo100+0x6a>
     962:	00 00       	nop
			
			_delay_ms(100);
			do_task();
     964:	0e 94 49 00 	call	0x92	; 0x92 <do_task>
     968:	8f ef       	ldi	r24, 0xFF	; 255
     96a:	9f e3       	ldi	r25, 0x3F	; 63
     96c:	ab e0       	ldi	r26, 0x0B	; 11
     96e:	81 50       	subi	r24, 0x01	; 1
     970:	90 40       	sbci	r25, 0x00	; 0
     972:	a0 40       	sbci	r26, 0x00	; 0
     974:	e1 f7       	brne	.-8      	; 0x96e <servo100+0x76>
     976:	00 c0       	rjmp	.+0      	; 0x978 <servo100+0x80>
     978:	00 00       	nop
     97a:	04 c0       	rjmp	.+8      	; 0x984 <servo100+0x8c>
     97c:	cd 5f       	subi	r28, 0xFD	; 253
unsigned char Center_white_line = 0;
unsigned char Right_white_line = 0;

void servo100()
{
	for(int i=95;i<=180;i=i+3)
     97e:	c6 3b       	cpi	r28, 0xB6	; 182
     980:	09 f0       	breq	.+2      	; 0x984 <servo100+0x8c>
     982:	bc cf       	rjmp	.-136    	; 0x8fc <servo100+0x4>
     984:	8f ef       	ldi	r24, 0xFF	; 255
     986:	9f e3       	ldi	r25, 0x3F	; 63
     988:	ab e0       	ldi	r26, 0x0B	; 11
     98a:	81 50       	subi	r24, 0x01	; 1
     98c:	90 40       	sbci	r25, 0x00	; 0
     98e:	a0 40       	sbci	r26, 0x00	; 0
     990:	e1 f7       	brne	.-8      	; 0x98a <servo100+0x92>
     992:	00 c0       	rjmp	.+0      	; 0x994 <servo100+0x9c>
     994:	00 00       	nop
			
		}
		
	}
	_delay_ms(500);
	servo_1(95);
     996:	8f e5       	ldi	r24, 0x5F	; 95
     998:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     99c:	8f ef       	ldi	r24, 0xFF	; 255
     99e:	9f e3       	ldi	r25, 0x3F	; 63
     9a0:	ab e0       	ldi	r26, 0x0B	; 11
     9a2:	81 50       	subi	r24, 0x01	; 1
     9a4:	90 40       	sbci	r25, 0x00	; 0
     9a6:	a0 40       	sbci	r26, 0x00	; 0
     9a8:	e1 f7       	brne	.-8      	; 0x9a2 <servo100+0xaa>
     9aa:	00 c0       	rjmp	.+0      	; 0x9ac <servo100+0xb4>
     9ac:	00 00       	nop
	_delay_ms(500);
	
}
     9ae:	cf 91       	pop	r28
     9b0:	08 95       	ret

000009b2 <servo101>:
void servo101()
{
     9b2:	cf 93       	push	r28
     9b4:	cf e5       	ldi	r28, 0x5F	; 95
	for(int i=95;i>=10;i=i-3)
	{
		init_devices_sharp();
     9b6:	0e 94 75 04 	call	0x8ea	; 0x8ea <init_devices_sharp>
		//			lcd_set_4bit();
		//			lcd_init();
		for (int i=0;i<2;i++)
		{
			Center_ultrasonic_Sensor = ADC_Conversion_sharp(1) * 2;
     9ba:	81 e0       	ldi	r24, 0x01	; 1
     9bc:	0e 94 66 04 	call	0x8cc	; 0x8cc <ADC_Conversion_sharp>
     9c0:	88 0f       	add	r24, r24
     9c2:	80 93 d8 00 	sts	0x00D8, r24
     9c6:	81 e0       	ldi	r24, 0x01	; 1
     9c8:	0e 94 66 04 	call	0x8cc	; 0x8cc <ADC_Conversion_sharp>
     9cc:	88 0f       	add	r24, r24
     9ce:	80 93 d8 00 	sts	0x00D8, r24
     9d2:	8f ef       	ldi	r24, 0xFF	; 255
     9d4:	9f e3       	ldi	r25, 0x3F	; 63
     9d6:	a2 e0       	ldi	r26, 0x02	; 2
     9d8:	81 50       	subi	r24, 0x01	; 1
     9da:	90 40       	sbci	r25, 0x00	; 0
     9dc:	a0 40       	sbci	r26, 0x00	; 0
     9de:	e1 f7       	brne	.-8      	; 0x9d8 <servo101+0x26>
     9e0:	00 c0       	rjmp	.+0      	; 0x9e2 <servo101+0x30>
     9e2:	00 00       	nop
			//lcd_print(2,12,Center_ultrasonic_Sensor,3);       // In Inches
			
		}
		_delay_ms(100);
		
		init_devices_servo();
     9e4:	0e 94 32 04 	call	0x864	; 0x864 <init_devices_servo>
		servo_1(i);
     9e8:	8c 2f       	mov	r24, r28
     9ea:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     9ee:	af ef       	ldi	r26, 0xFF	; 255
     9f0:	b7 e4       	ldi	r27, 0x47	; 71
     9f2:	11 97       	sbiw	r26, 0x01	; 1
     9f4:	f1 f7       	brne	.-4      	; 0x9f2 <servo101+0x40>
     9f6:	00 c0       	rjmp	.+0      	; 0x9f8 <servo101+0x46>
     9f8:	00 00       	nop
		_delay_ms(10);
		
		
		if(Center_ultrasonic_Sensor>200 )
     9fa:	80 91 d8 00 	lds	r24, 0x00D8
     9fe:	89 3c       	cpi	r24, 0xC9	; 201
     a00:	d0 f0       	brcs	.+52     	; 0xa36 <servo101+0x84>
		{	//servo_1_free();
			//_delay_ms(1000);
			//buzzer_beep();
			side=101;
     a02:	85 e6       	ldi	r24, 0x65	; 101
     a04:	80 93 74 00 	sts	0x0074, r24
			color_sensor_work();
     a08:	0e 94 bb 08 	call	0x1176	; 0x1176 <color_sensor_work>
     a0c:	8f ef       	ldi	r24, 0xFF	; 255
     a0e:	9f e3       	ldi	r25, 0x3F	; 63
     a10:	a2 e0       	ldi	r26, 0x02	; 2
     a12:	81 50       	subi	r24, 0x01	; 1
     a14:	90 40       	sbci	r25, 0x00	; 0
     a16:	a0 40       	sbci	r26, 0x00	; 0
     a18:	e1 f7       	brne	.-8      	; 0xa12 <servo101+0x60>
     a1a:	00 c0       	rjmp	.+0      	; 0xa1c <servo101+0x6a>
     a1c:	00 00       	nop
			
			_delay_ms(100);
			do_task();
     a1e:	0e 94 49 00 	call	0x92	; 0x92 <do_task>
     a22:	8f ef       	ldi	r24, 0xFF	; 255
     a24:	9f e3       	ldi	r25, 0x3F	; 63
     a26:	ab e0       	ldi	r26, 0x0B	; 11
     a28:	81 50       	subi	r24, 0x01	; 1
     a2a:	90 40       	sbci	r25, 0x00	; 0
     a2c:	a0 40       	sbci	r26, 0x00	; 0
     a2e:	e1 f7       	brne	.-8      	; 0xa28 <servo101+0x76>
     a30:	00 c0       	rjmp	.+0      	; 0xa32 <servo101+0x80>
     a32:	00 00       	nop
     a34:	04 c0       	rjmp	.+8      	; 0xa3e <servo101+0x8c>
     a36:	c3 50       	subi	r28, 0x03	; 3
	_delay_ms(500);
	
}
void servo101()
{
	for(int i=95;i>=10;i=i-3)
     a38:	c8 30       	cpi	r28, 0x08	; 8
     a3a:	09 f0       	breq	.+2      	; 0xa3e <servo101+0x8c>
     a3c:	bc cf       	rjmp	.-136    	; 0x9b6 <servo101+0x4>
     a3e:	8f ef       	ldi	r24, 0xFF	; 255
     a40:	9f e3       	ldi	r25, 0x3F	; 63
     a42:	ab e0       	ldi	r26, 0x0B	; 11
     a44:	81 50       	subi	r24, 0x01	; 1
     a46:	90 40       	sbci	r25, 0x00	; 0
     a48:	a0 40       	sbci	r26, 0x00	; 0
     a4a:	e1 f7       	brne	.-8      	; 0xa44 <servo101+0x92>
     a4c:	00 c0       	rjmp	.+0      	; 0xa4e <servo101+0x9c>
     a4e:	00 00       	nop
			break;
		}
		
	}
	_delay_ms(500);
	servo_1(95);
     a50:	8f e5       	ldi	r24, 0x5F	; 95
     a52:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     a56:	8f ef       	ldi	r24, 0xFF	; 255
     a58:	9f e3       	ldi	r25, 0x3F	; 63
     a5a:	a2 e0       	ldi	r26, 0x02	; 2
     a5c:	81 50       	subi	r24, 0x01	; 1
     a5e:	90 40       	sbci	r25, 0x00	; 0
     a60:	a0 40       	sbci	r26, 0x00	; 0
     a62:	e1 f7       	brne	.-8      	; 0xa5c <servo101+0xaa>
     a64:	00 c0       	rjmp	.+0      	; 0xa66 <servo101+0xb4>
     a66:	00 00       	nop
	_delay_ms(100);
}
     a68:	cf 91       	pop	r28
     a6a:	08 95       	ret

00000a6c <lcd_port_config>:


//Function to configure LCD port
void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7;    //all the LCD pin's direction set as output
     a6c:	84 b3       	in	r24, 0x14	; 20
     a6e:	87 6f       	ori	r24, 0xF7	; 247
     a70:	84 bb       	out	0x14, r24	; 20
 PORTC = PORTC & 0x80;  // all the LCD pins are set to logic 0 except PORTC 7
     a72:	85 b3       	in	r24, 0x15	; 21
     a74:	80 78       	andi	r24, 0x80	; 128
     a76:	85 bb       	out	0x15, r24	; 21
}
     a78:	08 95       	ret

00000a7a <adc_pin_config>:

//ADC pin configuration
void adc_pin_config (void)
{
 DDRA = 0x00;   //set PORTF direction as input
     a7a:	1a ba       	out	0x1a, r1	; 26
 PORTA = 0x00;  //set PORTF pins floating
     a7c:	1b ba       	out	0x1b, r1	; 27
}
     a7e:	08 95       	ret

00000a80 <motion_pin_config>:

//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
 DDRB = DDRB | 0x0F;    //set direction of the PORTB3 to PORTB0 pins as output
     a80:	87 b3       	in	r24, 0x17	; 23
     a82:	8f 60       	ori	r24, 0x0F	; 15
     a84:	87 bb       	out	0x17, r24	; 23
 PORTB = PORTB & 0xF0;  //set initial value of the PORTB3 to PORTB0 pins to logic 0
     a86:	88 b3       	in	r24, 0x18	; 24
     a88:	80 7f       	andi	r24, 0xF0	; 240
     a8a:	88 bb       	out	0x18, r24	; 24
 DDRD = DDRD | 0x30;    //Setting PD5 and PD4 pins as output for PWM generation
     a8c:	81 b3       	in	r24, 0x11	; 17
     a8e:	80 63       	ori	r24, 0x30	; 48
     a90:	81 bb       	out	0x11, r24	; 17
 PORTD = PORTD | 0x30;  //PD5 and PD4 pins are for velocity control using PWM
     a92:	82 b3       	in	r24, 0x12	; 18
     a94:	80 63       	ori	r24, 0x30	; 48
     a96:	82 bb       	out	0x12, r24	; 18
}
     a98:	08 95       	ret

00000a9a <port_init>:

//Function to Initialize PORTS
void port_init()
{
 lcd_port_config();
     a9a:	0e 94 36 05 	call	0xa6c	; 0xa6c <lcd_port_config>
 adc_pin_config();		
     a9e:	0e 94 3d 05 	call	0xa7a	; 0xa7a <adc_pin_config>
 motion_pin_config();
     aa2:	0e 94 40 05 	call	0xa80	; 0xa80 <motion_pin_config>
}
     aa6:	08 95       	ret

00000aa8 <timer1_init>:
// WGM: 5) PWM 8bit fast, TOP=0x00FF
// desired value: 450Hz
// actual value: 450.000Hz (0.0%)
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     aa8:	1e bc       	out	0x2e, r1	; 46
 TCNT1H = 0xFF; //setup
     aaa:	8f ef       	ldi	r24, 0xFF	; 255
     aac:	8d bd       	out	0x2d, r24	; 45
 TCNT1L = 0x01;
     aae:	91 e0       	ldi	r25, 0x01	; 1
     ab0:	9c bd       	out	0x2c, r25	; 44
 OCR1AH = 0x00;
     ab2:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = 0xFF;
     ab4:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     ab6:	19 bc       	out	0x29, r1	; 41
 OCR1BL = 0xFF;
     ab8:	88 bd       	out	0x28, r24	; 40
 ICR1H  = 0x00;
     aba:	17 bc       	out	0x27, r1	; 39
 ICR1L  = 0xFF;
     abc:	86 bd       	out	0x26, r24	; 38
 TCCR1A = 0xA1;
     abe:	81 ea       	ldi	r24, 0xA1	; 161
     ac0:	8f bd       	out	0x2f, r24	; 47
 TCCR1B = 0x0D; //start Timer
     ac2:	8d e0       	ldi	r24, 0x0D	; 13
     ac4:	8e bd       	out	0x2e, r24	; 46
}
     ac6:	08 95       	ret

00000ac8 <adc_init>:


//Function to Initialize ADC
void adc_init()
{
 ADCSRA = 0x00;
     ac8:	16 b8       	out	0x06, r1	; 6
 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     aca:	80 e2       	ldi	r24, 0x20	; 32
     acc:	87 b9       	out	0x07, r24	; 7
 ACSR = 0x80;
     ace:	80 e8       	ldi	r24, 0x80	; 128
     ad0:	88 b9       	out	0x08, r24	; 8
 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     ad2:	86 e8       	ldi	r24, 0x86	; 134
     ad4:	86 b9       	out	0x06, r24	; 6
}
     ad6:	08 95       	ret

00000ad8 <ADC_Conversion>:

//This Function accepts the Channel Number and returns the corresponding Analog Value 
unsigned char ADC_Conversion(unsigned char Ch)
{
 unsigned char a;
 Ch = Ch & 0x07;  			
     ad8:	87 70       	andi	r24, 0x07	; 7
 ADMUX= 0x20| Ch;	   		
     ada:	80 62       	ori	r24, 0x20	; 32
     adc:	87 b9       	out	0x07, r24	; 7
 ADCSRA = ADCSRA | 0x40;	//Set start conversion bit
     ade:	36 9a       	sbi	0x06, 6	; 6
 while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     ae0:	34 9b       	sbis	0x06, 4	; 6
     ae2:	fe cf       	rjmp	.-4      	; 0xae0 <ADC_Conversion+0x8>
 a=ADCH;
     ae4:	85 b1       	in	r24, 0x05	; 5
 ADCSRA = ADCSRA|0x10;      //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     ae6:	34 9a       	sbi	0x06, 4	; 6
 return a;
}
     ae8:	08 95       	ret

00000aea <print_sensor>:

// This Function prints the Analog Value Of Corresponding Channel No. at required Row
// and Coloumn Location. 
void print_sensor(char row, char coloumn,unsigned char channel)
{
     aea:	84 2f       	mov	r24, r20
 ADC_Value = ADC_Conversion(channel);
     aec:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>
     af0:	80 93 d7 00 	sts	0x00D7, r24
// lcd_print(row, coloumn, ADC_Value, 3);
}
     af4:	08 95       	ret

00000af6 <motion_set>:
void motion_set (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 			// removing upper nibbel as it is not needed
 PortBRestore = PORTB; 			// reading the PORTB's original status
     af6:	98 b3       	in	r25, 0x18	; 24
 PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
     af8:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 			// removing upper nibbel as it is not needed
     afa:	8f 70       	andi	r24, 0x0F	; 15
 PortBRestore = PORTB; 			// reading the PORTB's original status
 PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
 PortBRestore |= Direction; 	// adding lower nibbel for direction command and restoring the PORTB status
     afc:	98 2b       	or	r25, r24
 PORTB = PortBRestore; 			// setting the command to the port
     afe:	98 bb       	out	0x18, r25	; 24
}
     b00:	08 95       	ret

00000b02 <forward>:

void forward (void) //both wheels forward
{
  motion_set(0x06);
     b02:	86 e0       	ldi	r24, 0x06	; 6
     b04:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b08:	08 95       	ret

00000b0a <back>:

void back (void) //hard stop
{
  motion_set(0x09);
     b0a:	89 e0       	ldi	r24, 0x09	; 9
     b0c:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b10:	08 95       	ret

00000b12 <left>:
void left (void) //hard stop
{
	motion_set(0x05);
     b12:	85 e0       	ldi	r24, 0x05	; 5
     b14:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b18:	08 95       	ret

00000b1a <right>:
void right (void) //hard stop
{
	motion_set(0x0A);
     b1a:	8a e0       	ldi	r24, 0x0A	; 10
     b1c:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b20:	08 95       	ret

00000b22 <hard_stop>:
void hard_stop (void) //hard stop
{
	motion_set(0x00);
     b22:	80 e0       	ldi	r24, 0x00	; 0
     b24:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b28:	08 95       	ret

00000b2a <s_L>:
void s_L (void) //hard stop
{
	motion_set(0x04);
     b2a:	84 e0       	ldi	r24, 0x04	; 4
     b2c:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b30:	08 95       	ret

00000b32 <S_R>:
void S_R (void) //hard stop
{
	motion_set(0x02);
     b32:	82 e0       	ldi	r24, 0x02	; 2
     b34:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b38:	08 95       	ret

00000b3a <S_STOP>:
void S_STOP (void) //hard stop
{
	motion_set(0x0F);
     b3a:	8f e0       	ldi	r24, 0x0F	; 15
     b3c:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b40:	08 95       	ret

00000b42 <velocity>:


//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
 OCR1AH = 0x00;
     b42:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = left_motor; 
     b44:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     b46:	19 bc       	out	0x29, r1	; 41
 OCR1BL = right_motor;
     b48:	68 bd       	out	0x28, r22	; 40
}
     b4a:	08 95       	ret

00000b4c <success>:
	}
}


void success(int x)
{
     b4c:	0f 93       	push	r16
     b4e:	1f 93       	push	r17
     b50:	cf 93       	push	r28
     b52:	df 93       	push	r29
     b54:	ec 01       	movw	r28, r24
	unsigned char Left_white_line = 0;
	unsigned char Center_white_line = 0;
	unsigned char Right_white_line = 0;
	
	buzzer_on();
     b56:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
     b5a:	8f ef       	ldi	r24, 0xFF	; 255
     b5c:	9f e3       	ldi	r25, 0x3F	; 63
     b5e:	ab e0       	ldi	r26, 0x0B	; 11
     b60:	81 50       	subi	r24, 0x01	; 1
     b62:	90 40       	sbci	r25, 0x00	; 0
     b64:	a0 40       	sbci	r26, 0x00	; 0
     b66:	e1 f7       	brne	.-8      	; 0xb60 <success+0x14>
     b68:	00 c0       	rjmp	.+0      	; 0xb6a <success+0x1e>
     b6a:	00 00       	nop
	_delay_ms(500);
	buzzer_off();
     b6c:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
	
	switch (x)
     b70:	c2 30       	cpi	r28, 0x02	; 2
     b72:	d1 05       	cpc	r29, r1
     b74:	b1 f0       	breq	.+44     	; 0xba2 <success+0x56>
     b76:	c3 30       	cpi	r28, 0x03	; 3
     b78:	d1 05       	cpc	r29, r1
     b7a:	19 f1       	breq	.+70     	; 0xbc2 <success+0x76>
     b7c:	c1 30       	cpi	r28, 0x01	; 1
     b7e:	d1 05       	cpc	r29, r1
     b80:	79 f5       	brne	.+94     	; 0xbe0 <success+0x94>
	{	
		case 1:
		velocity(VELOCITY_MAX,VELOCITY_MAX);      // Run robot at max velocity
     b82:	8c e3       	ldi	r24, 0x3C	; 60
     b84:	6c e3       	ldi	r22, 0x3C	; 60
     b86:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		forward();
     b8a:	0e 94 81 05 	call	0xb02	; 0xb02 <forward>
     b8e:	8f ef       	ldi	r24, 0xFF	; 255
     b90:	9f e3       	ldi	r25, 0x3F	; 63
     b92:	a2 e0       	ldi	r26, 0x02	; 2
     b94:	81 50       	subi	r24, 0x01	; 1
     b96:	90 40       	sbci	r25, 0x00	; 0
     b98:	a0 40       	sbci	r26, 0x00	; 0
     b9a:	e1 f7       	brne	.-8      	; 0xb94 <success+0x48>
     b9c:	00 c0       	rjmp	.+0      	; 0xb9e <success+0x52>
     b9e:	00 00       	nop
     ba0:	1f c0       	rjmp	.+62     	; 0xbe0 <success+0x94>
		_delay_ms(100);
		break;
		case 2:
		velocity(VELOCITY_MAX,VELOCITY_MIN);      // Run robot left wheel at max velocity and right wheel
     ba2:	8c e3       	ldi	r24, 0x3C	; 60
     ba4:	64 e1       	ldi	r22, 0x14	; 20
     ba6:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		right();
     baa:	0e 94 8d 05 	call	0xb1a	; 0xb1a <right>
     bae:	8f ef       	ldi	r24, 0xFF	; 255
     bb0:	9f e3       	ldi	r25, 0x3F	; 63
     bb2:	a4 e1       	ldi	r26, 0x14	; 20
     bb4:	81 50       	subi	r24, 0x01	; 1
     bb6:	90 40       	sbci	r25, 0x00	; 0
     bb8:	a0 40       	sbci	r26, 0x00	; 0
     bba:	e1 f7       	brne	.-8      	; 0xbb4 <success+0x68>
     bbc:	00 c0       	rjmp	.+0      	; 0xbbe <success+0x72>
     bbe:	00 00       	nop
     bc0:	0f c0       	rjmp	.+30     	; 0xbe0 <success+0x94>
		_delay_ms(900);
		
		break;
		case 3:
		velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel
     bc2:	84 e1       	ldi	r24, 0x14	; 20
     bc4:	6c e3       	ldi	r22, 0x3C	; 60
     bc6:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		left();
     bca:	0e 94 89 05 	call	0xb12	; 0xb12 <left>
     bce:	8f ef       	ldi	r24, 0xFF	; 255
     bd0:	9f e3       	ldi	r25, 0x3F	; 63
     bd2:	a4 e1       	ldi	r26, 0x14	; 20
     bd4:	81 50       	subi	r24, 0x01	; 1
     bd6:	90 40       	sbci	r25, 0x00	; 0
     bd8:	a0 40       	sbci	r26, 0x00	; 0
     bda:	e1 f7       	brne	.-8      	; 0xbd4 <success+0x88>
     bdc:	00 c0       	rjmp	.+0      	; 0xbde <success+0x92>
     bde:	00 00       	nop
	}
	
	while(1)
	{
		
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     be0:	83 e0       	ldi	r24, 0x03	; 3
     be2:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>
     be6:	08 2f       	mov	r16, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     be8:	82 e0       	ldi	r24, 0x02	; 2
     bea:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>
     bee:	18 2f       	mov	r17, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
     bf0:	81 e0       	ldi	r24, 0x01	; 1
     bf2:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>

//		print_sensor(1,1,3);	//Prints value of White Line Sensor1
		//print_sensor(1,5,2);	//Prints Value of White Line Sensor2
	//	print_sensor(1,9,1);	//Prints Value of White Line Sensor3

		if(Center_white_line<0x19 && Left_white_line<0x19 && Right_white_line<0x19)
     bf6:	19 31       	cpi	r17, 0x19	; 25
     bf8:	08 f0       	brcs	.+2      	; 0xbfc <success+0xb0>
     bfa:	48 c0       	rjmp	.+144    	; 0xc8c <success+0x140>
     bfc:	09 31       	cpi	r16, 0x19	; 25
     bfe:	08 f0       	brcs	.+2      	; 0xc02 <success+0xb6>
     c00:	45 c0       	rjmp	.+138    	; 0xc8c <success+0x140>
     c02:	89 31       	cpi	r24, 0x19	; 25
     c04:	08 f0       	brcs	.+2      	; 0xc08 <success+0xbc>
     c06:	42 c0       	rjmp	.+132    	; 0xc8c <success+0x140>
		{	buzzer_on();
     c08:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
     c0c:	8f ef       	ldi	r24, 0xFF	; 255
     c0e:	9f e3       	ldi	r25, 0x3F	; 63
     c10:	ab e0       	ldi	r26, 0x0B	; 11
     c12:	81 50       	subi	r24, 0x01	; 1
     c14:	90 40       	sbci	r25, 0x00	; 0
     c16:	a0 40       	sbci	r26, 0x00	; 0
     c18:	e1 f7       	brne	.-8      	; 0xc12 <success+0xc6>
     c1a:	00 c0       	rjmp	.+0      	; 0xc1c <success+0xd0>
     c1c:	00 00       	nop
			_delay_ms(500);
			buzzer_off();
     c1e:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
			switch (x)
     c22:	c2 30       	cpi	r28, 0x02	; 2
     c24:	d1 05       	cpc	r29, r1
     c26:	b1 f0       	breq	.+44     	; 0xc54 <success+0x108>
     c28:	c3 30       	cpi	r28, 0x03	; 3
     c2a:	d1 05       	cpc	r29, r1
     c2c:	09 f1       	breq	.+66     	; 0xc70 <success+0x124>
     c2e:	c1 30       	cpi	r28, 0x01	; 1
     c30:	d1 05       	cpc	r29, r1
     c32:	b1 f6       	brne	.-84     	; 0xbe0 <success+0x94>
			{
				case 1:
				velocity(VELOCITY_MAX,VELOCITY_MAX);      // Run robot at max velocity
     c34:	8c e3       	ldi	r24, 0x3C	; 60
     c36:	6c e3       	ldi	r22, 0x3C	; 60
     c38:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
				forward();
     c3c:	0e 94 81 05 	call	0xb02	; 0xb02 <forward>
     c40:	8f ef       	ldi	r24, 0xFF	; 255
     c42:	9f e3       	ldi	r25, 0x3F	; 63
     c44:	a2 e0       	ldi	r26, 0x02	; 2
     c46:	81 50       	subi	r24, 0x01	; 1
     c48:	90 40       	sbci	r25, 0x00	; 0
     c4a:	a0 40       	sbci	r26, 0x00	; 0
     c4c:	e1 f7       	brne	.-8      	; 0xc46 <success+0xfa>
     c4e:	00 c0       	rjmp	.+0      	; 0xc50 <success+0x104>
     c50:	00 00       	nop
     c52:	c6 cf       	rjmp	.-116    	; 0xbe0 <success+0x94>
				_delay_ms(100);
				break;
				case 2:
				velocity(VELOCITY_MAX,VELOCITY_MIN);      // Run robot left wheel at max velocity and right wheel
     c54:	8c e3       	ldi	r24, 0x3C	; 60
     c56:	64 e1       	ldi	r22, 0x14	; 20
     c58:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
				right();
     c5c:	0e 94 8d 05 	call	0xb1a	; 0xb1a <right>
     c60:	86 e6       	ldi	r24, 0x66	; 102
     c62:	96 e0       	ldi	r25, 0x06	; 6
     c64:	a2 e0       	ldi	r26, 0x02	; 2
     c66:	81 50       	subi	r24, 0x01	; 1
     c68:	90 40       	sbci	r25, 0x00	; 0
     c6a:	a0 40       	sbci	r26, 0x00	; 0
     c6c:	e1 f7       	brne	.-8      	; 0xc66 <success+0x11a>
     c6e:	b8 cf       	rjmp	.-144    	; 0xbe0 <success+0x94>
				_delay_ms(90);
				
				break;
				case 3:
				velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel
     c70:	84 e1       	ldi	r24, 0x14	; 20
     c72:	6c e3       	ldi	r22, 0x3C	; 60
     c74:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
				left();
     c78:	0e 94 89 05 	call	0xb12	; 0xb12 <left>
     c7c:	86 e6       	ldi	r24, 0x66	; 102
     c7e:	96 e0       	ldi	r25, 0x06	; 6
     c80:	a2 e0       	ldi	r26, 0x02	; 2
     c82:	81 50       	subi	r24, 0x01	; 1
     c84:	90 40       	sbci	r25, 0x00	; 0
     c86:	a0 40       	sbci	r26, 0x00	; 0
     c88:	e1 f7       	brne	.-8      	; 0xc82 <success+0x136>
     c8a:	aa cf       	rjmp	.-172    	; 0xbe0 <success+0x94>
		}


		

		else if((Left_white_line>THRESHOLD)) //&& (flag==0))
     c8c:	05 31       	cpi	r16, 0x15	; 21
     c8e:	80 f0       	brcs	.+32     	; 0xcb0 <success+0x164>
		{
			//flag=1;
			velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel
     c90:	84 e1       	ldi	r24, 0x14	; 20
     c92:	6c e3       	ldi	r22, 0x3C	; 60
     c94:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
			left();
     c98:	0e 94 89 05 	call	0xb12	; 0xb12 <left>
     c9c:	8f ef       	ldi	r24, 0xFF	; 255
     c9e:	9f eb       	ldi	r25, 0xBF	; 191
     ca0:	a6 e0       	ldi	r26, 0x06	; 6
     ca2:	81 50       	subi	r24, 0x01	; 1
     ca4:	90 40       	sbci	r25, 0x00	; 0
     ca6:	a0 40       	sbci	r26, 0x00	; 0
     ca8:	e1 f7       	brne	.-8      	; 0xca2 <success+0x156>
     caa:	00 c0       	rjmp	.+0      	; 0xcac <success+0x160>
     cac:	00 00       	nop
     cae:	24 c0       	rjmp	.+72     	; 0xcf8 <success+0x1ac>
			_delay_ms(300);
			break;
		}

		else if((Right_white_line>THRESHOLD))// && (flag==0))
     cb0:	85 31       	cpi	r24, 0x15	; 21
     cb2:	80 f0       	brcs	.+32     	; 0xcd4 <success+0x188>
		{
			//	flag=1;
			
			velocity(VELOCITY_MAX,VELOCITY_MIN );      // Run robot left wheel at max velocity and right wheel
     cb4:	8c e3       	ldi	r24, 0x3C	; 60
     cb6:	64 e1       	ldi	r22, 0x14	; 20
     cb8:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
			right();
     cbc:	0e 94 8d 05 	call	0xb1a	; 0xb1a <right>
     cc0:	8f ef       	ldi	r24, 0xFF	; 255
     cc2:	9f eb       	ldi	r25, 0xBF	; 191
     cc4:	a6 e0       	ldi	r26, 0x06	; 6
     cc6:	81 50       	subi	r24, 0x01	; 1
     cc8:	90 40       	sbci	r25, 0x00	; 0
     cca:	a0 40       	sbci	r26, 0x00	; 0
     ccc:	e1 f7       	brne	.-8      	; 0xcc6 <success+0x17a>
     cce:	00 c0       	rjmp	.+0      	; 0xcd0 <success+0x184>
     cd0:	00 00       	nop
     cd2:	12 c0       	rjmp	.+36     	; 0xcf8 <success+0x1ac>
			_delay_ms(300);
			break;
		}
		else if(Center_white_line>THRESHOLD)
     cd4:	15 31       	cpi	r17, 0x15	; 21
     cd6:	08 f4       	brcc	.+2      	; 0xcda <success+0x18e>
     cd8:	83 cf       	rjmp	.-250    	; 0xbe0 <success+0x94>
		{
			//flag=1;
			velocity(VELOCITY_MAX,VELOCITY_MAX);      // Run robot at max velocity
     cda:	8c e3       	ldi	r24, 0x3C	; 60
     cdc:	6c e3       	ldi	r22, 0x3C	; 60
     cde:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
			forward();
     ce2:	0e 94 81 05 	call	0xb02	; 0xb02 <forward>
     ce6:	8f ef       	ldi	r24, 0xFF	; 255
     ce8:	9f eb       	ldi	r25, 0xBF	; 191
     cea:	a6 e0       	ldi	r26, 0x06	; 6
     cec:	81 50       	subi	r24, 0x01	; 1
     cee:	90 40       	sbci	r25, 0x00	; 0
     cf0:	a0 40       	sbci	r26, 0x00	; 0
     cf2:	e1 f7       	brne	.-8      	; 0xcec <success+0x1a0>
     cf4:	00 c0       	rjmp	.+0      	; 0xcf6 <success+0x1aa>
     cf6:	00 00       	nop
		
		

	}
	
     cf8:	df 91       	pop	r29
     cfa:	cf 91       	pop	r28
     cfc:	1f 91       	pop	r17
     cfe:	0f 91       	pop	r16
     d00:	08 95       	ret

00000d02 <init_devices>:

void init_devices (void)
{
 cli();          //Clears the global interrupts
     d02:	f8 94       	cli
 port_init();
     d04:	0e 94 4d 05 	call	0xa9a	; 0xa9a <port_init>
 timer1_init();
     d08:	0e 94 54 05 	call	0xaa8	; 0xaa8 <timer1_init>
 adc_init();
     d0c:	0e 94 64 05 	call	0xac8	; 0xac8 <adc_init>
 sei();          //Enables the global interrupts
     d10:	78 94       	sei
}
     d12:	08 95       	ret

00000d14 <line_follower>:

//Main Function
int line_follower(void)
{
     d14:	8f 92       	push	r8
     d16:	9f 92       	push	r9
     d18:	af 92       	push	r10
     d1a:	bf 92       	push	r11
     d1c:	cf 92       	push	r12
     d1e:	df 92       	push	r13
     d20:	ef 92       	push	r14
     d22:	ff 92       	push	r15
     d24:	0f 93       	push	r16
     d26:	1f 93       	push	r17
     d28:	cf 93       	push	r28
     d2a:	df 93       	push	r29
 //unsigned char flag ;

 init_devices();
     d2c:	0e 94 81 06 	call	0xd02	; 0xd02 <init_devices>

 

 velocity(VELOCITY_MAX,VELOCITY_MAX);    // Set the speed to max velocity
     d30:	8c e3       	ldi	r24, 0x3C	; 60
     d32:	6c e3       	ldi	r22, 0x3C	; 60
     d34:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		}
		
		if(stage==3)
		{	unsigned char count=0;
			unsigned char i;
			if(path1.path[t]==2 )
     d38:	0f 2e       	mov	r0, r31
     d3a:	f8 ec       	ldi	r31, 0xC8	; 200
     d3c:	cf 2e       	mov	r12, r31
     d3e:	f0 e0       	ldi	r31, 0x00	; 0
     d40:	df 2e       	mov	r13, r31
     d42:	f0 2d       	mov	r31, r0
			}
			
			for ( i=0;i<b;i++)
			{
				
				if(path1.path[t]==blue_nodes[i])
     d44:	0e e8       	ldi	r16, 0x8E	; 142
     d46:	10 e0       	ldi	r17, 0x00	; 0
			servo101();
			
		}
		
		if(stage==3)
		{	unsigned char count=0;
     d48:	ee 24       	eor	r14, r14
     d4a:	e3 94       	inc	r14
				buzzer_beep();
				
			}
			if(count==1)
			{
				if(blue_side[i]==100)
     d4c:	0f 2e       	mov	r0, r31
     d4e:	fc ea       	ldi	r31, 0xAC	; 172
     d50:	af 2e       	mov	r10, r31
     d52:	f0 e0       	ldi	r31, 0x00	; 0
     d54:	bf 2e       	mov	r11, r31
     d56:	f0 2d       	mov	r31, r0
			}
			
			for ( i=0;i<b;i++)
			{
				
				if(path1.path[t]==blue_nodes[i])
     d58:	88 24       	eor	r8, r8
     d5a:	99 24       	eor	r9, r9
 //forward();                              // start to move froward

 while(1)
 {
	 
	Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     d5c:	83 e0       	ldi	r24, 0x03	; 3
     d5e:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>
     d62:	80 93 70 00 	sts	0x0070, r24
	Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
     d66:	84 e0       	ldi	r24, 0x04	; 4
     d68:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>
     d6c:	80 93 6f 00 	sts	0x006F, r24
	Right_white_line = ADC_Conversion(5);	//Getting data of Right WL Sensor
     d70:	85 e0       	ldi	r24, 0x05	; 5
     d72:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>
     d76:	80 93 6e 00 	sts	0x006E, r24
 
	

	//flag=0;

	if(Center_white_line<THRESHOLD && Left_white_line<THRESHOLD && Right_white_line<THRESHOLD)               // Is middle Whiteline is within threshold limit
     d7a:	90 91 6f 00 	lds	r25, 0x006F
     d7e:	94 31       	cpi	r25, 0x14	; 20
     d80:	68 f4       	brcc	.+26     	; 0xd9c <line_follower+0x88>
     d82:	20 91 70 00 	lds	r18, 0x0070
     d86:	24 31       	cpi	r18, 0x14	; 20
     d88:	48 f4       	brcc	.+18     	; 0xd9c <line_follower+0x88>
     d8a:	84 31       	cpi	r24, 0x14	; 20
     d8c:	38 f4       	brcc	.+14     	; 0xd9c <line_follower+0x88>
	{                                             
		//flag=1;                                                                                                  //c0,l0,r0  
		velocity(VELOCITY_MIN,VELOCITY_MIN);      // Run robot at max velocity 
     d8e:	84 e1       	ldi	r24, 0x14	; 20
     d90:	64 e1       	ldi	r22, 0x14	; 20
     d92:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		//back();
		forward();
     d96:	0e 94 81 05 	call	0xb02	; 0xb02 <forward>
     d9a:	e0 cf       	rjmp	.-64     	; 0xd5c <line_follower+0x48>
		
		
	}
	else if(Center_white_line>THRESHOLD && Left_white_line<THRESHOLD && Right_white_line<THRESHOLD)               // Is middle Whiteline is within threshold limit
     d9c:	95 31       	cpi	r25, 0x15	; 21
     d9e:	68 f0       	brcs	.+26     	; 0xdba <line_follower+0xa6>
     da0:	20 91 70 00 	lds	r18, 0x0070
     da4:	24 31       	cpi	r18, 0x14	; 20
     da6:	48 f4       	brcc	.+18     	; 0xdba <line_follower+0xa6>
     da8:	84 31       	cpi	r24, 0x14	; 20
     daa:	38 f4       	brcc	.+14     	; 0xdba <line_follower+0xa6>
	{
		//flag=1;                                                                                                 //c1,l0,r0
		velocity(VELOCITY_MAX,VELOCITY_MAX);      // Run robot at max velocity
     dac:	8c e3       	ldi	r24, 0x3C	; 60
     dae:	6c e3       	ldi	r22, 0x3C	; 60
     db0:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		forward();
     db4:	0e 94 81 05 	call	0xb02	; 0xb02 <forward>
     db8:	d1 cf       	rjmp	.-94     	; 0xd5c <line_follower+0x48>
		
	}


	
	else if(Center_white_line<THRESHOLD && Left_white_line<THRESHOLD && Right_white_line>THRESHOLD)  // Is left Whiteline is not within threshold limit
     dba:	94 31       	cpi	r25, 0x14	; 20
     dbc:	68 f4       	brcc	.+26     	; 0xdd8 <line_follower+0xc4>
     dbe:	20 91 70 00 	lds	r18, 0x0070
     dc2:	24 31       	cpi	r18, 0x14	; 20
     dc4:	48 f4       	brcc	.+18     	; 0xdd8 <line_follower+0xc4>
     dc6:	85 31       	cpi	r24, 0x15	; 21
     dc8:	38 f0       	brcs	.+14     	; 0xdd8 <line_follower+0xc4>
	{                                             
	    //	flag=1;                                                                                                     //c0,l0,r1
		velocity(VELOCITY_MAX,VELOCITY_MIN);      // Run robot left wheel at max velocity and right wheel 
     dca:	8c e3       	ldi	r24, 0x3C	; 60
     dcc:	64 e1       	ldi	r22, 0x14	; 20
     dce:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		right();
     dd2:	0e 94 8d 05 	call	0xb1a	; 0xb1a <right>
     dd6:	c2 cf       	rjmp	.-124    	; 0xd5c <line_follower+0x48>
		
	}
	
	else if(Center_white_line>THRESHOLD && Left_white_line<THRESHOLD && Right_white_line>THRESHOLD)  // Is left Whiteline is not within threshold limit
     dd8:	95 31       	cpi	r25, 0x15	; 21
     dda:	68 f0       	brcs	.+26     	; 0xdf6 <line_follower+0xe2>
     ddc:	20 91 70 00 	lds	r18, 0x0070
     de0:	24 31       	cpi	r18, 0x14	; 20
     de2:	48 f4       	brcc	.+18     	; 0xdf6 <line_follower+0xe2>
     de4:	85 31       	cpi	r24, 0x15	; 21
     de6:	38 f0       	brcs	.+14     	; 0xdf6 <line_follower+0xe2>
	{                                                                                                                  //c1,l0,r1                 
		//	flag=1;
		velocity(VELOCITY_MAX,VELOCITY_MIN);      // Run robot left wheel at max velocity and right wheel
     de8:	8c e3       	ldi	r24, 0x3C	; 60
     dea:	64 e1       	ldi	r22, 0x14	; 20
     dec:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		S_R();
     df0:	0e 94 99 05 	call	0xb32	; 0xb32 <S_R>
     df4:	b3 cf       	rjmp	.-154    	; 0xd5c <line_follower+0x48>
		
	}

	
	else if(Center_white_line<THRESHOLD && Left_white_line>THRESHOLD && Right_white_line<THRESHOLD ) // Is right Whiteline is not within threshold limit
     df6:	94 31       	cpi	r25, 0x14	; 20
     df8:	68 f4       	brcc	.+26     	; 0xe14 <line_follower+0x100>
     dfa:	20 91 70 00 	lds	r18, 0x0070
     dfe:	25 31       	cpi	r18, 0x15	; 21
     e00:	48 f0       	brcs	.+18     	; 0xe14 <line_follower+0x100>
     e02:	84 31       	cpi	r24, 0x14	; 20
     e04:	38 f4       	brcc	.+14     	; 0xe14 <line_follower+0x100>
	{
		//flag=1;                                                                                                 //c0,l1,r0
		velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel 
     e06:	84 e1       	ldi	r24, 0x14	; 20
     e08:	6c e3       	ldi	r22, 0x3C	; 60
     e0a:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		s_L();
     e0e:	0e 94 95 05 	call	0xb2a	; 0xb2a <s_L>
     e12:	a4 cf       	rjmp	.-184    	; 0xd5c <line_follower+0x48>
		
	}
	else if(Center_white_line>THRESHOLD && Left_white_line>THRESHOLD && Right_white_line<THRESHOLD ) // Is right Whiteline is not within threshold limit
     e14:	95 31       	cpi	r25, 0x15	; 21
     e16:	08 f4       	brcc	.+2      	; 0xe1a <line_follower+0x106>
     e18:	a1 cf       	rjmp	.-190    	; 0xd5c <line_follower+0x48>
     e1a:	90 91 70 00 	lds	r25, 0x0070
     e1e:	95 31       	cpi	r25, 0x15	; 21
     e20:	08 f4       	brcc	.+2      	; 0xe24 <line_follower+0x110>
     e22:	9c cf       	rjmp	.-200    	; 0xd5c <line_follower+0x48>
     e24:	84 31       	cpi	r24, 0x14	; 20
     e26:	08 f0       	brcs	.+2      	; 0xe2a <line_follower+0x116>
     e28:	b0 c0       	rjmp	.+352    	; 0xf8a <line_follower+0x276>
	{                                                                                                             //c1,l1,r0
		//flag=1; 
		velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel
     e2a:	84 e1       	ldi	r24, 0x14	; 20
     e2c:	6c e3       	ldi	r22, 0x3C	; 60
     e2e:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		left();
     e32:	0e 94 89 05 	call	0xb12	; 0xb12 <left>
     e36:	92 cf       	rjmp	.-220    	; 0xd5c <line_follower+0x48>
                
	else if(Center_white_line>THRESHOLD && Left_white_line>THRESHOLD && Right_white_line>THRESHOLD)
	                                // if all Whiteline sensor are not within threshold limit                      //c1,l1,r1   
	{                       
		//flag=1;
		velocity(VELOCITY_LOW,VELOCITY_LOW);      // stop the robot
     e38:	80 e0       	ldi	r24, 0x00	; 0
     e3a:	60 e0       	ldi	r22, 0x00	; 0
     e3c:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		hard_stop();
     e40:	0e 94 91 05 	call	0xb22	; 0xb22 <hard_stop>
		if(stage==2)
     e44:	80 91 65 00 	lds	r24, 0x0065
     e48:	82 30       	cpi	r24, 0x02	; 2
     e4a:	21 f4       	brne	.+8      	; 0xe54 <line_follower+0x140>
		{
			servo100();
     e4c:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <servo100>
			servo101();
     e50:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <servo101>
			
		}
		
		if(stage==3)
     e54:	80 91 65 00 	lds	r24, 0x0065
     e58:	83 30       	cpi	r24, 0x03	; 3
     e5a:	09 f0       	breq	.+2      	; 0xe5e <line_follower+0x14a>
     e5c:	7e c0       	rjmp	.+252    	; 0xf5a <line_follower+0x246>
		{	unsigned char count=0;
			unsigned char i;
			if(path1.path[t]==2 )
     e5e:	80 91 76 00 	lds	r24, 0x0076
     e62:	f6 01       	movw	r30, r12
     e64:	e8 0f       	add	r30, r24
     e66:	f1 1d       	adc	r31, r1
     e68:	80 81       	ld	r24, Z
     e6a:	82 30       	cpi	r24, 0x02	; 2
     e6c:	a9 f4       	brne	.+42     	; 0xe98 <line_follower+0x184>
			{
				init_devices_pos();
     e6e:	0e 94 18 04 	call	0x830	; 0x830 <init_devices_pos>
				left_degrees(100);
     e72:	84 e6       	ldi	r24, 0x64	; 100
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	0e 94 ce 03 	call	0x79c	; 0x79c <left_degrees>
				stop_pos();
     e7a:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
     e7e:	8f ef       	ldi	r24, 0xFF	; 255
     e80:	9f e3       	ldi	r25, 0x3F	; 63
     e82:	ab e0       	ldi	r26, 0x0B	; 11
     e84:	81 50       	subi	r24, 0x01	; 1
     e86:	90 40       	sbci	r25, 0x00	; 0
     e88:	a0 40       	sbci	r26, 0x00	; 0
     e8a:	e1 f7       	brne	.-8      	; 0xe84 <line_follower+0x170>
     e8c:	00 c0       	rjmp	.+0      	; 0xe8e <line_follower+0x17a>
     e8e:	00 00       	nop
				_delay_ms(500);
				dir=3;
     e90:	83 e0       	ldi	r24, 0x03	; 3
     e92:	80 93 66 00 	sts	0x0066, r24
     e96:	15 c0       	rjmp	.+42     	; 0xec2 <line_follower+0x1ae>
				
			}
			else if(path1.path[t]==48 )
     e98:	80 33       	cpi	r24, 0x30	; 48
     e9a:	99 f4       	brne	.+38     	; 0xec2 <line_follower+0x1ae>
			{
				init_devices_pos();
     e9c:	0e 94 18 04 	call	0x830	; 0x830 <init_devices_pos>
				left_degrees(100);
     ea0:	84 e6       	ldi	r24, 0x64	; 100
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	0e 94 ce 03 	call	0x79c	; 0x79c <left_degrees>
				stop_pos();
     ea8:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
     eac:	8f ef       	ldi	r24, 0xFF	; 255
     eae:	9f e3       	ldi	r25, 0x3F	; 63
     eb0:	ab e0       	ldi	r26, 0x0B	; 11
     eb2:	81 50       	subi	r24, 0x01	; 1
     eb4:	90 40       	sbci	r25, 0x00	; 0
     eb6:	a0 40       	sbci	r26, 0x00	; 0
     eb8:	e1 f7       	brne	.-8      	; 0xeb2 <line_follower+0x19e>
     eba:	00 c0       	rjmp	.+0      	; 0xebc <line_follower+0x1a8>
     ebc:	00 00       	nop
				_delay_ms(500);
				dir=1;
     ebe:	e0 92 66 00 	sts	0x0066, r14
				
			}
			
			for ( i=0;i<b;i++)
     ec2:	80 91 73 00 	lds	r24, 0x0073
     ec6:	88 23       	and	r24, r24
     ec8:	09 f4       	brne	.+2      	; 0xecc <line_follower+0x1b8>
     eca:	5d c0       	rjmp	.+186    	; 0xf86 <line_follower+0x272>
			{
				
				if(path1.path[t]==blue_nodes[i])
     ecc:	80 91 76 00 	lds	r24, 0x0076
     ed0:	f6 01       	movw	r30, r12
     ed2:	e8 0f       	add	r30, r24
     ed4:	f1 1d       	adc	r31, r1
     ed6:	20 81       	ld	r18, Z
     ed8:	d8 01       	movw	r26, r16
     eda:	8c 91       	ld	r24, X
     edc:	28 17       	cp	r18, r24
     ede:	59 f0       	breq	.+22     	; 0xef6 <line_follower+0x1e2>
				_delay_ms(500);
				dir=1;
				
			}
			
			for ( i=0;i<b;i++)
     ee0:	c0 e0       	ldi	r28, 0x00	; 0
     ee2:	1c c0       	rjmp	.+56     	; 0xf1c <line_follower+0x208>
			{
				
				if(path1.path[t]==blue_nodes[i])
     ee4:	8c 2f       	mov	r24, r28
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	f8 01       	movw	r30, r16
     eea:	e8 0f       	add	r30, r24
     eec:	f9 1f       	adc	r31, r25
     eee:	30 81       	ld	r19, Z
     ef0:	23 17       	cp	r18, r19
     ef2:	a1 f4       	brne	.+40     	; 0xf1c <line_follower+0x208>
     ef4:	02 c0       	rjmp	.+4      	; 0xefa <line_follower+0x1e6>
     ef6:	c4 01       	movw	r24, r8
				_delay_ms(500);
				dir=1;
				
			}
			
			for ( i=0;i<b;i++)
     ef8:	c0 e0       	ldi	r28, 0x00	; 0
			{
				
				if(path1.path[t]==blue_nodes[i])
				{
					if (path1.path[t]==blue_nodes[i+1])
     efa:	fc 01       	movw	r30, r24
     efc:	31 96       	adiw	r30, 0x01	; 1
     efe:	e0 0f       	add	r30, r16
     f00:	f1 1f       	adc	r31, r17
     f02:	80 81       	ld	r24, Z
			servo101();
			
		}
		
		if(stage==3)
		{	unsigned char count=0;
     f04:	fe 2c       	mov	r15, r14
     f06:	28 13       	cpse	r18, r24
     f08:	ff 24       	eor	r15, r15
					}
					count++;
					break;
				}
			}
			if (count>0)
     f0a:	f3 94       	inc	r15
			{buzzer_beep();
     f0c:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_beep>
				buzzer_beep();
     f10:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_beep>
				
			}
			if(count==1)
     f14:	b1 e0       	ldi	r27, 0x01	; 1
     f16:	fb 16       	cp	r15, r27
     f18:	41 f0       	breq	.+16     	; 0xf2a <line_follower+0x216>
     f1a:	18 c0       	rjmp	.+48     	; 0xf4c <line_follower+0x238>
				_delay_ms(500);
				dir=1;
				
			}
			
			for ( i=0;i<b;i++)
     f1c:	cf 5f       	subi	r28, 0xFF	; 255
     f1e:	80 91 73 00 	lds	r24, 0x0073
     f22:	c8 17       	cp	r28, r24
     f24:	f8 f2       	brcs	.-66     	; 0xee4 <line_follower+0x1d0>
     f26:	ff 24       	eor	r15, r15
     f28:	11 c0       	rjmp	.+34     	; 0xf4c <line_follower+0x238>
				buzzer_beep();
				
			}
			if(count==1)
			{
				if(blue_side[i]==100)
     f2a:	d0 e0       	ldi	r29, 0x00	; 0
     f2c:	f5 01       	movw	r30, r10
     f2e:	ec 0f       	add	r30, r28
     f30:	fd 1f       	adc	r31, r29
     f32:	80 81       	ld	r24, Z
     f34:	84 36       	cpi	r24, 0x64	; 100
     f36:	19 f4       	brne	.+6      	; 0xf3e <line_follower+0x22a>
				{
					servo100();
     f38:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <servo100>
     f3c:	0e c0       	rjmp	.+28     	; 0xf5a <line_follower+0x246>
				}
				else if(blue_side[i]==101)
     f3e:	ca 0d       	add	r28, r10
     f40:	db 1d       	adc	r29, r11
     f42:	88 81       	ld	r24, Y
     f44:	85 36       	cpi	r24, 0x65	; 101
     f46:	11 f4       	brne	.+4      	; 0xf4c <line_follower+0x238>
				{
					servo101();
     f48:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <servo101>
				}
				
			}
			if(count==2)
     f4c:	e2 e0       	ldi	r30, 0x02	; 2
     f4e:	fe 16       	cp	r15, r30
     f50:	21 f4       	brne	.+8      	; 0xf5a <line_follower+0x246>
			{
				servo100();
     f52:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <servo100>
				servo101();
     f56:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <servo101>
			}
			count=0;
		}
		
		init_devices();
     f5a:	0e 94 81 06 	call	0xd02	; 0xd02 <init_devices>
		direction();
     f5e:	0e 94 3d 0a 	call	0x147a	; 0x147a <direction>
		if (g==1)
     f62:	80 91 81 00 	lds	r24, 0x0081
     f66:	81 30       	cpi	r24, 0x01	; 1
     f68:	09 f0       	breq	.+2      	; 0xf6c <line_follower+0x258>
     f6a:	f8 ce       	rjmp	.-528    	; 0xd5c <line_follower+0x48>
		
	}
	

 }
}
     f6c:	df 91       	pop	r29
     f6e:	cf 91       	pop	r28
     f70:	1f 91       	pop	r17
     f72:	0f 91       	pop	r16
     f74:	ff 90       	pop	r15
     f76:	ef 90       	pop	r14
     f78:	df 90       	pop	r13
     f7a:	cf 90       	pop	r12
     f7c:	bf 90       	pop	r11
     f7e:	af 90       	pop	r10
     f80:	9f 90       	pop	r9
     f82:	8f 90       	pop	r8
     f84:	08 95       	ret
				_delay_ms(500);
				dir=1;
				
			}
			
			for ( i=0;i<b;i++)
     f86:	ff 24       	eor	r15, r15
     f88:	e1 cf       	rjmp	.-62     	; 0xf4c <line_follower+0x238>
		velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel
		left();
		
	}
                
	else if(Center_white_line>THRESHOLD && Left_white_line>THRESHOLD && Right_white_line>THRESHOLD)
     f8a:	85 31       	cpi	r24, 0x15	; 21
     f8c:	08 f0       	brcs	.+2      	; 0xf90 <line_follower+0x27c>
     f8e:	54 cf       	rjmp	.-344    	; 0xe38 <line_follower+0x124>
     f90:	e5 ce       	rjmp	.-566    	; 0xd5c <line_follower+0x48>

00000f92 <color_sensor_pin_config>:
Blue_led pc6
*/

void color_sensor_pin_config(void)
{
	DDRD  = DDRD & 0xBF;  //Set the direction of the PORTD 6 pin as input 1011 1111
     f92:	8e 98       	cbi	0x11, 6	; 17
	PORTD = PORTD | 0x40; //pullup pd6 0100 0000
     f94:	96 9a       	sbi	0x12, 6	; 18
}
     f96:	08 95       	ret

00000f98 <port_init_color>:
void port_init_color(void)
{
	
	color_sensor_pin_config();//color sensor pin configuration
     f98:	0e 94 c9 07 	call	0xf92	; 0xf92 <color_sensor_pin_config>
}
     f9c:	08 95       	ret

00000f9e <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
     f9e:	f8 94       	cli
	//EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
	TCCR1A=0;
     fa0:	1f bc       	out	0x2f, r1	; 47
	TCCR1B=0x81;//falling edge,noise cancel, no prescale
     fa2:	81 e8       	ldi	r24, 0x81	; 129
     fa4:	8e bd       	out	0x2e, r24	; 46
	TIMSK=(1<<TICIE1);//ip capt and  NO overflow interrupt
     fa6:	80 e2       	ldi	r24, 0x20	; 32
     fa8:	89 bf       	out	0x39, r24	; 57
	//EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
	sei(); // Enables the global interrupt
     faa:	78 94       	sei
}
     fac:	08 95       	ret

00000fae <__vector_5>:
ISR(TIMER1_CAPT_vect)
{
     fae:	1f 92       	push	r1
     fb0:	0f 92       	push	r0
     fb2:	0f b6       	in	r0, 0x3f	; 63
     fb4:	0f 92       	push	r0
     fb6:	11 24       	eor	r1, r1
     fb8:	8f 93       	push	r24
     fba:	9f 93       	push	r25
     fbc:	af 93       	push	r26
     fbe:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     fc0:	80 91 6a 00 	lds	r24, 0x006A
     fc4:	90 91 6b 00 	lds	r25, 0x006B
     fc8:	a0 91 6c 00 	lds	r26, 0x006C
     fcc:	b0 91 6d 00 	lds	r27, 0x006D
     fd0:	01 96       	adiw	r24, 0x01	; 1
     fd2:	a1 1d       	adc	r26, r1
     fd4:	b1 1d       	adc	r27, r1
     fd6:	80 93 6a 00 	sts	0x006A, r24
     fda:	90 93 6b 00 	sts	0x006B, r25
     fde:	a0 93 6c 00 	sts	0x006C, r26
     fe2:	b0 93 6d 00 	sts	0x006D, r27
}
     fe6:	bf 91       	pop	r27
     fe8:	af 91       	pop	r26
     fea:	9f 91       	pop	r25
     fec:	8f 91       	pop	r24
     fee:	0f 90       	pop	r0
     ff0:	0f be       	out	0x3f, r0	; 63
     ff2:	0f 90       	pop	r0
     ff4:	1f 90       	pop	r1
     ff6:	18 95       	reti

00000ff8 <init_devices_color>:
void init_devices_color(void)
{
	cli(); //Clears the global interrupt
     ff8:	f8 94       	cli
	port_init_color();  //Initializes all the ports
     ffa:	0e 94 cc 07 	call	0xf98	; 0xf98 <port_init_color>
	color_sensor_pin_interrupt_init();
     ffe:	0e 94 cf 07 	call	0xf9e	; 0xf9e <color_sensor_pin_interrupt_init>
	sei();   // Enables the global interrupt
    1002:	78 94       	sei
}
    1004:	08 95       	ret

00001006 <filter_red>:
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	/*PORTC= PORTC & 0xFE; //set S2 low
	PORTC = PORTC & 0xF7; //set S37F lowpd2*/
	PORTC= PORTC & 0xFB; //set S2 low 1111 1011
    1006:	aa 98       	cbi	0x15, 2	; 21
	PORTC = PORTC & 0x7F; //set S37F lowpd2 0111 1111
    1008:	af 98       	cbi	0x15, 7	; 21
}
    100a:	08 95       	ret

0000100c <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	
	PORTC = PORTC | 0x04; //set S2 High 0000 0100
    100c:	aa 9a       	sbi	0x15, 2	; 21
	PORTC = PORTC | 0x80; //set S3 High 1000 0000
    100e:	af 9a       	sbi	0x15, 7	; 21
}
    1010:	08 95       	ret

00001012 <filter_blue>:
void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	/*PORTD = PORTD & 0xF7; //set S2 low
	PORTD = PORTD | 0x04; //set S3 High*/
	PORTC= PORTC & 0xFB; //set S2 low 1111 1011
    1012:	aa 98       	cbi	0x15, 2	; 21
	PORTC = PORTC | 0x80; //set S3 High 1000 0000
    1014:	af 9a       	sbi	0x15, 7	; 21
}
    1016:	08 95       	ret

00001018 <filter_clear>:
void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	/*PORTD = PORTD | 0x08; //set S2 High
	PORTD = PORTD & 0xFB; //set S3 Low*/
	PORTC = PORTC | 0x04;  //set S2 High 0000 0100
    1018:	aa 9a       	sbi	0x15, 2	; 21
	PORTC = PORTC & 0x7F; //set S3 Low 0111 1111
    101a:	af 98       	cbi	0x15, 7	; 21
}
    101c:	08 95       	ret

0000101e <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xFE;
	PORTC = PORTC | 0x01; //set S0 high 0000 0001
    101e:	a8 9a       	sbi	0x15, 0	; 21
	PORTC = PORTC & 0xFD; //set S1 low 1111 1101
    1020:	a9 98       	cbi	0x15, 1	; 21
	//PORTD = PORTD | 0x02; //set S1 high 
}
    1022:	08 95       	ret

00001024 <red_read>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
    1024:	0e 94 03 08 	call	0x1006	; 0x1006 <filter_red>
	pulse=0; //reset the count to 0
    1028:	10 92 6a 00 	sts	0x006A, r1
    102c:	10 92 6b 00 	sts	0x006B, r1
    1030:	10 92 6c 00 	sts	0x006C, r1
    1034:	10 92 6d 00 	sts	0x006D, r1
    1038:	8f ef       	ldi	r24, 0xFF	; 255
    103a:	9f e3       	ldi	r25, 0x3F	; 63
    103c:	a2 e0       	ldi	r26, 0x02	; 2
    103e:	81 50       	subi	r24, 0x01	; 1
    1040:	90 40       	sbci	r25, 0x00	; 0
    1042:	a0 40       	sbci	r26, 0x00	; 0
    1044:	e1 f7       	brne	.-8      	; 0x103e <red_read+0x1a>
    1046:	00 c0       	rjmp	.+0      	; 0x1048 <red_read+0x24>
    1048:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
    104a:	80 91 6a 00 	lds	r24, 0x006A
    104e:	90 91 6b 00 	lds	r25, 0x006B
    1052:	a0 91 6c 00 	lds	r26, 0x006C
    1056:	b0 91 6d 00 	lds	r27, 0x006D
    105a:	80 93 c4 00 	sts	0x00C4, r24
    105e:	90 93 c5 00 	sts	0x00C5, r25
    1062:	a0 93 c6 00 	sts	0x00C6, r26
    1066:	b0 93 c7 00 	sts	0x00C7, r27
	lcd_string("Red Pulses"); // Display "Red Pulses" on LCD
	lcd_print(2,1,red,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD
	*/
}
    106a:	08 95       	ret

0000106c <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
    106c:	0e 94 06 08 	call	0x100c	; 0x100c <filter_green>
	pulse=0; //reset the count to 0
    1070:	10 92 6a 00 	sts	0x006A, r1
    1074:	10 92 6b 00 	sts	0x006B, r1
    1078:	10 92 6c 00 	sts	0x006C, r1
    107c:	10 92 6d 00 	sts	0x006D, r1
    1080:	8f ef       	ldi	r24, 0xFF	; 255
    1082:	9f e3       	ldi	r25, 0x3F	; 63
    1084:	a2 e0       	ldi	r26, 0x02	; 2
    1086:	81 50       	subi	r24, 0x01	; 1
    1088:	90 40       	sbci	r25, 0x00	; 0
    108a:	a0 40       	sbci	r26, 0x00	; 0
    108c:	e1 f7       	brne	.-8      	; 0x1086 <green_read+0x1a>
    108e:	00 c0       	rjmp	.+0      	; 0x1090 <green_read+0x24>
    1090:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
    1092:	80 91 6a 00 	lds	r24, 0x006A
    1096:	90 91 6b 00 	lds	r25, 0x006B
    109a:	a0 91 6c 00 	lds	r26, 0x006C
    109e:	b0 91 6d 00 	lds	r27, 0x006D
    10a2:	80 93 c0 00 	sts	0x00C0, r24
    10a6:	90 93 c1 00 	sts	0x00C1, r25
    10aa:	a0 93 c2 00 	sts	0x00C2, r26
    10ae:	b0 93 c3 00 	sts	0x00C3, r27
	lcd_string("Green Pulses"); // Display "Green Pulses" on LCD
	lcd_print(2,1,green,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD

*/}
    10b2:	08 95       	ret

000010b4 <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
    10b4:	0e 94 09 08 	call	0x1012	; 0x1012 <filter_blue>
	pulse=0; //reset the count to 0
    10b8:	10 92 6a 00 	sts	0x006A, r1
    10bc:	10 92 6b 00 	sts	0x006B, r1
    10c0:	10 92 6c 00 	sts	0x006C, r1
    10c4:	10 92 6d 00 	sts	0x006D, r1
    10c8:	8f ef       	ldi	r24, 0xFF	; 255
    10ca:	9f e3       	ldi	r25, 0x3F	; 63
    10cc:	a2 e0       	ldi	r26, 0x02	; 2
    10ce:	81 50       	subi	r24, 0x01	; 1
    10d0:	90 40       	sbci	r25, 0x00	; 0
    10d2:	a0 40       	sbci	r26, 0x00	; 0
    10d4:	e1 f7       	brne	.-8      	; 0x10ce <blue_read+0x1a>
    10d6:	00 c0       	rjmp	.+0      	; 0x10d8 <blue_read+0x24>
    10d8:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
    10da:	80 91 6a 00 	lds	r24, 0x006A
    10de:	90 91 6b 00 	lds	r25, 0x006B
    10e2:	a0 91 6c 00 	lds	r26, 0x006C
    10e6:	b0 91 6d 00 	lds	r27, 0x006D
    10ea:	80 93 9a 00 	sts	0x009A, r24
    10ee:	90 93 9b 00 	sts	0x009B, r25
    10f2:	a0 93 9c 00 	sts	0x009C, r26
    10f6:	b0 93 9d 00 	sts	0x009D, r27
	lcd_string("Blue Pulses"); // Display "Blue Pulses" on LCD
	lcd_print(2,1,blue,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD
	*/
}
    10fa:	08 95       	ret

000010fc <colour>:
void colour(unsigned long int red_pulse, unsigned long int green_pulse,unsigned long int blue_pulse)
{	
    10fc:	8f 92       	push	r8
    10fe:	9f 92       	push	r9
    1100:	af 92       	push	r10
    1102:	bf 92       	push	r11
    1104:	ef 92       	push	r14
    1106:	ff 92       	push	r15
    1108:	0f 93       	push	r16
    110a:	1f 93       	push	r17
    110c:	4b 01       	movw	r8, r22
    110e:	5c 01       	movw	r10, r24
    1110:	da 01       	movw	r26, r20
    1112:	c9 01       	movw	r24, r18
    1114:	b8 01       	movw	r22, r16
    1116:	a7 01       	movw	r20, r14
	if(red_pulse>green_pulse && red_pulse>blue_pulse)
    1118:	88 15       	cp	r24, r8
    111a:	99 05       	cpc	r25, r9
    111c:	aa 05       	cpc	r26, r10
    111e:	bb 05       	cpc	r27, r11
    1120:	68 f4       	brcc	.+26     	; 0x113c <colour+0x40>
    1122:	e8 14       	cp	r14, r8
    1124:	f9 04       	cpc	r15, r9
    1126:	0a 05       	cpc	r16, r10
    1128:	1b 05       	cpc	r17, r11
    112a:	40 f4       	brcc	.+16     	; 0x113c <colour+0x40>
	{
		//red greatest
		PORTC=PORTC|(1<<PC4);
    112c:	ac 9a       	sbi	0x15, 4	; 21
		PORTC=PORTC & 0x9F; //clear pc5 and pc6 1001 1111
    112e:	85 b3       	in	r24, 0x15	; 21
    1130:	8f 79       	andi	r24, 0x9F	; 159
    1132:	85 bb       	out	0x15, r24	; 21
		task=1;
    1134:	81 e0       	ldi	r24, 0x01	; 1
    1136:	80 93 75 00 	sts	0x0075, r24
    113a:	14 c0       	rjmp	.+40     	; 0x1164 <colour+0x68>
	}
	else if(green_pulse>blue_pulse)
    113c:	48 17       	cp	r20, r24
    113e:	59 07       	cpc	r21, r25
    1140:	6a 07       	cpc	r22, r26
    1142:	7b 07       	cpc	r23, r27
    1144:	40 f4       	brcc	.+16     	; 0x1156 <colour+0x5a>
	{
		//green greatest
		PORTC=PORTC|(1<<PC5);
    1146:	ad 9a       	sbi	0x15, 5	; 21
		PORTC=PORTC & 0xAF; //clear pc4 and pc6 1010 1111
    1148:	85 b3       	in	r24, 0x15	; 21
    114a:	8f 7a       	andi	r24, 0xAF	; 175
    114c:	85 bb       	out	0x15, r24	; 21
		task=2;
    114e:	82 e0       	ldi	r24, 0x02	; 2
    1150:	80 93 75 00 	sts	0x0075, r24
    1154:	07 c0       	rjmp	.+14     	; 0x1164 <colour+0x68>
		
	}
	else
	{
		//blue greatest
		PORTC=PORTC|(1<<PC6);
    1156:	ae 9a       	sbi	0x15, 6	; 21
		PORTC=PORTC & 0xCF; //clear pc5 and pc4 1100 1111
    1158:	85 b3       	in	r24, 0x15	; 21
    115a:	8f 7c       	andi	r24, 0xCF	; 207
    115c:	85 bb       	out	0x15, r24	; 21
		task=3;
    115e:	83 e0       	ldi	r24, 0x03	; 3
    1160:	80 93 75 00 	sts	0x0075, r24
	}
}
    1164:	1f 91       	pop	r17
    1166:	0f 91       	pop	r16
    1168:	ff 90       	pop	r15
    116a:	ef 90       	pop	r14
    116c:	bf 90       	pop	r11
    116e:	af 90       	pop	r10
    1170:	9f 90       	pop	r9
    1172:	8f 90       	pop	r8
    1174:	08 95       	ret

00001176 <color_sensor_work>:


void color_sensor_work()
{	
    1176:	ef 92       	push	r14
    1178:	ff 92       	push	r15
    117a:	0f 93       	push	r16
    117c:	1f 93       	push	r17
    117e:	cf 93       	push	r28
    1180:	df 93       	push	r29
	
	init_devices_color();
    1182:	0e 94 fc 07 	call	0xff8	; 0xff8 <init_devices_color>
	DDRC = DDRC | 0xFF;//port c pins as output 
    1186:	84 b3       	in	r24, 0x14	; 20
    1188:	8f ef       	ldi	r24, 0xFF	; 255
    118a:	84 bb       	out	0x14, r24	; 20
	PORTC=0x00;
    118c:	15 ba       	out	0x15, r1	; 21
	color_sensor_scaling();
    118e:	0e 94 0f 08 	call	0x101e	; 0x101e <color_sensor_scaling>
	if(stage==2)
    1192:	80 91 65 00 	lds	r24, 0x0065
    1196:	82 30       	cpi	r24, 0x02	; 2
    1198:	71 f5       	brne	.+92     	; 0x11f6 <color_sensor_work+0x80>
    119a:	c5 e0       	ldi	r28, 0x05	; 5
    119c:	d0 e0       	ldi	r29, 0x00	; 0
	{
		for (int i=0;i<5;i++)
		{
			red_read(); //display the pulse count when red filter is selected
    119e:	0e 94 12 08 	call	0x1024	; 0x1024 <red_read>
			//_delay_ms(500);
			green_read(); //display the pulse count when green filter is selected
    11a2:	0e 94 36 08 	call	0x106c	; 0x106c <green_read>
			//_delay_ms(500);
			blue_read(); //display the pulse count when blue filter is selected
    11a6:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <blue_read>
			//_delay_ms(500);
			colour(red,green,blue);
    11aa:	60 91 c4 00 	lds	r22, 0x00C4
    11ae:	70 91 c5 00 	lds	r23, 0x00C5
    11b2:	80 91 c6 00 	lds	r24, 0x00C6
    11b6:	90 91 c7 00 	lds	r25, 0x00C7
    11ba:	20 91 c0 00 	lds	r18, 0x00C0
    11be:	30 91 c1 00 	lds	r19, 0x00C1
    11c2:	40 91 c2 00 	lds	r20, 0x00C2
    11c6:	50 91 c3 00 	lds	r21, 0x00C3
    11ca:	e0 90 9a 00 	lds	r14, 0x009A
    11ce:	f0 90 9b 00 	lds	r15, 0x009B
    11d2:	00 91 9c 00 	lds	r16, 0x009C
    11d6:	10 91 9d 00 	lds	r17, 0x009D
    11da:	0e 94 7e 08 	call	0x10fc	; 0x10fc <colour>
    11de:	8f ef       	ldi	r24, 0xFF	; 255
    11e0:	9f e3       	ldi	r25, 0x3F	; 63
    11e2:	ab e0       	ldi	r26, 0x0B	; 11
    11e4:	81 50       	subi	r24, 0x01	; 1
    11e6:	90 40       	sbci	r25, 0x00	; 0
    11e8:	a0 40       	sbci	r26, 0x00	; 0
    11ea:	e1 f7       	brne	.-8      	; 0x11e4 <color_sensor_work+0x6e>
    11ec:	00 c0       	rjmp	.+0      	; 0x11ee <color_sensor_work+0x78>
    11ee:	00 00       	nop
    11f0:	21 97       	sbiw	r28, 0x01	; 1
	DDRC = DDRC | 0xFF;//port c pins as output 
	PORTC=0x00;
	color_sensor_scaling();
	if(stage==2)
	{
		for (int i=0;i<5;i++)
    11f2:	a9 f6       	brne	.-86     	; 0x119e <color_sensor_work+0x28>
    11f4:	10 c0       	rjmp	.+32     	; 0x1216 <color_sensor_work+0xa0>
		}
		
	}
	else
	{	//blue
		PORTC=PORTC|(1<<PC6);
    11f6:	ae 9a       	sbi	0x15, 6	; 21
		PORTC=PORTC & 0xCF; //clear pc5 and pc4 1100 1111
    11f8:	85 b3       	in	r24, 0x15	; 21
    11fa:	8f 7c       	andi	r24, 0xCF	; 207
    11fc:	85 bb       	out	0x15, r24	; 21
		task=3;
    11fe:	83 e0       	ldi	r24, 0x03	; 3
    1200:	80 93 75 00 	sts	0x0075, r24
    1204:	8f ef       	ldi	r24, 0xFF	; 255
    1206:	9f e3       	ldi	r25, 0x3F	; 63
    1208:	ab e0       	ldi	r26, 0x0B	; 11
    120a:	81 50       	subi	r24, 0x01	; 1
    120c:	90 40       	sbci	r25, 0x00	; 0
    120e:	a0 40       	sbci	r26, 0x00	; 0
    1210:	e1 f7       	brne	.-8      	; 0x120a <color_sensor_work+0x94>
    1212:	00 c0       	rjmp	.+0      	; 0x1214 <color_sensor_work+0x9e>
    1214:	00 00       	nop
		_delay_ms(500);
	}	
	
    1216:	df 91       	pop	r29
    1218:	cf 91       	pop	r28
    121a:	1f 91       	pop	r17
    121c:	0f 91       	pop	r16
    121e:	ff 90       	pop	r15
    1220:	ef 90       	pop	r14
    1222:	08 95       	ret

00001224 <buzzer_pin_config_zigbee>:
}
*/

void buzzer_pin_config_zigbee (void)
{
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as outpt
    1224:	a3 9a       	sbi	0x14, 3	; 20
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
    1226:	ab 98       	cbi	0x15, 3	; 21
}
    1228:	08 95       	ret

0000122a <port_init_zigbee>:

//Function to initialize ports
void port_init_zigbee()
{
 //motion_pin_config();
 buzzer_pin_config_zigbee();
    122a:	0e 94 12 09 	call	0x1224	; 0x1224 <buzzer_pin_config_zigbee>
}
    122e:	08 95       	ret

00001230 <uart0_init_zigbee>:
// actual: baud rate:9600 (0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init_zigbee(void)
{
 UCSRB = 0x00; //disable while setting baud rate
    1230:	1a b8       	out	0x0a, r1	; 10
 UCSRA = 0x00;
    1232:	1b b8       	out	0x0b, r1	; 11
 UCSRC = 0x86;
    1234:	86 e8       	ldi	r24, 0x86	; 134
    1236:	80 bd       	out	0x20, r24	; 32
 UBRRL = 0x2F; //set baud rate lo  //67 is for 16MHz 9600 baudrate
    1238:	8f e2       	ldi	r24, 0x2F	; 47
    123a:	89 b9       	out	0x09, r24	; 9
 UBRRH = 0x00; //set baud rate hi
    123c:	10 bc       	out	0x20, r1	; 32
 UCSRB = 0x98; 
    123e:	88 e9       	ldi	r24, 0x98	; 152
    1240:	8a b9       	out	0x0a, r24	; 10
}
    1242:	08 95       	ret

00001244 <conversion>:
unsigned char conversion(unsigned char hex)
{	unsigned char node;	
	
	switch(hex)
    1244:	8b 31       	cpi	r24, 0x1B	; 27
    1246:	e9 f1       	breq	.+122    	; 0x12c2 <conversion+0x7e>
    1248:	8c 31       	cpi	r24, 0x1C	; 28
    124a:	90 f4       	brcc	.+36     	; 0x1270 <conversion+0x2c>
    124c:	8d 30       	cpi	r24, 0x0D	; 13
    124e:	e9 f1       	breq	.+122    	; 0x12ca <conversion+0x86>
    1250:	8e 30       	cpi	r24, 0x0E	; 14
    1252:	38 f4       	brcc	.+14     	; 0x1262 <conversion+0x1e>
    1254:	86 30       	cpi	r24, 0x06	; 6
    1256:	d9 f1       	breq	.+118    	; 0x12ce <conversion+0x8a>
    1258:	89 30       	cpi	r24, 0x09	; 9
    125a:	09 f1       	breq	.+66     	; 0x129e <conversion+0x5a>
    125c:	82 30       	cpi	r24, 0x02	; 2
    125e:	f1 f5       	brne	.+124    	; 0x12dc <conversion+0x98>
    1260:	3c c0       	rjmp	.+120    	; 0x12da <conversion+0x96>
    1262:	84 31       	cpi	r24, 0x14	; 20
    1264:	81 f1       	breq	.+96     	; 0x12c6 <conversion+0x82>
    1266:	87 31       	cpi	r24, 0x17	; 23
    1268:	f1 f0       	breq	.+60     	; 0x12a6 <conversion+0x62>
    126a:	80 31       	cpi	r24, 0x10	; 16
    126c:	b9 f5       	brne	.+110    	; 0x12dc <conversion+0x98>
    126e:	19 c0       	rjmp	.+50     	; 0x12a2 <conversion+0x5e>
    1270:	89 32       	cpi	r24, 0x29	; 41
    1272:	19 f1       	breq	.+70     	; 0x12ba <conversion+0x76>
    1274:	8a 32       	cpi	r24, 0x2A	; 42
    1276:	38 f4       	brcc	.+14     	; 0x1286 <conversion+0x42>
    1278:	82 32       	cpi	r24, 0x22	; 34
    127a:	09 f1       	breq	.+66     	; 0x12be <conversion+0x7a>
    127c:	85 32       	cpi	r24, 0x25	; 37
    127e:	b9 f0       	breq	.+46     	; 0x12ae <conversion+0x6a>
    1280:	8e 31       	cpi	r24, 0x1E	; 30
    1282:	61 f5       	brne	.+88     	; 0x12dc <conversion+0x98>
    1284:	12 c0       	rjmp	.+36     	; 0x12aa <conversion+0x66>
    1286:	80 33       	cpi	r24, 0x30	; 48
    1288:	b1 f0       	breq	.+44     	; 0x12b6 <conversion+0x72>
    128a:	81 33       	cpi	r24, 0x31	; 49
    128c:	18 f4       	brcc	.+6      	; 0x1294 <conversion+0x50>
    128e:	8c 32       	cpi	r24, 0x2C	; 44
    1290:	29 f5       	brne	.+74     	; 0x12dc <conversion+0x98>
    1292:	0f c0       	rjmp	.+30     	; 0x12b2 <conversion+0x6e>
    1294:	84 36       	cpi	r24, 0x64	; 100
    1296:	e9 f0       	breq	.+58     	; 0x12d2 <conversion+0x8e>
    1298:	85 36       	cpi	r24, 0x65	; 101
    129a:	01 f5       	brne	.+64     	; 0x12dc <conversion+0x98>
    129c:	1c c0       	rjmp	.+56     	; 0x12d6 <conversion+0x92>
	{
		case 0x02:
		node=2;
		break;
		case 0x09:
		node=9;
    129e:	99 e0       	ldi	r25, 0x09	; 9
		break;
    12a0:	1d c0       	rjmp	.+58     	; 0x12dc <conversion+0x98>
		case 0x10:
		node=16;
    12a2:	90 e1       	ldi	r25, 0x10	; 16
		break;
    12a4:	1b c0       	rjmp	.+54     	; 0x12dc <conversion+0x98>
		case 0x17:
		node=23;
    12a6:	97 e1       	ldi	r25, 0x17	; 23
		break;
    12a8:	19 c0       	rjmp	.+50     	; 0x12dc <conversion+0x98>
		case 0x1E:
		node=30;
    12aa:	9e e1       	ldi	r25, 0x1E	; 30
		break;
    12ac:	17 c0       	rjmp	.+46     	; 0x12dc <conversion+0x98>
		case 0x25:
		node=37;
    12ae:	95 e2       	ldi	r25, 0x25	; 37
		break;
    12b0:	15 c0       	rjmp	.+42     	; 0x12dc <conversion+0x98>
		case 0x2C:
		node=44;
    12b2:	9c e2       	ldi	r25, 0x2C	; 44
		break;
    12b4:	13 c0       	rjmp	.+38     	; 0x12dc <conversion+0x98>
		
		case 0x30:
		node=48;
    12b6:	90 e3       	ldi	r25, 0x30	; 48
		break;
    12b8:	11 c0       	rjmp	.+34     	; 0x12dc <conversion+0x98>
		case 0x29:
		node=41;
    12ba:	99 e2       	ldi	r25, 0x29	; 41
		break;
    12bc:	0f c0       	rjmp	.+30     	; 0x12dc <conversion+0x98>
		case 0x22:
		node=34;
    12be:	92 e2       	ldi	r25, 0x22	; 34
		break;
    12c0:	0d c0       	rjmp	.+26     	; 0x12dc <conversion+0x98>
		case 0x1B:
		node=27;
    12c2:	9b e1       	ldi	r25, 0x1B	; 27
		break;
    12c4:	0b c0       	rjmp	.+22     	; 0x12dc <conversion+0x98>
		case 0x14:
		node=20;
    12c6:	94 e1       	ldi	r25, 0x14	; 20
		break;
    12c8:	09 c0       	rjmp	.+18     	; 0x12dc <conversion+0x98>
		case 0x0D:
		node=13;
    12ca:	9d e0       	ldi	r25, 0x0D	; 13
		break;
    12cc:	07 c0       	rjmp	.+14     	; 0x12dc <conversion+0x98>
		case 0x06:
		node=6;
    12ce:	96 e0       	ldi	r25, 0x06	; 6
		break;
    12d0:	05 c0       	rjmp	.+10     	; 0x12dc <conversion+0x98>
		
		case 0x64:
		node=100;
    12d2:	94 e6       	ldi	r25, 0x64	; 100
		break;
    12d4:	03 c0       	rjmp	.+6      	; 0x12dc <conversion+0x98>
		case 0x65:
		node=101;
    12d6:	95 e6       	ldi	r25, 0x65	; 101
		break;
    12d8:	01 c0       	rjmp	.+2      	; 0x12dc <conversion+0x98>
{	unsigned char node;	
	
	switch(hex)
	{
		case 0x02:
		node=2;
    12da:	92 e0       	ldi	r25, 0x02	; 2
		break;
			
	}
	
	return node;
}
    12dc:	89 2f       	mov	r24, r25
    12de:	08 95       	ret

000012e0 <buzzer_on_zigbee>:
}*/

void buzzer_on_zigbee (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
    12e0:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore | 0x08;
    12e2:	88 60       	ori	r24, 0x08	; 8
 PORTC = port_restore;
    12e4:	85 bb       	out	0x15, r24	; 21
}
    12e6:	08 95       	ret

000012e8 <buzzer_off_zigbee>:

void buzzer_off_zigbee (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
    12e8:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore & 0xF7;
    12ea:	87 7f       	andi	r24, 0xF7	; 247
 PORTC = port_restore;
    12ec:	85 bb       	out	0x15, r24	; 21
}
    12ee:	08 95       	ret

000012f0 <init_devices_zigbee>:

void init_devices_zigbee (void)
{
 cli();         //Clears the global interrupts
    12f0:	f8 94       	cli
 port_init_zigbee();
    12f2:	0e 94 15 09 	call	0x122a	; 0x122a <port_init_zigbee>
 uart0_init_zigbee();
    12f6:	0e 94 18 09 	call	0x1230	; 0x1230 <uart0_init_zigbee>
 sei();         //Enables the global interrupts
    12fa:	78 94       	sei
}
    12fc:	08 95       	ret

000012fe <__vector_11>:

SIGNAL(SIG_UART_RECV) 
{	//init_devices_buzzer();
    12fe:	1f 92       	push	r1
    1300:	0f 92       	push	r0
    1302:	0f b6       	in	r0, 0x3f	; 63
    1304:	0f 92       	push	r0
    1306:	11 24       	eor	r1, r1
    1308:	0f 93       	push	r16
    130a:	1f 93       	push	r17
    130c:	2f 93       	push	r18
    130e:	3f 93       	push	r19
    1310:	4f 93       	push	r20
    1312:	5f 93       	push	r21
    1314:	6f 93       	push	r22
    1316:	7f 93       	push	r23
    1318:	8f 93       	push	r24
    131a:	9f 93       	push	r25
    131c:	af 93       	push	r26
    131e:	bf 93       	push	r27
    1320:	cf 93       	push	r28
    1322:	ef 93       	push	r30
    1324:	ff 93       	push	r31
	
	          
 unsigned char k;
 k=UDR;         // Echo the received data plus 1
    1326:	cc b1       	in	r28, 0x0c	; 12
if(k==0x35)//53
    1328:	c5 33       	cpi	r28, 0x35	; 53
    132a:	d1 f4       	brne	.+52     	; 0x1360 <__vector_11+0x62>
{
	mark=1;
    132c:	81 e0       	ldi	r24, 0x01	; 1
    132e:	80 93 60 00 	sts	0x0060, r24
	buzzer_on();
    1332:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1336:	8f ef       	ldi	r24, 0xFF	; 255
    1338:	9f eb       	ldi	r25, 0xBF	; 191
    133a:	a6 e0       	ldi	r26, 0x06	; 6
    133c:	81 50       	subi	r24, 0x01	; 1
    133e:	90 40       	sbci	r25, 0x00	; 0
    1340:	a0 40       	sbci	r26, 0x00	; 0
    1342:	e1 f7       	brne	.-8      	; 0x133c <__vector_11+0x3e>
    1344:	00 c0       	rjmp	.+0      	; 0x1346 <__vector_11+0x48>
    1346:	00 00       	nop
	_delay_ms(300);
	buzzer_off();
    1348:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    134c:	8f ef       	ldi	r24, 0xFF	; 255
    134e:	9f eb       	ldi	r25, 0xBF	; 191
    1350:	a6 e0       	ldi	r26, 0x06	; 6
    1352:	81 50       	subi	r24, 0x01	; 1
    1354:	90 40       	sbci	r25, 0x00	; 0
    1356:	a0 40       	sbci	r26, 0x00	; 0
    1358:	e1 f7       	brne	.-8      	; 0x1352 <__vector_11+0x54>
    135a:	00 c0       	rjmp	.+0      	; 0x135c <__vector_11+0x5e>
    135c:	00 00       	nop
    135e:	1f c0       	rjmp	.+62     	; 0x139e <__vector_11+0xa0>
	_delay_ms(300);
}
if (k==0x36)//54
    1360:	c6 33       	cpi	r28, 0x36	; 54
    1362:	e9 f4       	brne	.+58     	; 0x139e <__vector_11+0xa0>
{
	mark=0;
    1364:	10 92 60 00 	sts	0x0060, r1
	next++;
    1368:	80 91 71 00 	lds	r24, 0x0071
    136c:	8f 5f       	subi	r24, 0xFF	; 255
    136e:	80 93 71 00 	sts	0x0071, r24
	buzzer_on();
    1372:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1376:	8f ef       	ldi	r24, 0xFF	; 255
    1378:	9f eb       	ldi	r25, 0xBF	; 191
    137a:	a6 e0       	ldi	r26, 0x06	; 6
    137c:	81 50       	subi	r24, 0x01	; 1
    137e:	90 40       	sbci	r25, 0x00	; 0
    1380:	a0 40       	sbci	r26, 0x00	; 0
    1382:	e1 f7       	brne	.-8      	; 0x137c <__vector_11+0x7e>
    1384:	00 c0       	rjmp	.+0      	; 0x1386 <__vector_11+0x88>
    1386:	00 00       	nop
	_delay_ms(300);
	buzzer_off();
    1388:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    138c:	8f ef       	ldi	r24, 0xFF	; 255
    138e:	9f eb       	ldi	r25, 0xBF	; 191
    1390:	a6 e0       	ldi	r26, 0x06	; 6
    1392:	81 50       	subi	r24, 0x01	; 1
    1394:	90 40       	sbci	r25, 0x00	; 0
    1396:	a0 40       	sbci	r26, 0x00	; 0
    1398:	e1 f7       	brne	.-8      	; 0x1392 <__vector_11+0x94>
    139a:	00 c0       	rjmp	.+0      	; 0x139c <__vector_11+0x9e>
    139c:	00 00       	nop
	_delay_ms(300);
}

	if (mark==1)
    139e:	80 91 60 00 	lds	r24, 0x0060
    13a2:	81 30       	cpi	r24, 0x01	; 1
    13a4:	09 f0       	breq	.+2      	; 0x13a8 <__vector_11+0xaa>
    13a6:	53 c0       	rjmp	.+166    	; 0x144e <__vector_11+0x150>
	{
		if(k>0x00 && k<0x31)//0-49
    13a8:	8c 2f       	mov	r24, r28
    13aa:	81 50       	subi	r24, 0x01	; 1
    13ac:	80 33       	cpi	r24, 0x30	; 48
    13ae:	30 f5       	brcc	.+76     	; 0x13fc <__vector_11+0xfe>
		{
			blue_nodes[b]=conversion(k);
    13b0:	00 91 73 00 	lds	r16, 0x0073
    13b4:	10 e0       	ldi	r17, 0x00	; 0
    13b6:	8c 2f       	mov	r24, r28
    13b8:	0e 94 22 09 	call	0x1244	; 0x1244 <conversion>
    13bc:	f8 01       	movw	r30, r16
    13be:	e2 57       	subi	r30, 0x72	; 114
    13c0:	ff 4f       	sbci	r31, 0xFF	; 255
    13c2:	80 83       	st	Z, r24
			
			b++;
    13c4:	80 91 73 00 	lds	r24, 0x0073
    13c8:	8f 5f       	subi	r24, 0xFF	; 255
    13ca:	80 93 73 00 	sts	0x0073, r24
			buzzer_on();
    13ce:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    13d2:	8f ef       	ldi	r24, 0xFF	; 255
    13d4:	9f eb       	ldi	r25, 0xBF	; 191
    13d6:	a6 e0       	ldi	r26, 0x06	; 6
    13d8:	81 50       	subi	r24, 0x01	; 1
    13da:	90 40       	sbci	r25, 0x00	; 0
    13dc:	a0 40       	sbci	r26, 0x00	; 0
    13de:	e1 f7       	brne	.-8      	; 0x13d8 <__vector_11+0xda>
    13e0:	00 c0       	rjmp	.+0      	; 0x13e2 <__vector_11+0xe4>
    13e2:	00 00       	nop
			_delay_ms(300);
			buzzer_off();
    13e4:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    13e8:	8f ef       	ldi	r24, 0xFF	; 255
    13ea:	9f eb       	ldi	r25, 0xBF	; 191
    13ec:	a6 e0       	ldi	r26, 0x06	; 6
    13ee:	81 50       	subi	r24, 0x01	; 1
    13f0:	90 40       	sbci	r25, 0x00	; 0
    13f2:	a0 40       	sbci	r26, 0x00	; 0
    13f4:	e1 f7       	brne	.-8      	; 0x13ee <__vector_11+0xf0>
    13f6:	00 c0       	rjmp	.+0      	; 0x13f8 <__vector_11+0xfa>
    13f8:	00 00       	nop
    13fa:	29 c0       	rjmp	.+82     	; 0x144e <__vector_11+0x150>
			_delay_ms(300);
			
		}
		else if(k==0x64 || k==0x65)//100-101
    13fc:	8c 2f       	mov	r24, r28
    13fe:	84 56       	subi	r24, 0x64	; 100
    1400:	82 30       	cpi	r24, 0x02	; 2
    1402:	28 f5       	brcc	.+74     	; 0x144e <__vector_11+0x150>
		{
			blue_side[bs]=conversion(k);
    1404:	00 91 72 00 	lds	r16, 0x0072
    1408:	10 e0       	ldi	r17, 0x00	; 0
    140a:	8c 2f       	mov	r24, r28
    140c:	0e 94 22 09 	call	0x1244	; 0x1244 <conversion>
    1410:	f8 01       	movw	r30, r16
    1412:	e4 55       	subi	r30, 0x54	; 84
    1414:	ff 4f       	sbci	r31, 0xFF	; 255
    1416:	80 83       	st	Z, r24
			bs++;
    1418:	80 91 72 00 	lds	r24, 0x0072
    141c:	8f 5f       	subi	r24, 0xFF	; 255
    141e:	80 93 72 00 	sts	0x0072, r24
			buzzer_on();
    1422:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1426:	8f ef       	ldi	r24, 0xFF	; 255
    1428:	9f eb       	ldi	r25, 0xBF	; 191
    142a:	a6 e0       	ldi	r26, 0x06	; 6
    142c:	81 50       	subi	r24, 0x01	; 1
    142e:	90 40       	sbci	r25, 0x00	; 0
    1430:	a0 40       	sbci	r26, 0x00	; 0
    1432:	e1 f7       	brne	.-8      	; 0x142c <__vector_11+0x12e>
    1434:	00 c0       	rjmp	.+0      	; 0x1436 <__vector_11+0x138>
    1436:	00 00       	nop
			_delay_ms(300);
			buzzer_off();
    1438:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    143c:	8f ef       	ldi	r24, 0xFF	; 255
    143e:	9f eb       	ldi	r25, 0xBF	; 191
    1440:	a6 e0       	ldi	r26, 0x06	; 6
    1442:	81 50       	subi	r24, 0x01	; 1
    1444:	90 40       	sbci	r25, 0x00	; 0
    1446:	a0 40       	sbci	r26, 0x00	; 0
    1448:	e1 f7       	brne	.-8      	; 0x1442 <__vector_11+0x144>
    144a:	00 c0       	rjmp	.+0      	; 0x144c <__vector_11+0x14e>
    144c:	00 00       	nop
			_delay_ms(300);
		}
	}		
 
}
    144e:	ff 91       	pop	r31
    1450:	ef 91       	pop	r30
    1452:	cf 91       	pop	r28
    1454:	bf 91       	pop	r27
    1456:	af 91       	pop	r26
    1458:	9f 91       	pop	r25
    145a:	8f 91       	pop	r24
    145c:	7f 91       	pop	r23
    145e:	6f 91       	pop	r22
    1460:	5f 91       	pop	r21
    1462:	4f 91       	pop	r20
    1464:	3f 91       	pop	r19
    1466:	2f 91       	pop	r18
    1468:	1f 91       	pop	r17
    146a:	0f 91       	pop	r16
    146c:	0f 90       	pop	r0
    146e:	0f be       	out	0x3f, r0	; 63
    1470:	0f 90       	pop	r0
    1472:	1f 90       	pop	r1
    1474:	18 95       	reti

00001476 <USARTWriteChar>:
		//Do nothing
	*/

	//Now write the data to USART buffer
  
	UDR=data;
    1476:	8c b9       	out	0x0c, r24	; 12
		
	
}
    1478:	08 95       	ret

0000147a <direction>:
	PORTC=PORTC& 0x8F;//1000 1111
	//buzzer_beep();
}

void direction(void)
{	init_devices_buzzer();
    147a:	0f 93       	push	r16
    147c:	1f 93       	push	r17
    147e:	cf 93       	push	r28
    1480:	df 93       	push	r29
    1482:	0e 94 db 00 	call	0x1b6	; 0x1b6 <init_devices_buzzer>
	
	int w=0;
	if(t==max)
    1486:	90 91 76 00 	lds	r25, 0x0076
    148a:	80 91 80 00 	lds	r24, 0x0080
    148e:	98 17       	cp	r25, r24
    1490:	09 f0       	breq	.+2      	; 0x1494 <direction+0x1a>
    1492:	55 c1       	rjmp	.+682    	; 0x173e <direction+0x2c4>
	{	if(stage==1)
    1494:	80 91 65 00 	lds	r24, 0x0065
    1498:	81 30       	cpi	r24, 0x01	; 1
    149a:	09 f0       	breq	.+2      	; 0x149e <direction+0x24>
    149c:	4e c0       	rjmp	.+156    	; 0x153a <direction+0xc0>
		{	buzzer_beep();
    149e:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_beep>
			if(dir==3)
    14a2:	80 91 66 00 	lds	r24, 0x0066
    14a6:	83 30       	cpi	r24, 0x03	; 3
    14a8:	81 f4       	brne	.+32     	; 0x14ca <direction+0x50>
			{	//buzzer_beep();
				right_degrees(190);
    14aa:	8e eb       	ldi	r24, 0xBE	; 190
    14ac:	90 e0       	ldi	r25, 0x00	; 0
    14ae:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <right_degrees>
				stop_pos();
    14b2:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
    14b6:	8f ef       	ldi	r24, 0xFF	; 255
    14b8:	9f e3       	ldi	r25, 0x3F	; 63
    14ba:	ab e0       	ldi	r26, 0x0B	; 11
    14bc:	81 50       	subi	r24, 0x01	; 1
    14be:	90 40       	sbci	r25, 0x00	; 0
    14c0:	a0 40       	sbci	r26, 0x00	; 0
    14c2:	e1 f7       	brne	.-8      	; 0x14bc <direction+0x42>
    14c4:	00 c0       	rjmp	.+0      	; 0x14c6 <direction+0x4c>
    14c6:	00 00       	nop
    14c8:	23 c0       	rjmp	.+70     	; 0x1510 <direction+0x96>
				_delay_ms(500);
			}
			else if(dir==4)
    14ca:	84 30       	cpi	r24, 0x04	; 4
    14cc:	81 f4       	brne	.+32     	; 0x14ee <direction+0x74>
			{
				right_degrees(100);
    14ce:	84 e6       	ldi	r24, 0x64	; 100
    14d0:	90 e0       	ldi	r25, 0x00	; 0
    14d2:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <right_degrees>
				stop_pos();
    14d6:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
    14da:	8f ef       	ldi	r24, 0xFF	; 255
    14dc:	9f e3       	ldi	r25, 0x3F	; 63
    14de:	ab e0       	ldi	r26, 0x0B	; 11
    14e0:	81 50       	subi	r24, 0x01	; 1
    14e2:	90 40       	sbci	r25, 0x00	; 0
    14e4:	a0 40       	sbci	r26, 0x00	; 0
    14e6:	e1 f7       	brne	.-8      	; 0x14e0 <direction+0x66>
    14e8:	00 c0       	rjmp	.+0      	; 0x14ea <direction+0x70>
    14ea:	00 00       	nop
    14ec:	11 c0       	rjmp	.+34     	; 0x1510 <direction+0x96>
				_delay_ms(500);
			}
			else if(dir==2)
    14ee:	82 30       	cpi	r24, 0x02	; 2
    14f0:	79 f4       	brne	.+30     	; 0x1510 <direction+0x96>
			{
				left_degrees(100);
    14f2:	84 e6       	ldi	r24, 0x64	; 100
    14f4:	90 e0       	ldi	r25, 0x00	; 0
    14f6:	0e 94 ce 03 	call	0x79c	; 0x79c <left_degrees>
				stop_pos();
    14fa:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
    14fe:	8f ef       	ldi	r24, 0xFF	; 255
    1500:	9f e3       	ldi	r25, 0x3F	; 63
    1502:	ab e0       	ldi	r26, 0x0B	; 11
    1504:	81 50       	subi	r24, 0x01	; 1
    1506:	90 40       	sbci	r25, 0x00	; 0
    1508:	a0 40       	sbci	r26, 0x00	; 0
    150a:	e1 f7       	brne	.-8      	; 0x1504 <direction+0x8a>
    150c:	00 c0       	rjmp	.+0      	; 0x150e <direction+0x94>
    150e:	00 00       	nop
				_delay_ms(500);
			}
			
			dir=1;
    1510:	c1 e0       	ldi	r28, 0x01	; 1
    1512:	c0 93 66 00 	sts	0x0066, r28
		back_mm(100);
    1516:	84 e6       	ldi	r24, 0x64	; 100
    1518:	90 e0       	ldi	r25, 0x00	; 0
    151a:	0e 94 c3 03 	call	0x786	; 0x786 <back_mm>
		stop_pos();
    151e:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
    1522:	8f ef       	ldi	r24, 0xFF	; 255
    1524:	9f e3       	ldi	r25, 0x3F	; 63
    1526:	ab e0       	ldi	r26, 0x0B	; 11
    1528:	81 50       	subi	r24, 0x01	; 1
    152a:	90 40       	sbci	r25, 0x00	; 0
    152c:	a0 40       	sbci	r26, 0x00	; 0
    152e:	e1 f7       	brne	.-8      	; 0x1528 <direction+0xae>
    1530:	00 c0       	rjmp	.+0      	; 0x1532 <direction+0xb8>
    1532:	00 00       	nop
		_delay_ms(500);
			g=1;
    1534:	c0 93 81 00 	sts	0x0081, r28
    1538:	02 c1       	rjmp	.+516    	; 0x173e <direction+0x2c4>
		}
		else if(stage==2)
    153a:	82 30       	cpi	r24, 0x02	; 2
    153c:	09 f0       	breq	.+2      	; 0x1540 <direction+0xc6>
    153e:	f4 c0       	rjmp	.+488    	; 0x1728 <direction+0x2ae>

		{	
			
			init_devices_zigbee();
    1540:	0e 94 78 09 	call	0x12f0	; 0x12f0 <init_devices_zigbee>
    1544:	8f ef       	ldi	r24, 0xFF	; 255
    1546:	9f e3       	ldi	r25, 0x3F	; 63
    1548:	a2 e0       	ldi	r26, 0x02	; 2
    154a:	81 50       	subi	r24, 0x01	; 1
    154c:	90 40       	sbci	r25, 0x00	; 0
    154e:	a0 40       	sbci	r26, 0x00	; 0
    1550:	e1 f7       	brne	.-8      	; 0x154a <direction+0xd0>
    1552:	00 c0       	rjmp	.+0      	; 0x1554 <direction+0xda>
    1554:	00 00       	nop
			_delay_ms(100);
			while (1)
			{
				if(next>3)
    1556:	80 91 71 00 	lds	r24, 0x0071
    155a:	84 30       	cpi	r24, 0x04	; 4
    155c:	e0 f3       	brcs	.-8      	; 0x1556 <direction+0xdc>
					break;
					
				}
			}
			
			red_nodes[0]=51;
    155e:	93 e3       	ldi	r25, 0x33	; 51
    1560:	90 93 f3 00 	sts	0x00F3, r25
			red_nodes[r]=52;
    1564:	e0 91 64 00 	lds	r30, 0x0064
    1568:	f0 e0       	ldi	r31, 0x00	; 0
    156a:	ed 50       	subi	r30, 0x0D	; 13
    156c:	ff 4f       	sbci	r31, 0xFF	; 255
    156e:	84 e3       	ldi	r24, 0x34	; 52
    1570:	80 83       	st	Z, r24
			red_side[0]=51;
    1572:	90 93 ff 00 	sts	0x00FF, r25
			red_side[rs]=52;
    1576:	e0 91 63 00 	lds	r30, 0x0063
    157a:	f0 e0       	ldi	r31, 0x00	; 0
    157c:	e1 50       	subi	r30, 0x01	; 1
    157e:	ff 4f       	sbci	r31, 0xFF	; 255
    1580:	80 83       	st	Z, r24
			for(int i=0;i<=10;i++)
			{	if(red_nodes[i]==0)
    1582:	80 91 f3 00 	lds	r24, 0x00F3
    1586:	88 23       	and	r24, r24
    1588:	09 f0       	breq	.+2      	; 0x158c <direction+0x112>
    158a:	a1 c1       	rjmp	.+834    	; 0x18ce <direction+0x454>
    158c:	19 c0       	rjmp	.+50     	; 0x15c0 <direction+0x146>
    158e:	f8 01       	movw	r30, r16
    1590:	ec 0f       	add	r30, r28
    1592:	fd 1f       	adc	r31, r29
    1594:	80 81       	ld	r24, Z
    1596:	88 23       	and	r24, r24
    1598:	99 f0       	breq	.+38     	; 0x15c0 <direction+0x146>
				{
					
					break;
					
				}
				USARTWriteChar(red_nodes[i]);
    159a:	f8 01       	movw	r30, r16
    159c:	ec 0f       	add	r30, r28
    159e:	fd 1f       	adc	r31, r29
    15a0:	80 81       	ld	r24, Z
    15a2:	0e 94 3b 0a 	call	0x1476	; 0x1476 <USARTWriteChar>
    15a6:	8f ef       	ldi	r24, 0xFF	; 255
    15a8:	9f e3       	ldi	r25, 0x3F	; 63
    15aa:	a2 e0       	ldi	r26, 0x02	; 2
    15ac:	81 50       	subi	r24, 0x01	; 1
    15ae:	90 40       	sbci	r25, 0x00	; 0
    15b0:	a0 40       	sbci	r26, 0x00	; 0
    15b2:	e1 f7       	brne	.-8      	; 0x15ac <direction+0x132>
    15b4:	00 c0       	rjmp	.+0      	; 0x15b6 <direction+0x13c>
    15b6:	00 00       	nop
			
			red_nodes[0]=51;
			red_nodes[r]=52;
			red_side[0]=51;
			red_side[rs]=52;
			for(int i=0;i<=10;i++)
    15b8:	21 96       	adiw	r28, 0x01	; 1
    15ba:	cb 30       	cpi	r28, 0x0B	; 11
    15bc:	d1 05       	cpc	r29, r1
    15be:	39 f7       	brne	.-50     	; 0x158e <direction+0x114>
				}*/
				
				
			}
			
			buzzer_on();
    15c0:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    15c4:	8f ef       	ldi	r24, 0xFF	; 255
    15c6:	9f e7       	ldi	r25, 0x7F	; 127
    15c8:	a6 e1       	ldi	r26, 0x16	; 22
    15ca:	81 50       	subi	r24, 0x01	; 1
    15cc:	90 40       	sbci	r25, 0x00	; 0
    15ce:	a0 40       	sbci	r26, 0x00	; 0
    15d0:	e1 f7       	brne	.-8      	; 0x15ca <direction+0x150>
    15d2:	00 c0       	rjmp	.+0      	; 0x15d4 <direction+0x15a>
    15d4:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    15d6:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
			for(int i=0;i<10;i++)
			{	if(red_side[i]==0)
    15da:	80 91 ff 00 	lds	r24, 0x00FF
    15de:	88 23       	and	r24, r24
    15e0:	09 f0       	breq	.+2      	; 0x15e4 <direction+0x16a>
    15e2:	63 c1       	rjmp	.+710    	; 0x18aa <direction+0x430>
    15e4:	19 c0       	rjmp	.+50     	; 0x1618 <direction+0x19e>
    15e6:	f8 01       	movw	r30, r16
    15e8:	ec 0f       	add	r30, r28
    15ea:	fd 1f       	adc	r31, r29
    15ec:	80 81       	ld	r24, Z
    15ee:	88 23       	and	r24, r24
    15f0:	99 f0       	breq	.+38     	; 0x1618 <direction+0x19e>
				{
					break;
				}
				USARTWriteChar(red_side[i]);
    15f2:	f8 01       	movw	r30, r16
    15f4:	ec 0f       	add	r30, r28
    15f6:	fd 1f       	adc	r31, r29
    15f8:	80 81       	ld	r24, Z
    15fa:	0e 94 3b 0a 	call	0x1476	; 0x1476 <USARTWriteChar>
    15fe:	8f ef       	ldi	r24, 0xFF	; 255
    1600:	9f e3       	ldi	r25, 0x3F	; 63
    1602:	a2 e0       	ldi	r26, 0x02	; 2
    1604:	81 50       	subi	r24, 0x01	; 1
    1606:	90 40       	sbci	r25, 0x00	; 0
    1608:	a0 40       	sbci	r26, 0x00	; 0
    160a:	e1 f7       	brne	.-8      	; 0x1604 <direction+0x18a>
    160c:	00 c0       	rjmp	.+0      	; 0x160e <direction+0x194>
    160e:	00 00       	nop
			}
			
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    1610:	21 96       	adiw	r28, 0x01	; 1
    1612:	ca 30       	cpi	r28, 0x0A	; 10
    1614:	d1 05       	cpc	r29, r1
    1616:	39 f7       	brne	.-50     	; 0x15e6 <direction+0x16c>
				USARTWriteChar(red_side[i]);
				_delay_ms(100);
				
			}
			
			buzzer_on();
    1618:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    161c:	8f ef       	ldi	r24, 0xFF	; 255
    161e:	9f e7       	ldi	r25, 0x7F	; 127
    1620:	a6 e1       	ldi	r26, 0x16	; 22
    1622:	81 50       	subi	r24, 0x01	; 1
    1624:	90 40       	sbci	r25, 0x00	; 0
    1626:	a0 40       	sbci	r26, 0x00	; 0
    1628:	e1 f7       	brne	.-8      	; 0x1622 <direction+0x1a8>
    162a:	00 c0       	rjmp	.+0      	; 0x162c <direction+0x1b2>
    162c:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    162e:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
			green_nodes[0]=55;
    1632:	97 e3       	ldi	r25, 0x37	; 55
    1634:	90 93 82 00 	sts	0x0082, r25
			green_nodes[gn]=56;
    1638:	e0 91 62 00 	lds	r30, 0x0062
    163c:	f0 e0       	ldi	r31, 0x00	; 0
    163e:	ee 57       	subi	r30, 0x7E	; 126
    1640:	ff 4f       	sbci	r31, 0xFF	; 255
    1642:	88 e3       	ldi	r24, 0x38	; 56
    1644:	80 83       	st	Z, r24
			green_side[0]=55;
    1646:	90 93 a0 00 	sts	0x00A0, r25
			green_side[gs]=56;
    164a:	e0 91 61 00 	lds	r30, 0x0061
    164e:	f0 e0       	ldi	r31, 0x00	; 0
    1650:	e0 56       	subi	r30, 0x60	; 96
    1652:	ff 4f       	sbci	r31, 0xFF	; 255
    1654:	80 83       	st	Z, r24
			for(int i=0;i<=10;i++)
			{	if(green_nodes[i]==0)
    1656:	80 91 82 00 	lds	r24, 0x0082
    165a:	88 23       	and	r24, r24
    165c:	09 f0       	breq	.+2      	; 0x1660 <direction+0x1e6>
    165e:	13 c1       	rjmp	.+550    	; 0x1886 <direction+0x40c>
    1660:	19 c0       	rjmp	.+50     	; 0x1694 <direction+0x21a>
    1662:	f8 01       	movw	r30, r16
    1664:	ec 0f       	add	r30, r28
    1666:	fd 1f       	adc	r31, r29
    1668:	80 81       	ld	r24, Z
    166a:	88 23       	and	r24, r24
    166c:	99 f0       	breq	.+38     	; 0x1694 <direction+0x21a>
				{
					
					break;
					
				}
				USARTWriteChar(green_nodes[i]);
    166e:	f8 01       	movw	r30, r16
    1670:	ec 0f       	add	r30, r28
    1672:	fd 1f       	adc	r31, r29
    1674:	80 81       	ld	r24, Z
    1676:	0e 94 3b 0a 	call	0x1476	; 0x1476 <USARTWriteChar>
    167a:	8f ef       	ldi	r24, 0xFF	; 255
    167c:	9f e7       	ldi	r25, 0x7F	; 127
    167e:	a6 e1       	ldi	r26, 0x16	; 22
    1680:	81 50       	subi	r24, 0x01	; 1
    1682:	90 40       	sbci	r25, 0x00	; 0
    1684:	a0 40       	sbci	r26, 0x00	; 0
    1686:	e1 f7       	brne	.-8      	; 0x1680 <direction+0x206>
    1688:	00 c0       	rjmp	.+0      	; 0x168a <direction+0x210>
    168a:	00 00       	nop
			buzzer_off();
			green_nodes[0]=55;
			green_nodes[gn]=56;
			green_side[0]=55;
			green_side[gs]=56;
			for(int i=0;i<=10;i++)
    168c:	21 96       	adiw	r28, 0x01	; 1
    168e:	cb 30       	cpi	r28, 0x0B	; 11
    1690:	d1 05       	cpc	r29, r1
    1692:	39 f7       	brne	.-50     	; 0x1662 <direction+0x1e8>
				
				_delay_ms(1000);
				//buzzer_beep();
				
			}
			buzzer_on();
    1694:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1698:	8f ef       	ldi	r24, 0xFF	; 255
    169a:	9f e7       	ldi	r25, 0x7F	; 127
    169c:	a6 e1       	ldi	r26, 0x16	; 22
    169e:	81 50       	subi	r24, 0x01	; 1
    16a0:	90 40       	sbci	r25, 0x00	; 0
    16a2:	a0 40       	sbci	r26, 0x00	; 0
    16a4:	e1 f7       	brne	.-8      	; 0x169e <direction+0x224>
    16a6:	00 c0       	rjmp	.+0      	; 0x16a8 <direction+0x22e>
    16a8:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    16aa:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
			for(int i=0;i<10;i++)
			{	if(green_side[i]==0)
    16ae:	80 91 a0 00 	lds	r24, 0x00A0
    16b2:	88 23       	and	r24, r24
    16b4:	09 f0       	breq	.+2      	; 0x16b8 <direction+0x23e>
    16b6:	d5 c0       	rjmp	.+426    	; 0x1862 <direction+0x3e8>
    16b8:	19 c0       	rjmp	.+50     	; 0x16ec <direction+0x272>
    16ba:	f8 01       	movw	r30, r16
    16bc:	ec 0f       	add	r30, r28
    16be:	fd 1f       	adc	r31, r29
    16c0:	80 81       	ld	r24, Z
    16c2:	88 23       	and	r24, r24
    16c4:	99 f0       	breq	.+38     	; 0x16ec <direction+0x272>
				{
					break;
				}
				USARTWriteChar(green_side[i]);
    16c6:	f8 01       	movw	r30, r16
    16c8:	ec 0f       	add	r30, r28
    16ca:	fd 1f       	adc	r31, r29
    16cc:	80 81       	ld	r24, Z
    16ce:	0e 94 3b 0a 	call	0x1476	; 0x1476 <USARTWriteChar>
    16d2:	8f ef       	ldi	r24, 0xFF	; 255
    16d4:	9f e7       	ldi	r25, 0x7F	; 127
    16d6:	a6 e1       	ldi	r26, 0x16	; 22
    16d8:	81 50       	subi	r24, 0x01	; 1
    16da:	90 40       	sbci	r25, 0x00	; 0
    16dc:	a0 40       	sbci	r26, 0x00	; 0
    16de:	e1 f7       	brne	.-8      	; 0x16d8 <direction+0x25e>
    16e0:	00 c0       	rjmp	.+0      	; 0x16e2 <direction+0x268>
    16e2:	00 00       	nop
				
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    16e4:	21 96       	adiw	r28, 0x01	; 1
    16e6:	ca 30       	cpi	r28, 0x0A	; 10
    16e8:	d1 05       	cpc	r29, r1
    16ea:	39 f7       	brne	.-50     	; 0x16ba <direction+0x240>
				}
				USARTWriteChar(green_side[i]);
				_delay_ms(1000);
				//buzzer_beep();
			}
			buzzer_on();
    16ec:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    16f0:	8f ef       	ldi	r24, 0xFF	; 255
    16f2:	9f e7       	ldi	r25, 0x7F	; 127
    16f4:	a6 e1       	ldi	r26, 0x16	; 22
    16f6:	81 50       	subi	r24, 0x01	; 1
    16f8:	90 40       	sbci	r25, 0x00	; 0
    16fa:	a0 40       	sbci	r26, 0x00	; 0
    16fc:	e1 f7       	brne	.-8      	; 0x16f6 <direction+0x27c>
    16fe:	00 c0       	rjmp	.+0      	; 0x1700 <direction+0x286>
    1700:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    1702:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
					break;
				}
				
			}*/
			
			g=1;
    1706:	81 e0       	ldi	r24, 0x01	; 1
    1708:	80 93 81 00 	sts	0x0081, r24
			buzzer_on();
    170c:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1710:	8f ef       	ldi	r24, 0xFF	; 255
    1712:	9f e7       	ldi	r25, 0x7F	; 127
    1714:	a6 e1       	ldi	r26, 0x16	; 22
    1716:	81 50       	subi	r24, 0x01	; 1
    1718:	90 40       	sbci	r25, 0x00	; 0
    171a:	a0 40       	sbci	r26, 0x00	; 0
    171c:	e1 f7       	brne	.-8      	; 0x1716 <direction+0x29c>
    171e:	00 c0       	rjmp	.+0      	; 0x1720 <direction+0x2a6>
    1720:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    1722:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    1726:	0b c0       	rjmp	.+22     	; 0x173e <direction+0x2c4>
			
			
		}
		else if(stage==3)
    1728:	83 30       	cpi	r24, 0x03	; 3
    172a:	21 f4       	brne	.+8      	; 0x1734 <direction+0x2ba>
		{
			g=1;
    172c:	81 e0       	ldi	r24, 0x01	; 1
    172e:	80 93 81 00 	sts	0x0081, r24
    1732:	05 c0       	rjmp	.+10     	; 0x173e <direction+0x2c4>
		
		}		
		else if(stage==4)
    1734:	84 30       	cpi	r24, 0x04	; 4
    1736:	19 f4       	brne	.+6      	; 0x173e <direction+0x2c4>
		{
			g=1;
    1738:	81 e0       	ldi	r24, 0x01	; 1
    173a:	80 93 81 00 	sts	0x0081, r24
		}		
		
		
		
	}
	if(t<max)
    173e:	20 91 76 00 	lds	r18, 0x0076
    1742:	80 91 80 00 	lds	r24, 0x0080
    1746:	28 17       	cp	r18, r24
    1748:	08 f0       	brcs	.+2      	; 0x174c <direction+0x2d2>
    174a:	d3 c0       	rjmp	.+422    	; 0x18f2 <direction+0x478>
	{
		w=(path1.path[t]-path1.path[t+1]);
    174c:	e8 ec       	ldi	r30, 0xC8	; 200
    174e:	f0 e0       	ldi	r31, 0x00	; 0
    1750:	e2 0f       	add	r30, r18
    1752:	f1 1d       	adc	r31, r1
    1754:	80 81       	ld	r24, Z
    1756:	90 e0       	ldi	r25, 0x00	; 0
    1758:	31 81       	ldd	r19, Z+1	; 0x01
    175a:	83 1b       	sub	r24, r19
    175c:	91 09       	sbc	r25, r1
		t++;
    175e:	2f 5f       	subi	r18, 0xFF	; 255
    1760:	20 93 76 00 	sts	0x0076, r18
			lcd_init();
			
		
		lcd_print(2,1,w,3);
		_delay_ms(4000);*/
		switch (w)
    1764:	af ef       	ldi	r26, 0xFF	; 255
    1766:	8f 3f       	cpi	r24, 0xFF	; 255
    1768:	9a 07       	cpc	r25, r26
    176a:	69 f1       	breq	.+90     	; 0x17c6 <direction+0x34c>
    176c:	bf ef       	ldi	r27, 0xFF	; 255
    176e:	8f 3f       	cpi	r24, 0xFF	; 255
    1770:	9b 07       	cpc	r25, r27
    1772:	09 f0       	breq	.+2      	; 0x1776 <direction+0x2fc>
    1774:	34 f4       	brge	.+12     	; 0x1782 <direction+0x308>
    1776:	2f ef       	ldi	r18, 0xFF	; 255
    1778:	89 3f       	cpi	r24, 0xF9	; 249
    177a:	92 07       	cpc	r25, r18
    177c:	09 f0       	breq	.+2      	; 0x1780 <direction+0x306>
    177e:	b9 c0       	rjmp	.+370    	; 0x18f2 <direction+0x478>
    1780:	56 c0       	rjmp	.+172    	; 0x182e <direction+0x3b4>
    1782:	81 30       	cpi	r24, 0x01	; 1
    1784:	91 05       	cpc	r25, r1
    1786:	29 f0       	breq	.+10     	; 0x1792 <direction+0x318>
    1788:	87 30       	cpi	r24, 0x07	; 7
    178a:	91 05       	cpc	r25, r1
    178c:	09 f0       	breq	.+2      	; 0x1790 <direction+0x316>
    178e:	b1 c0       	rjmp	.+354    	; 0x18f2 <direction+0x478>
    1790:	34 c0       	rjmp	.+104    	; 0x17fa <direction+0x380>
		{ 
			case 1:
			
				if(dir==1)
    1792:	80 91 66 00 	lds	r24, 0x0066
    1796:	81 30       	cpi	r24, 0x01	; 1
    1798:	29 f4       	brne	.+10     	; 0x17a4 <direction+0x32a>
				success(3);
    179a:	83 e0       	ldi	r24, 0x03	; 3
    179c:	90 e0       	ldi	r25, 0x00	; 0
    179e:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    17a2:	0d c0       	rjmp	.+26     	; 0x17be <direction+0x344>
				else if(dir==3)
    17a4:	83 30       	cpi	r24, 0x03	; 3
    17a6:	29 f4       	brne	.+10     	; 0x17b2 <direction+0x338>
				success(2);
    17a8:	82 e0       	ldi	r24, 0x02	; 2
    17aa:	90 e0       	ldi	r25, 0x00	; 0
    17ac:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    17b0:	06 c0       	rjmp	.+12     	; 0x17be <direction+0x344>
				else if(dir==4)
    17b2:	84 30       	cpi	r24, 0x04	; 4
    17b4:	21 f4       	brne	.+8      	; 0x17be <direction+0x344>
				success(1);
    17b6:	81 e0       	ldi	r24, 0x01	; 1
    17b8:	90 e0       	ldi	r25, 0x00	; 0
    17ba:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
				
				dir=4;
    17be:	84 e0       	ldi	r24, 0x04	; 4
    17c0:	80 93 66 00 	sts	0x0066, r24
				break;
    17c4:	96 c0       	rjmp	.+300    	; 0x18f2 <direction+0x478>
			
			case (-1):
			
				if(dir==1)
    17c6:	80 91 66 00 	lds	r24, 0x0066
    17ca:	81 30       	cpi	r24, 0x01	; 1
    17cc:	29 f4       	brne	.+10     	; 0x17d8 <direction+0x35e>
				success(2);
    17ce:	82 e0       	ldi	r24, 0x02	; 2
    17d0:	90 e0       	ldi	r25, 0x00	; 0
    17d2:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    17d6:	0d c0       	rjmp	.+26     	; 0x17f2 <direction+0x378>
				else if(dir==2)
    17d8:	82 30       	cpi	r24, 0x02	; 2
    17da:	29 f4       	brne	.+10     	; 0x17e6 <direction+0x36c>
				success(1);
    17dc:	81 e0       	ldi	r24, 0x01	; 1
    17de:	90 e0       	ldi	r25, 0x00	; 0
    17e0:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    17e4:	06 c0       	rjmp	.+12     	; 0x17f2 <direction+0x378>
				else if(dir==3)
    17e6:	83 30       	cpi	r24, 0x03	; 3
    17e8:	21 f4       	brne	.+8      	; 0x17f2 <direction+0x378>
				success(3);
    17ea:	83 e0       	ldi	r24, 0x03	; 3
    17ec:	90 e0       	ldi	r25, 0x00	; 0
    17ee:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
				
				dir=2;
    17f2:	82 e0       	ldi	r24, 0x02	; 2
    17f4:	80 93 66 00 	sts	0x0066, r24
				break;
    17f8:	7c c0       	rjmp	.+248    	; 0x18f2 <direction+0x478>
				
			
			case (7):
			
				if(dir==1)
    17fa:	80 91 66 00 	lds	r24, 0x0066
    17fe:	81 30       	cpi	r24, 0x01	; 1
    1800:	29 f4       	brne	.+10     	; 0x180c <direction+0x392>
				success(1);
    1802:	81 e0       	ldi	r24, 0x01	; 1
    1804:	90 e0       	ldi	r25, 0x00	; 0
    1806:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    180a:	0d c0       	rjmp	.+26     	; 0x1826 <direction+0x3ac>
				else if(dir==2)
    180c:	82 30       	cpi	r24, 0x02	; 2
    180e:	29 f4       	brne	.+10     	; 0x181a <direction+0x3a0>
				success(3);
    1810:	83 e0       	ldi	r24, 0x03	; 3
    1812:	90 e0       	ldi	r25, 0x00	; 0
    1814:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    1818:	06 c0       	rjmp	.+12     	; 0x1826 <direction+0x3ac>
				else if(dir==4)
    181a:	84 30       	cpi	r24, 0x04	; 4
    181c:	21 f4       	brne	.+8      	; 0x1826 <direction+0x3ac>
				success(2);
    181e:	82 e0       	ldi	r24, 0x02	; 2
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
				
				dir=1;
    1826:	81 e0       	ldi	r24, 0x01	; 1
    1828:	80 93 66 00 	sts	0x0066, r24
				break;
    182c:	62 c0       	rjmp	.+196    	; 0x18f2 <direction+0x478>
				
			
			case (-7):
			
				if(dir==2)
    182e:	80 91 66 00 	lds	r24, 0x0066
    1832:	82 30       	cpi	r24, 0x02	; 2
    1834:	29 f4       	brne	.+10     	; 0x1840 <direction+0x3c6>
				success(2);
    1836:	82 e0       	ldi	r24, 0x02	; 2
    1838:	90 e0       	ldi	r25, 0x00	; 0
    183a:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    183e:	0d c0       	rjmp	.+26     	; 0x185a <direction+0x3e0>
				else if(dir==3)
    1840:	83 30       	cpi	r24, 0x03	; 3
    1842:	29 f4       	brne	.+10     	; 0x184e <direction+0x3d4>
				success(1);
    1844:	81 e0       	ldi	r24, 0x01	; 1
    1846:	90 e0       	ldi	r25, 0x00	; 0
    1848:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    184c:	06 c0       	rjmp	.+12     	; 0x185a <direction+0x3e0>
				else if(dir==4)
    184e:	84 30       	cpi	r24, 0x04	; 4
    1850:	21 f4       	brne	.+8      	; 0x185a <direction+0x3e0>
				success(3);
    1852:	83 e0       	ldi	r24, 0x03	; 3
    1854:	90 e0       	ldi	r25, 0x00	; 0
    1856:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
				
				dir=3;
    185a:	83 e0       	ldi	r24, 0x03	; 3
    185c:	80 93 66 00 	sts	0x0066, r24
				break;
    1860:	48 c0       	rjmp	.+144    	; 0x18f2 <direction+0x478>
			for(int i=0;i<10;i++)
			{	if(green_side[i]==0)
				{
					break;
				}
				USARTWriteChar(green_side[i]);
    1862:	80 91 a0 00 	lds	r24, 0x00A0
    1866:	0e 94 3b 0a 	call	0x1476	; 0x1476 <USARTWriteChar>
    186a:	8f ef       	ldi	r24, 0xFF	; 255
    186c:	9f e7       	ldi	r25, 0x7F	; 127
    186e:	a6 e1       	ldi	r26, 0x16	; 22
    1870:	81 50       	subi	r24, 0x01	; 1
    1872:	90 40       	sbci	r25, 0x00	; 0
    1874:	a0 40       	sbci	r26, 0x00	; 0
    1876:	e1 f7       	brne	.-8      	; 0x1870 <direction+0x3f6>
    1878:	00 c0       	rjmp	.+0      	; 0x187a <direction+0x400>
    187a:	00 00       	nop
				
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    187c:	c1 e0       	ldi	r28, 0x01	; 1
    187e:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(green_side[i]==0)
    1880:	00 ea       	ldi	r16, 0xA0	; 160
    1882:	10 e0       	ldi	r17, 0x00	; 0
    1884:	1a cf       	rjmp	.-460    	; 0x16ba <direction+0x240>
				{
					
					break;
					
				}
				USARTWriteChar(green_nodes[i]);
    1886:	80 91 82 00 	lds	r24, 0x0082
    188a:	0e 94 3b 0a 	call	0x1476	; 0x1476 <USARTWriteChar>
    188e:	8f ef       	ldi	r24, 0xFF	; 255
    1890:	9f e7       	ldi	r25, 0x7F	; 127
    1892:	a6 e1       	ldi	r26, 0x16	; 22
    1894:	81 50       	subi	r24, 0x01	; 1
    1896:	90 40       	sbci	r25, 0x00	; 0
    1898:	a0 40       	sbci	r26, 0x00	; 0
    189a:	e1 f7       	brne	.-8      	; 0x1894 <direction+0x41a>
    189c:	00 c0       	rjmp	.+0      	; 0x189e <direction+0x424>
    189e:	00 00       	nop
			buzzer_off();
			green_nodes[0]=55;
			green_nodes[gn]=56;
			green_side[0]=55;
			green_side[gs]=56;
			for(int i=0;i<=10;i++)
    18a0:	c1 e0       	ldi	r28, 0x01	; 1
    18a2:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(green_nodes[i]==0)
    18a4:	02 e8       	ldi	r16, 0x82	; 130
    18a6:	10 e0       	ldi	r17, 0x00	; 0
    18a8:	dc ce       	rjmp	.-584    	; 0x1662 <direction+0x1e8>
			for(int i=0;i<10;i++)
			{	if(red_side[i]==0)
				{
					break;
				}
				USARTWriteChar(red_side[i]);
    18aa:	80 91 ff 00 	lds	r24, 0x00FF
    18ae:	0e 94 3b 0a 	call	0x1476	; 0x1476 <USARTWriteChar>
    18b2:	8f ef       	ldi	r24, 0xFF	; 255
    18b4:	9f e3       	ldi	r25, 0x3F	; 63
    18b6:	a2 e0       	ldi	r26, 0x02	; 2
    18b8:	81 50       	subi	r24, 0x01	; 1
    18ba:	90 40       	sbci	r25, 0x00	; 0
    18bc:	a0 40       	sbci	r26, 0x00	; 0
    18be:	e1 f7       	brne	.-8      	; 0x18b8 <direction+0x43e>
    18c0:	00 c0       	rjmp	.+0      	; 0x18c2 <direction+0x448>
    18c2:	00 00       	nop
			}
			
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    18c4:	c1 e0       	ldi	r28, 0x01	; 1
    18c6:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(red_side[i]==0)
    18c8:	0f ef       	ldi	r16, 0xFF	; 255
    18ca:	10 e0       	ldi	r17, 0x00	; 0
    18cc:	8c ce       	rjmp	.-744    	; 0x15e6 <direction+0x16c>
				{
					
					break;
					
				}
				USARTWriteChar(red_nodes[i]);
    18ce:	80 91 f3 00 	lds	r24, 0x00F3
    18d2:	0e 94 3b 0a 	call	0x1476	; 0x1476 <USARTWriteChar>
    18d6:	8f ef       	ldi	r24, 0xFF	; 255
    18d8:	9f e3       	ldi	r25, 0x3F	; 63
    18da:	a2 e0       	ldi	r26, 0x02	; 2
    18dc:	81 50       	subi	r24, 0x01	; 1
    18de:	90 40       	sbci	r25, 0x00	; 0
    18e0:	a0 40       	sbci	r26, 0x00	; 0
    18e2:	e1 f7       	brne	.-8      	; 0x18dc <direction+0x462>
    18e4:	00 c0       	rjmp	.+0      	; 0x18e6 <direction+0x46c>
    18e6:	00 00       	nop
			
			red_nodes[0]=51;
			red_nodes[r]=52;
			red_side[0]=51;
			red_side[rs]=52;
			for(int i=0;i<=10;i++)
    18e8:	c1 e0       	ldi	r28, 0x01	; 1
    18ea:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(red_nodes[i]==0)
    18ec:	03 ef       	ldi	r16, 0xF3	; 243
    18ee:	10 e0       	ldi	r17, 0x00	; 0
    18f0:	4e ce       	rjmp	.-868    	; 0x158e <direction+0x114>
			
			
		}
//		lcd_print(2,5,dir,2);
	}
}
    18f2:	df 91       	pop	r29
    18f4:	cf 91       	pop	r28
    18f6:	1f 91       	pop	r17
    18f8:	0f 91       	pop	r16
    18fa:	08 95       	ret

000018fc <array_init>:
//blue

void array_init()
{
	for(int i=0;i<=10;i++)
    18fc:	80 e0       	ldi	r24, 0x00	; 0
    18fe:	90 e0       	ldi	r25, 0x00	; 0
	{
		red_nodes[i]=0;
    1900:	23 ef       	ldi	r18, 0xF3	; 243
    1902:	30 e0       	ldi	r19, 0x00	; 0
		green_nodes[i]=0;
    1904:	42 e8       	ldi	r20, 0x82	; 130
    1906:	50 e0       	ldi	r21, 0x00	; 0

void array_init()
{
	for(int i=0;i<=10;i++)
	{
		red_nodes[i]=0;
    1908:	f9 01       	movw	r30, r18
    190a:	e8 0f       	add	r30, r24
    190c:	f9 1f       	adc	r31, r25
    190e:	10 82       	st	Z, r1
		green_nodes[i]=0;
    1910:	fa 01       	movw	r30, r20
    1912:	e8 0f       	add	r30, r24
    1914:	f9 1f       	adc	r31, r25
    1916:	10 82       	st	Z, r1
//blue

void array_init()
{
	for(int i=0;i<=10;i++)
    1918:	01 96       	adiw	r24, 0x01	; 1
    191a:	8b 30       	cpi	r24, 0x0B	; 11
    191c:	91 05       	cpc	r25, r1
    191e:	a1 f7       	brne	.-24     	; 0x1908 <array_init+0xc>
    1920:	80 e0       	ldi	r24, 0x00	; 0
    1922:	90 e0       	ldi	r25, 0x00	; 0
		red_nodes[i]=0;
		green_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
	{
		red_side[i]=0;
    1924:	2f ef       	ldi	r18, 0xFF	; 255
    1926:	30 e0       	ldi	r19, 0x00	; 0
		green_side[i]=0;
    1928:	40 ea       	ldi	r20, 0xA0	; 160
    192a:	50 e0       	ldi	r21, 0x00	; 0
		red_nodes[i]=0;
		green_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
	{
		red_side[i]=0;
    192c:	f9 01       	movw	r30, r18
    192e:	e8 0f       	add	r30, r24
    1930:	f9 1f       	adc	r31, r25
    1932:	10 82       	st	Z, r1
		green_side[i]=0;
    1934:	fa 01       	movw	r30, r20
    1936:	e8 0f       	add	r30, r24
    1938:	f9 1f       	adc	r31, r25
    193a:	10 82       	st	Z, r1
	for(int i=0;i<=10;i++)
	{
		red_nodes[i]=0;
		green_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
    193c:	01 96       	adiw	r24, 0x01	; 1
    193e:	85 31       	cpi	r24, 0x15	; 21
    1940:	91 05       	cpc	r25, r1
    1942:	a1 f7       	brne	.-24     	; 0x192c <array_init+0x30>
	{
		red_side[i]=0;
		green_side[i]=0;
	}
}
    1944:	08 95       	ret

00001946 <ReachDestinationAvoidingNode>:
#include "direction.h"
//#include "adjsrc4.h"


void ReachDestinationAvoidingNode(unsigned char Xd,unsigned char Yd)
{
    1946:	cf 93       	push	r28
    1948:	df 93       	push	r29
    194a:	cd b7       	in	r28, 0x3d	; 61
    194c:	de b7       	in	r29, 0x3e	; 62
    194e:	2f 97       	sbiw	r28, 0x0f	; 15
    1950:	0f b6       	in	r0, 0x3f	; 63
    1952:	f8 94       	cli
    1954:	de bf       	out	0x3e, r29	; 62
    1956:	0f be       	out	0x3f, r0	; 63
    1958:	cd bf       	out	0x3d, r28	; 61
	
	

	path1 = main_function7( start,des);
    195a:	ce 01       	movw	r24, r28
    195c:	01 96       	adiw	r24, 0x01	; 1
    195e:	60 91 68 00 	lds	r22, 0x0068
    1962:	40 91 67 00 	lds	r20, 0x0067
    1966:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <main_function7>
    196a:	a8 ec       	ldi	r26, 0xC8	; 200
    196c:	b0 e0       	ldi	r27, 0x00	; 0
    196e:	fe 01       	movw	r30, r28
    1970:	31 96       	adiw	r30, 0x01	; 1
    1972:	8f e0       	ldi	r24, 0x0F	; 15
    1974:	01 90       	ld	r0, Z+
    1976:	0d 92       	st	X+, r0
    1978:	81 50       	subi	r24, 0x01	; 1
    197a:	e1 f7       	brne	.-8      	; 0x1974 <ReachDestinationAvoidingNode+0x2e>
	
	
	

	init_devices();
    197c:	0e 94 81 06 	call	0xd02	; 0xd02 <init_devices>

	

	while(1)
	{
		line_follower();
    1980:	0e 94 8a 06 	call	0xd14	; 0xd14 <line_follower>
		if (g==1)
    1984:	80 91 81 00 	lds	r24, 0x0081
    1988:	81 30       	cpi	r24, 0x01	; 1
    198a:	d1 f7       	brne	.-12     	; 0x1980 <ReachDestinationAvoidingNode+0x3a>
			
		
		
	}
	
	g=0;
    198c:	10 92 81 00 	sts	0x0081, r1
	l=0;
    1990:	10 92 77 00 	sts	0x0077, r1
	t=0;
    1994:	10 92 76 00 	sts	0x0076, r1
	/*back();
	velocity(100,100);
	
	_delay_ms(500);*/
	
	start=des;
    1998:	80 91 67 00 	lds	r24, 0x0067
    199c:	80 93 68 00 	sts	0x0068, r24
}
    19a0:	2f 96       	adiw	r28, 0x0f	; 15
    19a2:	0f b6       	in	r0, 0x3f	; 63
    19a4:	f8 94       	cli
    19a6:	de bf       	out	0x3e, r29	; 62
    19a8:	0f be       	out	0x3f, r0	; 63
    19aa:	cd bf       	out	0x3d, r28	; 61
    19ac:	df 91       	pop	r29
    19ae:	cf 91       	pop	r28
    19b0:	08 95       	ret

000019b2 <main>:


//Do not make changes in main function

int main(void)
{   DDRB=0x20; 
    19b2:	80 e2       	ldi	r24, 0x20	; 32
    19b4:	87 bb       	out	0x17, r24	; 23
	init_devices_pos();
    19b6:	0e 94 18 04 	call	0x830	; 0x830 <init_devices_pos>
     ReachDestinationAvoidingNode(start,des);//6-46
    19ba:	80 91 68 00 	lds	r24, 0x0068
    19be:	60 91 67 00 	lds	r22, 0x0067
    19c2:	0e 94 a3 0c 	call	0x1946	; 0x1946 <ReachDestinationAvoidingNode>
	 buzzer_on();
    19c6:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    19ca:	8f ef       	ldi	r24, 0xFF	; 255
    19cc:	9f e7       	ldi	r25, 0x7F	; 127
    19ce:	a6 e1       	ldi	r26, 0x16	; 22
    19d0:	81 50       	subi	r24, 0x01	; 1
    19d2:	90 40       	sbci	r25, 0x00	; 0
    19d4:	a0 40       	sbci	r26, 0x00	; 0
    19d6:	e1 f7       	brne	.-8      	; 0x19d0 <main+0x1e>
    19d8:	00 c0       	rjmp	.+0      	; 0x19da <main+0x28>
    19da:	00 00       	nop
	   _delay_ms(1000);
	   buzzer_off();
    19dc:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
	stage=2;
    19e0:	82 e0       	ldi	r24, 0x02	; 2
    19e2:	80 93 65 00 	sts	0x0065, r24
	//start=5;
	des=4;
    19e6:	84 e0       	ldi	r24, 0x04	; 4
    19e8:	80 93 67 00 	sts	0x0067, r24
	array_init();
    19ec:	0e 94 7e 0c 	call	0x18fc	; 0x18fc <array_init>
		ReachDestinationAvoidingNode(start,des);//46-4
    19f0:	80 91 68 00 	lds	r24, 0x0068
    19f4:	60 91 67 00 	lds	r22, 0x0067
    19f8:	0e 94 a3 0c 	call	0x1946	; 0x1946 <ReachDestinationAvoidingNode>
	//stage=4;
	//des=2;
	//ReachDestinationAvoidingNode(start,des);//4-2
	
 	stage=3;
    19fc:	83 e0       	ldi	r24, 0x03	; 3
    19fe:	80 93 65 00 	sts	0x0065, r24
	//start=2;////////
	/////////////stage==3/////start=4///
	des=44;
    1a02:	8c e2       	ldi	r24, 0x2C	; 44
    1a04:	80 93 67 00 	sts	0x0067, r24
	ReachDestinationAvoidingNode(start,des);///2-44//4-44
    1a08:	80 91 68 00 	lds	r24, 0x0068
    1a0c:	6c e2       	ldi	r22, 0x2C	; 44
    1a0e:	0e 94 a3 0c 	call	0x1946	; 0x1946 <ReachDestinationAvoidingNode>
	
	//stage=4;
	//des=48;
	des=13;
    1a12:	8d e0       	ldi	r24, 0x0D	; 13
    1a14:	80 93 67 00 	sts	0x0067, r24
	buzzer_on();
    1a18:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1a1c:	8f ef       	ldi	r24, 0xFF	; 255
    1a1e:	9f e7       	ldi	r25, 0x7F	; 127
    1a20:	a6 e1       	ldi	r26, 0x16	; 22
    1a22:	81 50       	subi	r24, 0x01	; 1
    1a24:	90 40       	sbci	r25, 0x00	; 0
    1a26:	a0 40       	sbci	r26, 0x00	; 0
    1a28:	e1 f7       	brne	.-8      	; 0x1a22 <main+0x70>
    1a2a:	00 c0       	rjmp	.+0      	; 0x1a2c <main+0x7a>
    1a2c:	00 00       	nop
	_delay_ms(1000);
	buzzer_on();
    1a2e:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
	ReachDestinationAvoidingNode(start,des);//44-48//44-13
    1a32:	80 91 68 00 	lds	r24, 0x0068
    1a36:	60 91 67 00 	lds	r22, 0x0067
    1a3a:	0e 94 a3 0c 	call	0x1946	; 0x1946 <ReachDestinationAvoidingNode>
	buzzer_on();
    1a3e:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1a42:	8f ef       	ldi	r24, 0xFF	; 255
    1a44:	9f e7       	ldi	r25, 0x7F	; 127
    1a46:	a6 e1       	ldi	r26, 0x16	; 22
    1a48:	81 50       	subi	r24, 0x01	; 1
    1a4a:	90 40       	sbci	r25, 0x00	; 0
    1a4c:	a0 40       	sbci	r26, 0x00	; 0
    1a4e:	e1 f7       	brne	.-8      	; 0x1a48 <main+0x96>
    1a50:	00 c0       	rjmp	.+0      	; 0x1a52 <main+0xa0>
    1a52:	00 00       	nop
	_delay_ms(1000);
	buzzer_off();
    1a54:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
// 	ReachDestinationAvoidingNode(start,des);//48-13
// 	buzzer_on();
// 	_delay_ms(1000);
// 	buzzer_on();
// 	stage=4;
	des=14;
    1a58:	8e e0       	ldi	r24, 0x0E	; 14
    1a5a:	80 93 67 00 	sts	0x0067, r24
	ReachDestinationAvoidingNode(start,des);//13-14
    1a5e:	80 91 68 00 	lds	r24, 0x0068
    1a62:	6e e0       	ldi	r22, 0x0E	; 14
    1a64:	0e 94 a3 0c 	call	0x1946	; 0x1946 <ReachDestinationAvoidingNode>
	

	buzzer_on();
    1a68:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1a6c:	8f ef       	ldi	r24, 0xFF	; 255
    1a6e:	9f ef       	ldi	r25, 0xFF	; 255
    1a70:	ac e2       	ldi	r26, 0x2C	; 44
    1a72:	81 50       	subi	r24, 0x01	; 1
    1a74:	90 40       	sbci	r25, 0x00	; 0
    1a76:	a0 40       	sbci	r26, 0x00	; 0
    1a78:	e1 f7       	brne	.-8      	; 0x1a72 <main+0xc0>
    1a7a:	00 c0       	rjmp	.+0      	; 0x1a7c <main+0xca>
    1a7c:	00 00       	nop
	_delay_ms(2000);
	buzzer_on();
    1a7e:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
   forward();
    1a82:	0e 94 81 05 	call	0xb02	; 0xb02 <forward>
   velocity(0,0);
    1a86:	80 e0       	ldi	r24, 0x00	; 0
    1a88:	60 e0       	ldi	r22, 0x00	; 0
    1a8a:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
    1a8e:	8f ef       	ldi	r24, 0xFF	; 255
    1a90:	9f eb       	ldi	r25, 0xBF	; 191
    1a92:	a1 e2       	ldi	r26, 0x21	; 33
    1a94:	81 50       	subi	r24, 0x01	; 1
    1a96:	90 40       	sbci	r25, 0x00	; 0
    1a98:	a0 40       	sbci	r26, 0x00	; 0
    1a9a:	e1 f7       	brne	.-8      	; 0x1a94 <main+0xe2>
    1a9c:	00 c0       	rjmp	.+0      	; 0x1a9e <main+0xec>
    1a9e:	00 00       	nop
    1aa0:	ff cf       	rjmp	.-2      	; 0x1aa0 <main+0xee>

00001aa2 <__subsf3>:
    1aa2:	50 58       	subi	r21, 0x80	; 128

00001aa4 <__addsf3>:
    1aa4:	bb 27       	eor	r27, r27
    1aa6:	aa 27       	eor	r26, r26
    1aa8:	0e d0       	rcall	.+28     	; 0x1ac6 <__addsf3x>
    1aaa:	48 c1       	rjmp	.+656    	; 0x1d3c <__fp_round>
    1aac:	39 d1       	rcall	.+626    	; 0x1d20 <__fp_pscA>
    1aae:	30 f0       	brcs	.+12     	; 0x1abc <__addsf3+0x18>
    1ab0:	3e d1       	rcall	.+636    	; 0x1d2e <__fp_pscB>
    1ab2:	20 f0       	brcs	.+8      	; 0x1abc <__addsf3+0x18>
    1ab4:	31 f4       	brne	.+12     	; 0x1ac2 <__addsf3+0x1e>
    1ab6:	9f 3f       	cpi	r25, 0xFF	; 255
    1ab8:	11 f4       	brne	.+4      	; 0x1abe <__addsf3+0x1a>
    1aba:	1e f4       	brtc	.+6      	; 0x1ac2 <__addsf3+0x1e>
    1abc:	2e c1       	rjmp	.+604    	; 0x1d1a <__fp_nan>
    1abe:	0e f4       	brtc	.+2      	; 0x1ac2 <__addsf3+0x1e>
    1ac0:	e0 95       	com	r30
    1ac2:	e7 fb       	bst	r30, 7
    1ac4:	24 c1       	rjmp	.+584    	; 0x1d0e <__fp_inf>

00001ac6 <__addsf3x>:
    1ac6:	e9 2f       	mov	r30, r25
    1ac8:	4a d1       	rcall	.+660    	; 0x1d5e <__fp_split3>
    1aca:	80 f3       	brcs	.-32     	; 0x1aac <__addsf3+0x8>
    1acc:	ba 17       	cp	r27, r26
    1ace:	62 07       	cpc	r22, r18
    1ad0:	73 07       	cpc	r23, r19
    1ad2:	84 07       	cpc	r24, r20
    1ad4:	95 07       	cpc	r25, r21
    1ad6:	18 f0       	brcs	.+6      	; 0x1ade <__addsf3x+0x18>
    1ad8:	71 f4       	brne	.+28     	; 0x1af6 <__addsf3x+0x30>
    1ada:	9e f5       	brtc	.+102    	; 0x1b42 <__addsf3x+0x7c>
    1adc:	62 c1       	rjmp	.+708    	; 0x1da2 <__fp_zero>
    1ade:	0e f4       	brtc	.+2      	; 0x1ae2 <__addsf3x+0x1c>
    1ae0:	e0 95       	com	r30
    1ae2:	0b 2e       	mov	r0, r27
    1ae4:	ba 2f       	mov	r27, r26
    1ae6:	a0 2d       	mov	r26, r0
    1ae8:	0b 01       	movw	r0, r22
    1aea:	b9 01       	movw	r22, r18
    1aec:	90 01       	movw	r18, r0
    1aee:	0c 01       	movw	r0, r24
    1af0:	ca 01       	movw	r24, r20
    1af2:	a0 01       	movw	r20, r0
    1af4:	11 24       	eor	r1, r1
    1af6:	ff 27       	eor	r31, r31
    1af8:	59 1b       	sub	r21, r25
    1afa:	99 f0       	breq	.+38     	; 0x1b22 <__addsf3x+0x5c>
    1afc:	59 3f       	cpi	r21, 0xF9	; 249
    1afe:	50 f4       	brcc	.+20     	; 0x1b14 <__addsf3x+0x4e>
    1b00:	50 3e       	cpi	r21, 0xE0	; 224
    1b02:	68 f1       	brcs	.+90     	; 0x1b5e <__addsf3x+0x98>
    1b04:	1a 16       	cp	r1, r26
    1b06:	f0 40       	sbci	r31, 0x00	; 0
    1b08:	a2 2f       	mov	r26, r18
    1b0a:	23 2f       	mov	r18, r19
    1b0c:	34 2f       	mov	r19, r20
    1b0e:	44 27       	eor	r20, r20
    1b10:	58 5f       	subi	r21, 0xF8	; 248
    1b12:	f3 cf       	rjmp	.-26     	; 0x1afa <__addsf3x+0x34>
    1b14:	46 95       	lsr	r20
    1b16:	37 95       	ror	r19
    1b18:	27 95       	ror	r18
    1b1a:	a7 95       	ror	r26
    1b1c:	f0 40       	sbci	r31, 0x00	; 0
    1b1e:	53 95       	inc	r21
    1b20:	c9 f7       	brne	.-14     	; 0x1b14 <__addsf3x+0x4e>
    1b22:	7e f4       	brtc	.+30     	; 0x1b42 <__addsf3x+0x7c>
    1b24:	1f 16       	cp	r1, r31
    1b26:	ba 0b       	sbc	r27, r26
    1b28:	62 0b       	sbc	r22, r18
    1b2a:	73 0b       	sbc	r23, r19
    1b2c:	84 0b       	sbc	r24, r20
    1b2e:	ba f0       	brmi	.+46     	; 0x1b5e <__addsf3x+0x98>
    1b30:	91 50       	subi	r25, 0x01	; 1
    1b32:	a1 f0       	breq	.+40     	; 0x1b5c <__addsf3x+0x96>
    1b34:	ff 0f       	add	r31, r31
    1b36:	bb 1f       	adc	r27, r27
    1b38:	66 1f       	adc	r22, r22
    1b3a:	77 1f       	adc	r23, r23
    1b3c:	88 1f       	adc	r24, r24
    1b3e:	c2 f7       	brpl	.-16     	; 0x1b30 <__addsf3x+0x6a>
    1b40:	0e c0       	rjmp	.+28     	; 0x1b5e <__addsf3x+0x98>
    1b42:	ba 0f       	add	r27, r26
    1b44:	62 1f       	adc	r22, r18
    1b46:	73 1f       	adc	r23, r19
    1b48:	84 1f       	adc	r24, r20
    1b4a:	48 f4       	brcc	.+18     	; 0x1b5e <__addsf3x+0x98>
    1b4c:	87 95       	ror	r24
    1b4e:	77 95       	ror	r23
    1b50:	67 95       	ror	r22
    1b52:	b7 95       	ror	r27
    1b54:	f7 95       	ror	r31
    1b56:	9e 3f       	cpi	r25, 0xFE	; 254
    1b58:	08 f0       	brcs	.+2      	; 0x1b5c <__addsf3x+0x96>
    1b5a:	b3 cf       	rjmp	.-154    	; 0x1ac2 <__addsf3+0x1e>
    1b5c:	93 95       	inc	r25
    1b5e:	88 0f       	add	r24, r24
    1b60:	08 f0       	brcs	.+2      	; 0x1b64 <__addsf3x+0x9e>
    1b62:	99 27       	eor	r25, r25
    1b64:	ee 0f       	add	r30, r30
    1b66:	97 95       	ror	r25
    1b68:	87 95       	ror	r24
    1b6a:	08 95       	ret

00001b6c <__divsf3>:
    1b6c:	0c d0       	rcall	.+24     	; 0x1b86 <__divsf3x>
    1b6e:	e6 c0       	rjmp	.+460    	; 0x1d3c <__fp_round>
    1b70:	de d0       	rcall	.+444    	; 0x1d2e <__fp_pscB>
    1b72:	40 f0       	brcs	.+16     	; 0x1b84 <__divsf3+0x18>
    1b74:	d5 d0       	rcall	.+426    	; 0x1d20 <__fp_pscA>
    1b76:	30 f0       	brcs	.+12     	; 0x1b84 <__divsf3+0x18>
    1b78:	21 f4       	brne	.+8      	; 0x1b82 <__divsf3+0x16>
    1b7a:	5f 3f       	cpi	r21, 0xFF	; 255
    1b7c:	19 f0       	breq	.+6      	; 0x1b84 <__divsf3+0x18>
    1b7e:	c7 c0       	rjmp	.+398    	; 0x1d0e <__fp_inf>
    1b80:	51 11       	cpse	r21, r1
    1b82:	10 c1       	rjmp	.+544    	; 0x1da4 <__fp_szero>
    1b84:	ca c0       	rjmp	.+404    	; 0x1d1a <__fp_nan>

00001b86 <__divsf3x>:
    1b86:	eb d0       	rcall	.+470    	; 0x1d5e <__fp_split3>
    1b88:	98 f3       	brcs	.-26     	; 0x1b70 <__divsf3+0x4>

00001b8a <__divsf3_pse>:
    1b8a:	99 23       	and	r25, r25
    1b8c:	c9 f3       	breq	.-14     	; 0x1b80 <__divsf3+0x14>
    1b8e:	55 23       	and	r21, r21
    1b90:	b1 f3       	breq	.-20     	; 0x1b7e <__divsf3+0x12>
    1b92:	95 1b       	sub	r25, r21
    1b94:	55 0b       	sbc	r21, r21
    1b96:	bb 27       	eor	r27, r27
    1b98:	aa 27       	eor	r26, r26
    1b9a:	62 17       	cp	r22, r18
    1b9c:	73 07       	cpc	r23, r19
    1b9e:	84 07       	cpc	r24, r20
    1ba0:	38 f0       	brcs	.+14     	; 0x1bb0 <__divsf3_pse+0x26>
    1ba2:	9f 5f       	subi	r25, 0xFF	; 255
    1ba4:	5f 4f       	sbci	r21, 0xFF	; 255
    1ba6:	22 0f       	add	r18, r18
    1ba8:	33 1f       	adc	r19, r19
    1baa:	44 1f       	adc	r20, r20
    1bac:	aa 1f       	adc	r26, r26
    1bae:	a9 f3       	breq	.-22     	; 0x1b9a <__divsf3_pse+0x10>
    1bb0:	33 d0       	rcall	.+102    	; 0x1c18 <__divsf3_pse+0x8e>
    1bb2:	0e 2e       	mov	r0, r30
    1bb4:	3a f0       	brmi	.+14     	; 0x1bc4 <__divsf3_pse+0x3a>
    1bb6:	e0 e8       	ldi	r30, 0x80	; 128
    1bb8:	30 d0       	rcall	.+96     	; 0x1c1a <__divsf3_pse+0x90>
    1bba:	91 50       	subi	r25, 0x01	; 1
    1bbc:	50 40       	sbci	r21, 0x00	; 0
    1bbe:	e6 95       	lsr	r30
    1bc0:	00 1c       	adc	r0, r0
    1bc2:	ca f7       	brpl	.-14     	; 0x1bb6 <__divsf3_pse+0x2c>
    1bc4:	29 d0       	rcall	.+82     	; 0x1c18 <__divsf3_pse+0x8e>
    1bc6:	fe 2f       	mov	r31, r30
    1bc8:	27 d0       	rcall	.+78     	; 0x1c18 <__divsf3_pse+0x8e>
    1bca:	66 0f       	add	r22, r22
    1bcc:	77 1f       	adc	r23, r23
    1bce:	88 1f       	adc	r24, r24
    1bd0:	bb 1f       	adc	r27, r27
    1bd2:	26 17       	cp	r18, r22
    1bd4:	37 07       	cpc	r19, r23
    1bd6:	48 07       	cpc	r20, r24
    1bd8:	ab 07       	cpc	r26, r27
    1bda:	b0 e8       	ldi	r27, 0x80	; 128
    1bdc:	09 f0       	breq	.+2      	; 0x1be0 <__divsf3_pse+0x56>
    1bde:	bb 0b       	sbc	r27, r27
    1be0:	80 2d       	mov	r24, r0
    1be2:	bf 01       	movw	r22, r30
    1be4:	ff 27       	eor	r31, r31
    1be6:	93 58       	subi	r25, 0x83	; 131
    1be8:	5f 4f       	sbci	r21, 0xFF	; 255
    1bea:	2a f0       	brmi	.+10     	; 0x1bf6 <__divsf3_pse+0x6c>
    1bec:	9e 3f       	cpi	r25, 0xFE	; 254
    1bee:	51 05       	cpc	r21, r1
    1bf0:	68 f0       	brcs	.+26     	; 0x1c0c <__divsf3_pse+0x82>
    1bf2:	8d c0       	rjmp	.+282    	; 0x1d0e <__fp_inf>
    1bf4:	d7 c0       	rjmp	.+430    	; 0x1da4 <__fp_szero>
    1bf6:	5f 3f       	cpi	r21, 0xFF	; 255
    1bf8:	ec f3       	brlt	.-6      	; 0x1bf4 <__divsf3_pse+0x6a>
    1bfa:	98 3e       	cpi	r25, 0xE8	; 232
    1bfc:	dc f3       	brlt	.-10     	; 0x1bf4 <__divsf3_pse+0x6a>
    1bfe:	86 95       	lsr	r24
    1c00:	77 95       	ror	r23
    1c02:	67 95       	ror	r22
    1c04:	b7 95       	ror	r27
    1c06:	f7 95       	ror	r31
    1c08:	9f 5f       	subi	r25, 0xFF	; 255
    1c0a:	c9 f7       	brne	.-14     	; 0x1bfe <__divsf3_pse+0x74>
    1c0c:	88 0f       	add	r24, r24
    1c0e:	91 1d       	adc	r25, r1
    1c10:	96 95       	lsr	r25
    1c12:	87 95       	ror	r24
    1c14:	97 f9       	bld	r25, 7
    1c16:	08 95       	ret
    1c18:	e1 e0       	ldi	r30, 0x01	; 1
    1c1a:	66 0f       	add	r22, r22
    1c1c:	77 1f       	adc	r23, r23
    1c1e:	88 1f       	adc	r24, r24
    1c20:	bb 1f       	adc	r27, r27
    1c22:	62 17       	cp	r22, r18
    1c24:	73 07       	cpc	r23, r19
    1c26:	84 07       	cpc	r24, r20
    1c28:	ba 07       	cpc	r27, r26
    1c2a:	20 f0       	brcs	.+8      	; 0x1c34 <__divsf3_pse+0xaa>
    1c2c:	62 1b       	sub	r22, r18
    1c2e:	73 0b       	sbc	r23, r19
    1c30:	84 0b       	sbc	r24, r20
    1c32:	ba 0b       	sbc	r27, r26
    1c34:	ee 1f       	adc	r30, r30
    1c36:	88 f7       	brcc	.-30     	; 0x1c1a <__divsf3_pse+0x90>
    1c38:	e0 95       	com	r30
    1c3a:	08 95       	ret

00001c3c <__fixunssfsi>:
    1c3c:	98 d0       	rcall	.+304    	; 0x1d6e <__fp_splitA>
    1c3e:	88 f0       	brcs	.+34     	; 0x1c62 <__fixunssfsi+0x26>
    1c40:	9f 57       	subi	r25, 0x7F	; 127
    1c42:	90 f0       	brcs	.+36     	; 0x1c68 <__fixunssfsi+0x2c>
    1c44:	b9 2f       	mov	r27, r25
    1c46:	99 27       	eor	r25, r25
    1c48:	b7 51       	subi	r27, 0x17	; 23
    1c4a:	a0 f0       	brcs	.+40     	; 0x1c74 <__fixunssfsi+0x38>
    1c4c:	d1 f0       	breq	.+52     	; 0x1c82 <__fixunssfsi+0x46>
    1c4e:	66 0f       	add	r22, r22
    1c50:	77 1f       	adc	r23, r23
    1c52:	88 1f       	adc	r24, r24
    1c54:	99 1f       	adc	r25, r25
    1c56:	1a f0       	brmi	.+6      	; 0x1c5e <__fixunssfsi+0x22>
    1c58:	ba 95       	dec	r27
    1c5a:	c9 f7       	brne	.-14     	; 0x1c4e <__fixunssfsi+0x12>
    1c5c:	12 c0       	rjmp	.+36     	; 0x1c82 <__fixunssfsi+0x46>
    1c5e:	b1 30       	cpi	r27, 0x01	; 1
    1c60:	81 f0       	breq	.+32     	; 0x1c82 <__fixunssfsi+0x46>
    1c62:	9f d0       	rcall	.+318    	; 0x1da2 <__fp_zero>
    1c64:	b1 e0       	ldi	r27, 0x01	; 1
    1c66:	08 95       	ret
    1c68:	9c c0       	rjmp	.+312    	; 0x1da2 <__fp_zero>
    1c6a:	67 2f       	mov	r22, r23
    1c6c:	78 2f       	mov	r23, r24
    1c6e:	88 27       	eor	r24, r24
    1c70:	b8 5f       	subi	r27, 0xF8	; 248
    1c72:	39 f0       	breq	.+14     	; 0x1c82 <__fixunssfsi+0x46>
    1c74:	b9 3f       	cpi	r27, 0xF9	; 249
    1c76:	cc f3       	brlt	.-14     	; 0x1c6a <__fixunssfsi+0x2e>
    1c78:	86 95       	lsr	r24
    1c7a:	77 95       	ror	r23
    1c7c:	67 95       	ror	r22
    1c7e:	b3 95       	inc	r27
    1c80:	d9 f7       	brne	.-10     	; 0x1c78 <__fixunssfsi+0x3c>
    1c82:	3e f4       	brtc	.+14     	; 0x1c92 <__fixunssfsi+0x56>
    1c84:	90 95       	com	r25
    1c86:	80 95       	com	r24
    1c88:	70 95       	com	r23
    1c8a:	61 95       	neg	r22
    1c8c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c8e:	8f 4f       	sbci	r24, 0xFF	; 255
    1c90:	9f 4f       	sbci	r25, 0xFF	; 255
    1c92:	08 95       	ret

00001c94 <__floatunsisf>:
    1c94:	e8 94       	clt
    1c96:	09 c0       	rjmp	.+18     	; 0x1caa <__floatsisf+0x12>

00001c98 <__floatsisf>:
    1c98:	97 fb       	bst	r25, 7
    1c9a:	3e f4       	brtc	.+14     	; 0x1caa <__floatsisf+0x12>
    1c9c:	90 95       	com	r25
    1c9e:	80 95       	com	r24
    1ca0:	70 95       	com	r23
    1ca2:	61 95       	neg	r22
    1ca4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ca6:	8f 4f       	sbci	r24, 0xFF	; 255
    1ca8:	9f 4f       	sbci	r25, 0xFF	; 255
    1caa:	99 23       	and	r25, r25
    1cac:	a9 f0       	breq	.+42     	; 0x1cd8 <__floatsisf+0x40>
    1cae:	f9 2f       	mov	r31, r25
    1cb0:	96 e9       	ldi	r25, 0x96	; 150
    1cb2:	bb 27       	eor	r27, r27
    1cb4:	93 95       	inc	r25
    1cb6:	f6 95       	lsr	r31
    1cb8:	87 95       	ror	r24
    1cba:	77 95       	ror	r23
    1cbc:	67 95       	ror	r22
    1cbe:	b7 95       	ror	r27
    1cc0:	f1 11       	cpse	r31, r1
    1cc2:	f8 cf       	rjmp	.-16     	; 0x1cb4 <__floatsisf+0x1c>
    1cc4:	fa f4       	brpl	.+62     	; 0x1d04 <__floatsisf+0x6c>
    1cc6:	bb 0f       	add	r27, r27
    1cc8:	11 f4       	brne	.+4      	; 0x1cce <__floatsisf+0x36>
    1cca:	60 ff       	sbrs	r22, 0
    1ccc:	1b c0       	rjmp	.+54     	; 0x1d04 <__floatsisf+0x6c>
    1cce:	6f 5f       	subi	r22, 0xFF	; 255
    1cd0:	7f 4f       	sbci	r23, 0xFF	; 255
    1cd2:	8f 4f       	sbci	r24, 0xFF	; 255
    1cd4:	9f 4f       	sbci	r25, 0xFF	; 255
    1cd6:	16 c0       	rjmp	.+44     	; 0x1d04 <__floatsisf+0x6c>
    1cd8:	88 23       	and	r24, r24
    1cda:	11 f0       	breq	.+4      	; 0x1ce0 <__floatsisf+0x48>
    1cdc:	96 e9       	ldi	r25, 0x96	; 150
    1cde:	11 c0       	rjmp	.+34     	; 0x1d02 <__floatsisf+0x6a>
    1ce0:	77 23       	and	r23, r23
    1ce2:	21 f0       	breq	.+8      	; 0x1cec <__floatsisf+0x54>
    1ce4:	9e e8       	ldi	r25, 0x8E	; 142
    1ce6:	87 2f       	mov	r24, r23
    1ce8:	76 2f       	mov	r23, r22
    1cea:	05 c0       	rjmp	.+10     	; 0x1cf6 <__floatsisf+0x5e>
    1cec:	66 23       	and	r22, r22
    1cee:	71 f0       	breq	.+28     	; 0x1d0c <__floatsisf+0x74>
    1cf0:	96 e8       	ldi	r25, 0x86	; 134
    1cf2:	86 2f       	mov	r24, r22
    1cf4:	70 e0       	ldi	r23, 0x00	; 0
    1cf6:	60 e0       	ldi	r22, 0x00	; 0
    1cf8:	2a f0       	brmi	.+10     	; 0x1d04 <__floatsisf+0x6c>
    1cfa:	9a 95       	dec	r25
    1cfc:	66 0f       	add	r22, r22
    1cfe:	77 1f       	adc	r23, r23
    1d00:	88 1f       	adc	r24, r24
    1d02:	da f7       	brpl	.-10     	; 0x1cfa <__floatsisf+0x62>
    1d04:	88 0f       	add	r24, r24
    1d06:	96 95       	lsr	r25
    1d08:	87 95       	ror	r24
    1d0a:	97 f9       	bld	r25, 7
    1d0c:	08 95       	ret

00001d0e <__fp_inf>:
    1d0e:	97 f9       	bld	r25, 7
    1d10:	9f 67       	ori	r25, 0x7F	; 127
    1d12:	80 e8       	ldi	r24, 0x80	; 128
    1d14:	70 e0       	ldi	r23, 0x00	; 0
    1d16:	60 e0       	ldi	r22, 0x00	; 0
    1d18:	08 95       	ret

00001d1a <__fp_nan>:
    1d1a:	9f ef       	ldi	r25, 0xFF	; 255
    1d1c:	80 ec       	ldi	r24, 0xC0	; 192
    1d1e:	08 95       	ret

00001d20 <__fp_pscA>:
    1d20:	00 24       	eor	r0, r0
    1d22:	0a 94       	dec	r0
    1d24:	16 16       	cp	r1, r22
    1d26:	17 06       	cpc	r1, r23
    1d28:	18 06       	cpc	r1, r24
    1d2a:	09 06       	cpc	r0, r25
    1d2c:	08 95       	ret

00001d2e <__fp_pscB>:
    1d2e:	00 24       	eor	r0, r0
    1d30:	0a 94       	dec	r0
    1d32:	12 16       	cp	r1, r18
    1d34:	13 06       	cpc	r1, r19
    1d36:	14 06       	cpc	r1, r20
    1d38:	05 06       	cpc	r0, r21
    1d3a:	08 95       	ret

00001d3c <__fp_round>:
    1d3c:	09 2e       	mov	r0, r25
    1d3e:	03 94       	inc	r0
    1d40:	00 0c       	add	r0, r0
    1d42:	11 f4       	brne	.+4      	; 0x1d48 <__fp_round+0xc>
    1d44:	88 23       	and	r24, r24
    1d46:	52 f0       	brmi	.+20     	; 0x1d5c <__fp_round+0x20>
    1d48:	bb 0f       	add	r27, r27
    1d4a:	40 f4       	brcc	.+16     	; 0x1d5c <__fp_round+0x20>
    1d4c:	bf 2b       	or	r27, r31
    1d4e:	11 f4       	brne	.+4      	; 0x1d54 <__fp_round+0x18>
    1d50:	60 ff       	sbrs	r22, 0
    1d52:	04 c0       	rjmp	.+8      	; 0x1d5c <__fp_round+0x20>
    1d54:	6f 5f       	subi	r22, 0xFF	; 255
    1d56:	7f 4f       	sbci	r23, 0xFF	; 255
    1d58:	8f 4f       	sbci	r24, 0xFF	; 255
    1d5a:	9f 4f       	sbci	r25, 0xFF	; 255
    1d5c:	08 95       	ret

00001d5e <__fp_split3>:
    1d5e:	57 fd       	sbrc	r21, 7
    1d60:	90 58       	subi	r25, 0x80	; 128
    1d62:	44 0f       	add	r20, r20
    1d64:	55 1f       	adc	r21, r21
    1d66:	59 f0       	breq	.+22     	; 0x1d7e <__fp_splitA+0x10>
    1d68:	5f 3f       	cpi	r21, 0xFF	; 255
    1d6a:	71 f0       	breq	.+28     	; 0x1d88 <__fp_splitA+0x1a>
    1d6c:	47 95       	ror	r20

00001d6e <__fp_splitA>:
    1d6e:	88 0f       	add	r24, r24
    1d70:	97 fb       	bst	r25, 7
    1d72:	99 1f       	adc	r25, r25
    1d74:	61 f0       	breq	.+24     	; 0x1d8e <__fp_splitA+0x20>
    1d76:	9f 3f       	cpi	r25, 0xFF	; 255
    1d78:	79 f0       	breq	.+30     	; 0x1d98 <__fp_splitA+0x2a>
    1d7a:	87 95       	ror	r24
    1d7c:	08 95       	ret
    1d7e:	12 16       	cp	r1, r18
    1d80:	13 06       	cpc	r1, r19
    1d82:	14 06       	cpc	r1, r20
    1d84:	55 1f       	adc	r21, r21
    1d86:	f2 cf       	rjmp	.-28     	; 0x1d6c <__fp_split3+0xe>
    1d88:	46 95       	lsr	r20
    1d8a:	f1 df       	rcall	.-30     	; 0x1d6e <__fp_splitA>
    1d8c:	08 c0       	rjmp	.+16     	; 0x1d9e <__fp_splitA+0x30>
    1d8e:	16 16       	cp	r1, r22
    1d90:	17 06       	cpc	r1, r23
    1d92:	18 06       	cpc	r1, r24
    1d94:	99 1f       	adc	r25, r25
    1d96:	f1 cf       	rjmp	.-30     	; 0x1d7a <__fp_splitA+0xc>
    1d98:	86 95       	lsr	r24
    1d9a:	71 05       	cpc	r23, r1
    1d9c:	61 05       	cpc	r22, r1
    1d9e:	08 94       	sec
    1da0:	08 95       	ret

00001da2 <__fp_zero>:
    1da2:	e8 94       	clt

00001da4 <__fp_szero>:
    1da4:	bb 27       	eor	r27, r27
    1da6:	66 27       	eor	r22, r22
    1da8:	77 27       	eor	r23, r23
    1daa:	cb 01       	movw	r24, r22
    1dac:	97 f9       	bld	r25, 7
    1dae:	08 95       	ret

00001db0 <__divmodhi4>:
    1db0:	97 fb       	bst	r25, 7
    1db2:	09 2e       	mov	r0, r25
    1db4:	07 26       	eor	r0, r23
    1db6:	0a d0       	rcall	.+20     	; 0x1dcc <__divmodhi4_neg1>
    1db8:	77 fd       	sbrc	r23, 7
    1dba:	04 d0       	rcall	.+8      	; 0x1dc4 <__divmodhi4_neg2>
    1dbc:	0c d0       	rcall	.+24     	; 0x1dd6 <__udivmodhi4>
    1dbe:	06 d0       	rcall	.+12     	; 0x1dcc <__divmodhi4_neg1>
    1dc0:	00 20       	and	r0, r0
    1dc2:	1a f4       	brpl	.+6      	; 0x1dca <__divmodhi4_exit>

00001dc4 <__divmodhi4_neg2>:
    1dc4:	70 95       	com	r23
    1dc6:	61 95       	neg	r22
    1dc8:	7f 4f       	sbci	r23, 0xFF	; 255

00001dca <__divmodhi4_exit>:
    1dca:	08 95       	ret

00001dcc <__divmodhi4_neg1>:
    1dcc:	f6 f7       	brtc	.-4      	; 0x1dca <__divmodhi4_exit>
    1dce:	90 95       	com	r25
    1dd0:	81 95       	neg	r24
    1dd2:	9f 4f       	sbci	r25, 0xFF	; 255
    1dd4:	08 95       	ret

00001dd6 <__udivmodhi4>:
    1dd6:	aa 1b       	sub	r26, r26
    1dd8:	bb 1b       	sub	r27, r27
    1dda:	51 e1       	ldi	r21, 0x11	; 17
    1ddc:	07 c0       	rjmp	.+14     	; 0x1dec <__udivmodhi4_ep>

00001dde <__udivmodhi4_loop>:
    1dde:	aa 1f       	adc	r26, r26
    1de0:	bb 1f       	adc	r27, r27
    1de2:	a6 17       	cp	r26, r22
    1de4:	b7 07       	cpc	r27, r23
    1de6:	10 f0       	brcs	.+4      	; 0x1dec <__udivmodhi4_ep>
    1de8:	a6 1b       	sub	r26, r22
    1dea:	b7 0b       	sbc	r27, r23

00001dec <__udivmodhi4_ep>:
    1dec:	88 1f       	adc	r24, r24
    1dee:	99 1f       	adc	r25, r25
    1df0:	5a 95       	dec	r21
    1df2:	a9 f7       	brne	.-22     	; 0x1dde <__udivmodhi4_loop>
    1df4:	80 95       	com	r24
    1df6:	90 95       	com	r25
    1df8:	bc 01       	movw	r22, r24
    1dfa:	cd 01       	movw	r24, r26
    1dfc:	08 95       	ret

00001dfe <_exit>:
    1dfe:	f8 94       	cli

00001e00 <__stop_program>:
    1e00:	ff cf       	rjmp	.-2      	; 0x1e00 <__stop_program>
