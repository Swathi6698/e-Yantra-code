
final_spark_code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001f42  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000a  00800060  00001f42  00001fd6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000a9  0080006a  0080006a  00001fe0  2**0
                  ALLOC
  3 .stab         00001be4  00000000  00000000  00001fe0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000583  00000000  00000000  00003bc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00004148  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002cd1  00000000  00000000  00004208  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000479  00000000  00000000  00006ed9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000cf0  00000000  00000000  00007352  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000884  00000000  00000000  00008044  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000903  00000000  00000000  000088c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000249b  00000000  00000000  000091cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000118  00000000  00000000  0000b666  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 cd 02 	jmp	0x59a	; 0x59a <__vector_1>
       8:	0c 94 f2 02 	jmp	0x5e4	; 0x5e4 <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 df 07 	jmp	0xfbe	; 0xfbe <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 87 09 	jmp	0x130e	; 0x130e <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e4       	ldi	r30, 0x42	; 66
      68:	ff e1       	ldi	r31, 0x1F	; 31
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 36       	cpi	r26, 0x6A	; 106
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	aa e6       	ldi	r26, 0x6A	; 106
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 31       	cpi	r26, 0x13	; 19
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <main>
      8a:	0c 94 9f 0f 	jmp	0x1f3e	; 0x1f3e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <do_task>:
		green_side[i]=0;
	}
}
void do_task()
{	
	if(task==1)//red
      92:	80 91 75 00 	lds	r24, 0x0075
      96:	81 30       	cpi	r24, 0x01	; 1
      98:	09 f5       	brne	.+66     	; 0xdc <do_task+0x4a>
      9a:	87 e9       	ldi	r24, 0x97	; 151
      9c:	90 e0       	ldi	r25, 0x00	; 0
	{	
		for(int i=0;i<=150;i++)   //back
		{
			PORTB=PORTB|0x20;//0010 0000 pb5
      9e:	c5 9a       	sbi	0x18, 5	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      a0:	e9 e9       	ldi	r30, 0x99	; 153
      a2:	f3 e0       	ldi	r31, 0x03	; 3
      a4:	31 97       	sbiw	r30, 0x01	; 1
      a6:	f1 f7       	brne	.-4      	; 0xa4 <do_task+0x12>
      a8:	00 c0       	rjmp	.+0      	; 0xaa <do_task+0x18>
			_delay_ms(0.5);
			PORTB=PORTB & 0xDF;//1101 1111
      aa:	c5 98       	cbi	0x18, 5	; 24
      ac:	e6 e6       	ldi	r30, 0x66	; 102
      ae:	fc e8       	ldi	r31, 0x8C	; 140
      b0:	31 97       	sbiw	r30, 0x01	; 1
      b2:	f1 f7       	brne	.-4      	; 0xb0 <do_task+0x1e>
      b4:	00 00       	nop
      b6:	01 97       	sbiw	r24, 0x01	; 1
}
void do_task()
{	
	if(task==1)//red
	{	
		for(int i=0;i<=150;i++)   //back
      b8:	91 f7       	brne	.-28     	; 0x9e <do_task+0xc>
      ba:	87 e9       	ldi	r24, 0x97	; 151
      bc:	90 e0       	ldi	r25, 0x00	; 0
		}


		for(int i=0;i<=150;i++)  //front
		{
			PORTB=PORTB|0x20;//0010 0000 pb5
      be:	c5 9a       	sbi	0x18, 5	; 24
      c0:	ee e1       	ldi	r30, 0x1E	; 30
      c2:	f6 e0       	ldi	r31, 0x06	; 6
      c4:	31 97       	sbiw	r30, 0x01	; 1
      c6:	f1 f7       	brne	.-4      	; 0xc4 <do_task+0x32>
      c8:	00 c0       	rjmp	.+0      	; 0xca <do_task+0x38>
			_delay_ms(0.85);
			PORTB=PORTB & 0xDF;//1101 1111
      ca:	c5 98       	cbi	0x18, 5	; 24
      cc:	e1 ee       	ldi	r30, 0xE1	; 225
      ce:	f9 e8       	ldi	r31, 0x89	; 137
      d0:	31 97       	sbiw	r30, 0x01	; 1
      d2:	f1 f7       	brne	.-4      	; 0xd0 <do_task+0x3e>
      d4:	00 00       	nop
      d6:	01 97       	sbiw	r24, 0x01	; 1
			_delay_ms(19.5);
			
		}


		for(int i=0;i<=150;i++)  //front
      d8:	91 f7       	brne	.-28     	; 0xbe <do_task+0x2c>
      da:	1f c0       	rjmp	.+62     	; 0x11a <do_task+0x88>
			
		}
		
		
	}
	else if(task==2)//green
      dc:	82 30       	cpi	r24, 0x02	; 2
      de:	e9 f4       	brne	.+58     	; 0x11a <do_task+0x88>
	{
		green_nodes[gn]=path1.path[t];
      e0:	90 91 62 00 	lds	r25, 0x0062
      e4:	80 91 76 00 	lds	r24, 0x0076
      e8:	e8 ec       	ldi	r30, 0xC8	; 200
      ea:	f0 e0       	ldi	r31, 0x00	; 0
      ec:	e8 0f       	add	r30, r24
      ee:	f1 1d       	adc	r31, r1
      f0:	80 81       	ld	r24, Z
      f2:	e2 e8       	ldi	r30, 0x82	; 130
      f4:	f0 e0       	ldi	r31, 0x00	; 0
      f6:	e9 0f       	add	r30, r25
      f8:	f1 1d       	adc	r31, r1
      fa:	80 83       	st	Z, r24
		green_side[gs]=side;
      fc:	80 91 61 00 	lds	r24, 0x0061
     100:	20 91 74 00 	lds	r18, 0x0074
     104:	e0 ea       	ldi	r30, 0xA0	; 160
     106:	f0 e0       	ldi	r31, 0x00	; 0
     108:	e8 0f       	add	r30, r24
     10a:	f1 1d       	adc	r31, r1
     10c:	20 83       	st	Z, r18
		gn++;
     10e:	9f 5f       	subi	r25, 0xFF	; 255
     110:	90 93 62 00 	sts	0x0062, r25
		gs++;
     114:	8f 5f       	subi	r24, 0xFF	; 255
     116:	80 93 61 00 	sts	0x0061, r24
		
	}
	if(task==3)
     11a:	80 91 75 00 	lds	r24, 0x0075
     11e:	83 30       	cpi	r24, 0x03	; 3
     120:	e9 f4       	brne	.+58     	; 0x15c <do_task+0xca>
	{
		blue_nodes[b]=path1.path[t];
     122:	90 91 64 00 	lds	r25, 0x0064
     126:	80 91 76 00 	lds	r24, 0x0076
     12a:	e8 ec       	ldi	r30, 0xC8	; 200
     12c:	f0 e0       	ldi	r31, 0x00	; 0
     12e:	e8 0f       	add	r30, r24
     130:	f1 1d       	adc	r31, r1
     132:	80 81       	ld	r24, Z
     134:	ee e8       	ldi	r30, 0x8E	; 142
     136:	f0 e0       	ldi	r31, 0x00	; 0
     138:	e9 0f       	add	r30, r25
     13a:	f1 1d       	adc	r31, r1
     13c:	80 83       	st	Z, r24
		blue_side[bs]=side;
     13e:	80 91 63 00 	lds	r24, 0x0063
     142:	20 91 74 00 	lds	r18, 0x0074
     146:	ec ea       	ldi	r30, 0xAC	; 172
     148:	f0 e0       	ldi	r31, 0x00	; 0
     14a:	e8 0f       	add	r30, r24
     14c:	f1 1d       	adc	r31, r1
     14e:	20 83       	st	Z, r18
		b++;
     150:	9f 5f       	subi	r25, 0xFF	; 255
     152:	90 93 64 00 	sts	0x0064, r25
		bs++;
     156:	8f 5f       	subi	r24, 0xFF	; 255
     158:	80 93 63 00 	sts	0x0063, r24
	}
	if(red_side[0]==1 && red_side[1]==1)
	{
		buzzer_beep();
	}*/
	task=0;
     15c:	10 92 75 00 	sts	0x0075, r1
	side=0;
     160:	10 92 74 00 	sts	0x0074, r1
	PORTC=PORTC& 0x8F;
     164:	85 b3       	in	r24, 0x15	; 21
     166:	8f 78       	andi	r24, 0x8F	; 143
     168:	85 bb       	out	0x15, r24	; 21
	//buzzer_beep();
}
     16a:	08 95       	ret

0000016c <buzzer_pin_config>:
#include <util/delay.h>

//Function to initialize Buzzer 
void buzzer_pin_config (void)
{
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     16c:	a3 9a       	sbi	0x14, 3	; 20
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     16e:	ab 98       	cbi	0x15, 3	; 21
}
     170:	08 95       	ret

00000172 <port_init_buzzer>:

void port_init_buzzer (void)
{
 buzzer_pin_config();
     172:	0e 94 b6 00 	call	0x16c	; 0x16c <buzzer_pin_config>
}
     176:	08 95       	ret

00000178 <buzzer_on>:

void buzzer_on (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     178:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore | 0x08;
     17a:	88 60       	ori	r24, 0x08	; 8
 PORTC = port_restore;
     17c:	85 bb       	out	0x15, r24	; 21
}
     17e:	08 95       	ret

00000180 <buzzer_off>:

void buzzer_off (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     180:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore & 0xF7;
     182:	87 7f       	andi	r24, 0xF7	; 247
 PORTC = port_restore;
     184:	85 bb       	out	0x15, r24	; 21
}
     186:	08 95       	ret

00000188 <buzzer_beep>:
void buzzer_beep()
{
	buzzer_on();
     188:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
     18c:	8f ef       	ldi	r24, 0xFF	; 255
     18e:	9f e7       	ldi	r25, 0x7F	; 127
     190:	a4 e0       	ldi	r26, 0x04	; 4
     192:	81 50       	subi	r24, 0x01	; 1
     194:	90 40       	sbci	r25, 0x00	; 0
     196:	a0 40       	sbci	r26, 0x00	; 0
     198:	e1 f7       	brne	.-8      	; 0x192 <buzzer_beep+0xa>
     19a:	00 c0       	rjmp	.+0      	; 0x19c <buzzer_beep+0x14>
     19c:	00 00       	nop
	_delay_ms(200);
	buzzer_off();
     19e:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
     1a2:	8f ef       	ldi	r24, 0xFF	; 255
     1a4:	9f e7       	ldi	r25, 0x7F	; 127
     1a6:	a4 e0       	ldi	r26, 0x04	; 4
     1a8:	81 50       	subi	r24, 0x01	; 1
     1aa:	90 40       	sbci	r25, 0x00	; 0
     1ac:	a0 40       	sbci	r26, 0x00	; 0
     1ae:	e1 f7       	brne	.-8      	; 0x1a8 <buzzer_beep+0x20>
     1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <buzzer_beep+0x2a>
     1b2:	00 00       	nop
	_delay_ms(200);
}
     1b4:	08 95       	ret

000001b6 <init_devices_buzzer>:
void init_devices_buzzer (void)
{
 cli(); 			//Clears the global interrupts
     1b6:	f8 94       	cli
 port_init_buzzer();
     1b8:	0e 94 b9 00 	call	0x172	; 0x172 <port_init_buzzer>
 sei(); 			//Enables the global interrupts
     1bc:	78 94       	sei
}
     1be:	08 95       	ret

000001c0 <main_function7>:




struct Path_Array main_function7(unsigned char start, unsigned char finish)
{
     1c0:	cf 92       	push	r12
     1c2:	df 92       	push	r13
     1c4:	ef 92       	push	r14
     1c6:	ff 92       	push	r15
     1c8:	0f 93       	push	r16
     1ca:	1f 93       	push	r17
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	cd b7       	in	r28, 0x3d	; 61
     1d2:	de b7       	in	r29, 0x3e	; 62
     1d4:	2f 97       	sbiw	r28, 0x0f	; 15
     1d6:	0f b6       	in	r0, 0x3f	; 63
     1d8:	f8 94       	cli
     1da:	de bf       	out	0x3e, r29	; 62
     1dc:	0f be       	out	0x3f, r0	; 63
     1de:	cd bf       	out	0x3d, r28	; 61
     1e0:	08 2f       	mov	r16, r24
     1e2:	f9 2e       	mov	r15, r25
     1e4:	26 2f       	mov	r18, r22
	struct Path_Array path;
unsigned char friend; 
signed char k =(((start-1)/7)-((finish-1)/7));
     1e6:	c4 2e       	mov	r12, r20
     1e8:	dd 24       	eor	r13, r13
     1ea:	86 2f       	mov	r24, r22
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	01 97       	sbiw	r24, 0x01	; 1
     1f0:	e7 e0       	ldi	r30, 0x07	; 7
     1f2:	f0 e0       	ldi	r31, 0x00	; 0
     1f4:	bf 01       	movw	r22, r30
     1f6:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <__divmodhi4>
     1fa:	36 2f       	mov	r19, r22
     1fc:	c6 01       	movw	r24, r12
     1fe:	01 97       	sbiw	r24, 0x01	; 1
     200:	bf 01       	movw	r22, r30
     202:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <__divmodhi4>
     206:	36 1b       	sub	r19, r22
     208:	53 2f       	mov	r21, r19
if(k>0)
     20a:	13 16       	cp	r1, r19
     20c:	3c f4       	brge	.+14     	; 0x21c <main_function7+0x5c>
{
	friend=((k*7)+finish);
     20e:	13 2f       	mov	r17, r19
     210:	11 0f       	add	r17, r17
     212:	11 0f       	add	r17, r17
     214:	11 0f       	add	r17, r17
     216:	13 1b       	sub	r17, r19
     218:	14 0f       	add	r17, r20
     21a:	06 c0       	rjmp	.+12     	; 0x228 <main_function7+0x68>
}
else
{
	friend=(finish-(k*(-1))*7);
     21c:	13 2f       	mov	r17, r19
     21e:	11 0f       	add	r17, r17
     220:	11 0f       	add	r17, r17
     222:	11 0f       	add	r17, r17
     224:	13 1b       	sub	r17, r19
     226:	14 0f       	add	r17, r20
}
signed char l=0;
unsigned char m=0;
 unsigned char st =start;
l=(friend - start);
     228:	31 2f       	mov	r19, r17
     22a:	32 1b       	sub	r19, r18
     22c:	e3 2e       	mov	r14, r19

if(l>0)
     22e:	13 16       	cp	r1, r19
     230:	0c f0       	brlt	.+2      	; 0x234 <main_function7+0x74>
     232:	ad c0       	rjmp	.+346    	; 0x38e <main_function7+0x1ce>
{
	for(unsigned char i = 0;i<=l;i++)
     234:	e3 2f       	mov	r30, r19
     236:	ff 27       	eor	r31, r31
     238:	e7 fd       	sbrc	r30, 7
     23a:	f0 95       	com	r31
     23c:	ff 23       	and	r31, r31
     23e:	9c f0       	brlt	.+38     	; 0x266 <main_function7+0xa6>
     240:	80 e0       	ldi	r24, 0x00	; 0
     242:	90 e0       	ldi	r25, 0x00	; 0
     244:	60 e0       	ldi	r22, 0x00	; 0
	{path.path[i]=st;
     246:	a1 e0       	ldi	r26, 0x01	; 1
     248:	b0 e0       	ldi	r27, 0x00	; 0
     24a:	ac 0f       	add	r26, r28
     24c:	bd 1f       	adc	r27, r29
     24e:	8a 0f       	add	r24, r26
     250:	9b 1f       	adc	r25, r27
     252:	76 2f       	mov	r23, r22
     254:	72 0f       	add	r23, r18
     256:	dc 01       	movw	r26, r24
     258:	7c 93       	st	X, r23
 unsigned char st =start;
l=(friend - start);

if(l>0)
{
	for(unsigned char i = 0;i<=l;i++)
     25a:	6f 5f       	subi	r22, 0xFF	; 255
     25c:	86 2f       	mov	r24, r22
     25e:	90 e0       	ldi	r25, 0x00	; 0
     260:	e8 17       	cp	r30, r24
     262:	f9 07       	cpc	r31, r25
     264:	84 f7       	brge	.-32     	; 0x246 <main_function7+0x86>
	{path.path[i]=st;
	st++;
	}
	if(k>0)	
     266:	15 16       	cp	r1, r21
     268:	0c f0       	brlt	.+2      	; 0x26c <main_function7+0xac>
     26a:	47 c0       	rjmp	.+142    	; 0x2fa <main_function7+0x13a>
	{   
		if(friend > finish)
     26c:	41 17       	cp	r20, r17
     26e:	18 f5       	brcc	.+70     	; 0x2b6 <main_function7+0xf6>
		{
			m=((friend-finish)/7);
     270:	81 2f       	mov	r24, r17
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	8c 19       	sub	r24, r12
     276:	9d 09       	sbc	r25, r13
     278:	67 e0       	ldi	r22, 0x07	; 7
     27a:	70 e0       	ldi	r23, 0x00	; 0
     27c:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     280:	66 23       	and	r22, r22
     282:	09 f4       	brne	.+2      	; 0x286 <main_function7+0xc6>
     284:	34 c1       	rjmp	.+616    	; 0x4ee <__stack+0x8f>
     286:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     288:	ec 0f       	add	r30, r28
     28a:	fd 1f       	adc	r31, r29
     28c:	32 96       	adiw	r30, 0x02	; 2
     28e:	83 2f       	mov	r24, r19
     290:	99 27       	eor	r25, r25
     292:	87 fd       	sbrc	r24, 7
     294:	90 95       	com	r25
     296:	23 e0       	ldi	r18, 0x03	; 3
     298:	30 e0       	ldi	r19, 0x00	; 0
     29a:	2c 0f       	add	r18, r28
     29c:	3d 1f       	adc	r19, r29
     29e:	82 0f       	add	r24, r18
     2a0:	93 1f       	adc	r25, r19
     2a2:	26 2f       	mov	r18, r22
     2a4:	21 50       	subi	r18, 0x01	; 1
     2a6:	82 0f       	add	r24, r18
     2a8:	91 1d       	adc	r25, r1
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     2aa:	11 93       	st	Z+, r17
     2ac:	17 50       	subi	r17, 0x07	; 7
	if(k>0)	
	{   
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     2ae:	e8 17       	cp	r30, r24
     2b0:	f9 07       	cpc	r31, r25
     2b2:	d9 f7       	brne	.-10     	; 0x2aa <main_function7+0xea>
     2b4:	1c c1       	rjmp	.+568    	; 0x4ee <__stack+0x8f>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     2b6:	c6 01       	movw	r24, r12
     2b8:	81 1b       	sub	r24, r17
     2ba:	91 09       	sbc	r25, r1
     2bc:	67 e0       	ldi	r22, 0x07	; 7
     2be:	70 e0       	ldi	r23, 0x00	; 0
     2c0:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     2c4:	66 23       	and	r22, r22
     2c6:	09 f4       	brne	.+2      	; 0x2ca <main_function7+0x10a>
     2c8:	12 c1       	rjmp	.+548    	; 0x4ee <__stack+0x8f>
     2ca:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     2cc:	ec 0f       	add	r30, r28
     2ce:	fd 1f       	adc	r31, r29
     2d0:	32 96       	adiw	r30, 0x02	; 2
     2d2:	83 2f       	mov	r24, r19
     2d4:	99 27       	eor	r25, r25
     2d6:	87 fd       	sbrc	r24, 7
     2d8:	90 95       	com	r25
     2da:	a3 e0       	ldi	r26, 0x03	; 3
     2dc:	b0 e0       	ldi	r27, 0x00	; 0
     2de:	ac 0f       	add	r26, r28
     2e0:	bd 1f       	adc	r27, r29
     2e2:	8a 0f       	add	r24, r26
     2e4:	9b 1f       	adc	r25, r27
     2e6:	26 2f       	mov	r18, r22
     2e8:	21 50       	subi	r18, 0x01	; 1
     2ea:	82 0f       	add	r24, r18
     2ec:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     2ee:	11 93       	st	Z+, r17
     2f0:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     2f2:	e8 17       	cp	r30, r24
     2f4:	f9 07       	cpc	r31, r25
     2f6:	d9 f7       	brne	.-10     	; 0x2ee <main_function7+0x12e>
     2f8:	fa c0       	rjmp	.+500    	; 0x4ee <__stack+0x8f>
				path.path[l+i+1]=friend+((7*i)+7);
			}
		}
		
	}
	else if(k<0)
     2fa:	55 23       	and	r21, r21
     2fc:	0c f0       	brlt	.+2      	; 0x300 <main_function7+0x140>
     2fe:	f4 c0       	rjmp	.+488    	; 0x4e8 <__stack+0x89>
	{ if(friend > finish)
     300:	41 17       	cp	r20, r17
     302:	18 f5       	brcc	.+70     	; 0x34a <main_function7+0x18a>
		{	
			m=((friend-finish)/7);
     304:	81 2f       	mov	r24, r17
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	8c 19       	sub	r24, r12
     30a:	9d 09       	sbc	r25, r13
     30c:	67 e0       	ldi	r22, 0x07	; 7
     30e:	70 e0       	ldi	r23, 0x00	; 0
     310:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     314:	66 23       	and	r22, r22
     316:	09 f4       	brne	.+2      	; 0x31a <main_function7+0x15a>
     318:	ea c0       	rjmp	.+468    	; 0x4ee <__stack+0x8f>
     31a:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     31c:	ec 0f       	add	r30, r28
     31e:	fd 1f       	adc	r31, r29
     320:	32 96       	adiw	r30, 0x02	; 2
     322:	83 2f       	mov	r24, r19
     324:	99 27       	eor	r25, r25
     326:	87 fd       	sbrc	r24, 7
     328:	90 95       	com	r25
     32a:	23 e0       	ldi	r18, 0x03	; 3
     32c:	30 e0       	ldi	r19, 0x00	; 0
     32e:	2c 0f       	add	r18, r28
     330:	3d 1f       	adc	r19, r29
     332:	82 0f       	add	r24, r18
     334:	93 1f       	adc	r25, r19
     336:	26 2f       	mov	r18, r22
     338:	21 50       	subi	r18, 0x01	; 1
     33a:	82 0f       	add	r24, r18
     33c:	91 1d       	adc	r25, r1
	{ if(friend > finish)
		{	
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     33e:	11 93       	st	Z+, r17
     340:	17 50       	subi	r17, 0x07	; 7
	}
	else if(k<0)
	{ if(friend > finish)
		{	
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     342:	e8 17       	cp	r30, r24
     344:	f9 07       	cpc	r31, r25
     346:	d9 f7       	brne	.-10     	; 0x33e <main_function7+0x17e>
     348:	d2 c0       	rjmp	.+420    	; 0x4ee <__stack+0x8f>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     34a:	c6 01       	movw	r24, r12
     34c:	81 1b       	sub	r24, r17
     34e:	91 09       	sbc	r25, r1
     350:	67 e0       	ldi	r22, 0x07	; 7
     352:	70 e0       	ldi	r23, 0x00	; 0
     354:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     358:	66 23       	and	r22, r22
     35a:	09 f4       	brne	.+2      	; 0x35e <main_function7+0x19e>
     35c:	c8 c0       	rjmp	.+400    	; 0x4ee <__stack+0x8f>
     35e:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     360:	ec 0f       	add	r30, r28
     362:	fd 1f       	adc	r31, r29
     364:	32 96       	adiw	r30, 0x02	; 2
     366:	83 2f       	mov	r24, r19
     368:	99 27       	eor	r25, r25
     36a:	87 fd       	sbrc	r24, 7
     36c:	90 95       	com	r25
     36e:	a3 e0       	ldi	r26, 0x03	; 3
     370:	b0 e0       	ldi	r27, 0x00	; 0
     372:	ac 0f       	add	r26, r28
     374:	bd 1f       	adc	r27, r29
     376:	8a 0f       	add	r24, r26
     378:	9b 1f       	adc	r25, r27
     37a:	26 2f       	mov	r18, r22
     37c:	21 50       	subi	r18, 0x01	; 1
     37e:	82 0f       	add	r24, r18
     380:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     382:	11 93       	st	Z+, r17
     384:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     386:	e8 17       	cp	r30, r24
     388:	f9 07       	cpc	r31, r25
     38a:	d9 f7       	brne	.-10     	; 0x382 <main_function7+0x1c2>
     38c:	b0 c0       	rjmp	.+352    	; 0x4ee <__stack+0x8f>
		
	}
	
}
else
{ l=(l*(-1));
     38e:	e3 2e       	mov	r14, r19
     390:	e1 94       	neg	r14
	for(unsigned char i = 0;i<=(l);i++)
     392:	ee 2d       	mov	r30, r14
     394:	ff 27       	eor	r31, r31
     396:	e7 fd       	sbrc	r30, 7
     398:	f0 95       	com	r31
     39a:	ff 23       	and	r31, r31
     39c:	9c f0       	brlt	.+38     	; 0x3c4 <main_function7+0x204>
     39e:	80 e0       	ldi	r24, 0x00	; 0
     3a0:	90 e0       	ldi	r25, 0x00	; 0
     3a2:	30 e0       	ldi	r19, 0x00	; 0
	{path.path[i]=st;
     3a4:	61 e0       	ldi	r22, 0x01	; 1
     3a6:	70 e0       	ldi	r23, 0x00	; 0
     3a8:	6c 0f       	add	r22, r28
     3aa:	7d 1f       	adc	r23, r29
     3ac:	86 0f       	add	r24, r22
     3ae:	97 1f       	adc	r25, r23
     3b0:	62 2f       	mov	r22, r18
     3b2:	63 1b       	sub	r22, r19
     3b4:	dc 01       	movw	r26, r24
     3b6:	6c 93       	st	X, r22
	}
	
}
else
{ l=(l*(-1));
	for(unsigned char i = 0;i<=(l);i++)
     3b8:	3f 5f       	subi	r19, 0xFF	; 255
     3ba:	83 2f       	mov	r24, r19
     3bc:	90 e0       	ldi	r25, 0x00	; 0
     3be:	e8 17       	cp	r30, r24
     3c0:	f9 07       	cpc	r31, r25
     3c2:	84 f7       	brge	.-32     	; 0x3a4 <main_function7+0x1e4>
	{path.path[i]=st;
		st--;
	}
	if(k>0)
     3c4:	15 16       	cp	r1, r21
     3c6:	0c f0       	brlt	.+2      	; 0x3ca <main_function7+0x20a>
     3c8:	47 c0       	rjmp	.+142    	; 0x458 <main_function7+0x298>
	{  
		if(friend > finish)
     3ca:	41 17       	cp	r20, r17
     3cc:	18 f5       	brcc	.+70     	; 0x414 <main_function7+0x254>
		{
			m=((friend-finish)/7);
     3ce:	81 2f       	mov	r24, r17
     3d0:	90 e0       	ldi	r25, 0x00	; 0
     3d2:	8c 19       	sub	r24, r12
     3d4:	9d 09       	sbc	r25, r13
     3d6:	67 e0       	ldi	r22, 0x07	; 7
     3d8:	70 e0       	ldi	r23, 0x00	; 0
     3da:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     3de:	66 23       	and	r22, r22
     3e0:	09 f4       	brne	.+2      	; 0x3e4 <main_function7+0x224>
     3e2:	85 c0       	rjmp	.+266    	; 0x4ee <__stack+0x8f>
     3e4:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     3e6:	ec 0f       	add	r30, r28
     3e8:	fd 1f       	adc	r31, r29
     3ea:	32 96       	adiw	r30, 0x02	; 2
     3ec:	8e 2d       	mov	r24, r14
     3ee:	99 27       	eor	r25, r25
     3f0:	87 fd       	sbrc	r24, 7
     3f2:	90 95       	com	r25
     3f4:	23 e0       	ldi	r18, 0x03	; 3
     3f6:	30 e0       	ldi	r19, 0x00	; 0
     3f8:	2c 0f       	add	r18, r28
     3fa:	3d 1f       	adc	r19, r29
     3fc:	82 0f       	add	r24, r18
     3fe:	93 1f       	adc	r25, r19
     400:	26 2f       	mov	r18, r22
     402:	21 50       	subi	r18, 0x01	; 1
     404:	82 0f       	add	r24, r18
     406:	91 1d       	adc	r25, r1
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     408:	11 93       	st	Z+, r17
     40a:	17 50       	subi	r17, 0x07	; 7
	if(k>0)
	{  
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     40c:	e8 17       	cp	r30, r24
     40e:	f9 07       	cpc	r31, r25
     410:	d9 f7       	brne	.-10     	; 0x408 <main_function7+0x248>
     412:	6d c0       	rjmp	.+218    	; 0x4ee <__stack+0x8f>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     414:	c6 01       	movw	r24, r12
     416:	81 1b       	sub	r24, r17
     418:	91 09       	sbc	r25, r1
     41a:	67 e0       	ldi	r22, 0x07	; 7
     41c:	70 e0       	ldi	r23, 0x00	; 0
     41e:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     422:	66 23       	and	r22, r22
     424:	09 f4       	brne	.+2      	; 0x428 <main_function7+0x268>
     426:	63 c0       	rjmp	.+198    	; 0x4ee <__stack+0x8f>
     428:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     42a:	ec 0f       	add	r30, r28
     42c:	fd 1f       	adc	r31, r29
     42e:	32 96       	adiw	r30, 0x02	; 2
     430:	8e 2d       	mov	r24, r14
     432:	99 27       	eor	r25, r25
     434:	87 fd       	sbrc	r24, 7
     436:	90 95       	com	r25
     438:	a3 e0       	ldi	r26, 0x03	; 3
     43a:	b0 e0       	ldi	r27, 0x00	; 0
     43c:	ac 0f       	add	r26, r28
     43e:	bd 1f       	adc	r27, r29
     440:	8a 0f       	add	r24, r26
     442:	9b 1f       	adc	r25, r27
     444:	26 2f       	mov	r18, r22
     446:	21 50       	subi	r18, 0x01	; 1
     448:	82 0f       	add	r24, r18
     44a:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     44c:	11 93       	st	Z+, r17
     44e:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     450:	e8 17       	cp	r30, r24
     452:	f9 07       	cpc	r31, r25
     454:	d9 f7       	brne	.-10     	; 0x44c <main_function7+0x28c>
     456:	4b c0       	rjmp	.+150    	; 0x4ee <__stack+0x8f>
			{
				path.path[l+i+1]=friend+((7*i)+7);
			}
		}
	}
	else  if(k<0)
     458:	55 23       	and	r21, r21
     45a:	0c f0       	brlt	.+2      	; 0x45e <main_function7+0x29e>
     45c:	47 c0       	rjmp	.+142    	; 0x4ec <__stack+0x8d>
	{
		if(friend > finish)
     45e:	41 17       	cp	r20, r17
     460:	10 f5       	brcc	.+68     	; 0x4a6 <__stack+0x47>
		{
			m=((friend-finish)/7);
     462:	81 2f       	mov	r24, r17
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	8c 19       	sub	r24, r12
     468:	9d 09       	sbc	r25, r13
     46a:	67 e0       	ldi	r22, 0x07	; 7
     46c:	70 e0       	ldi	r23, 0x00	; 0
     46e:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     472:	66 23       	and	r22, r22
     474:	e1 f1       	breq	.+120    	; 0x4ee <__stack+0x8f>
     476:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     478:	ec 0f       	add	r30, r28
     47a:	fd 1f       	adc	r31, r29
     47c:	32 96       	adiw	r30, 0x02	; 2
     47e:	8e 2d       	mov	r24, r14
     480:	99 27       	eor	r25, r25
     482:	87 fd       	sbrc	r24, 7
     484:	90 95       	com	r25
     486:	23 e0       	ldi	r18, 0x03	; 3
     488:	30 e0       	ldi	r19, 0x00	; 0
     48a:	2c 0f       	add	r18, r28
     48c:	3d 1f       	adc	r19, r29
     48e:	82 0f       	add	r24, r18
     490:	93 1f       	adc	r25, r19
     492:	26 2f       	mov	r18, r22
     494:	21 50       	subi	r18, 0x01	; 1
     496:	82 0f       	add	r24, r18
     498:	91 1d       	adc	r25, r1
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     49a:	11 93       	st	Z+, r17
     49c:	17 50       	subi	r17, 0x07	; 7
	else  if(k<0)
	{
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     49e:	e8 17       	cp	r30, r24
     4a0:	f9 07       	cpc	r31, r25
     4a2:	d9 f7       	brne	.-10     	; 0x49a <__stack+0x3b>
     4a4:	24 c0       	rjmp	.+72     	; 0x4ee <__stack+0x8f>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     4a6:	c6 01       	movw	r24, r12
     4a8:	81 1b       	sub	r24, r17
     4aa:	91 09       	sbc	r25, r1
     4ac:	67 e0       	ldi	r22, 0x07	; 7
     4ae:	70 e0       	ldi	r23, 0x00	; 0
     4b0:	0e 94 78 0f 	call	0x1ef0	; 0x1ef0 <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     4b4:	66 23       	and	r22, r22
     4b6:	d9 f0       	breq	.+54     	; 0x4ee <__stack+0x8f>
     4b8:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     4ba:	ec 0f       	add	r30, r28
     4bc:	fd 1f       	adc	r31, r29
     4be:	32 96       	adiw	r30, 0x02	; 2
     4c0:	8e 2d       	mov	r24, r14
     4c2:	99 27       	eor	r25, r25
     4c4:	87 fd       	sbrc	r24, 7
     4c6:	90 95       	com	r25
     4c8:	a3 e0       	ldi	r26, 0x03	; 3
     4ca:	b0 e0       	ldi	r27, 0x00	; 0
     4cc:	ac 0f       	add	r26, r28
     4ce:	bd 1f       	adc	r27, r29
     4d0:	8a 0f       	add	r24, r26
     4d2:	9b 1f       	adc	r25, r27
     4d4:	26 2f       	mov	r18, r22
     4d6:	21 50       	subi	r18, 0x01	; 1
     4d8:	82 0f       	add	r24, r18
     4da:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     4dc:	11 93       	st	Z+, r17
     4de:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     4e0:	e8 17       	cp	r30, r24
     4e2:	f9 07       	cpc	r31, r25
     4e4:	d9 f7       	brne	.-10     	; 0x4dc <__stack+0x7d>
     4e6:	03 c0       	rjmp	.+6      	; 0x4ee <__stack+0x8f>
else
{
	friend=(finish-(k*(-1))*7);
}
signed char l=0;
unsigned char m=0;
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	01 c0       	rjmp	.+2      	; 0x4ee <__stack+0x8f>
     4ec:	60 e0       	ldi	r22, 0x00	; 0
		}
		
	}
	
}
 max = l+m;
     4ee:	6e 0d       	add	r22, r14
     4f0:	60 93 80 00 	sts	0x0080, r22
 for(unsigned char i=(l+m+1);i<15;i++)
     4f4:	6f 5f       	subi	r22, 0xFF	; 255
     4f6:	6f 30       	cpi	r22, 0x0F	; 15
     4f8:	50 f4       	brcc	.+20     	; 0x50e <__stack+0xaf>
 {
	 path.path[i]=0;
     4fa:	e1 e0       	ldi	r30, 0x01	; 1
     4fc:	f0 e0       	ldi	r31, 0x00	; 0
     4fe:	ec 0f       	add	r30, r28
     500:	fd 1f       	adc	r31, r29
     502:	e6 0f       	add	r30, r22
     504:	f1 1d       	adc	r31, r1
     506:	10 82       	st	Z, r1
		
	}
	
}
 max = l+m;
 for(unsigned char i=(l+m+1);i<15;i++)
     508:	6f 5f       	subi	r22, 0xFF	; 255
     50a:	6f 30       	cpi	r22, 0x0F	; 15
     50c:	b1 f7       	brne	.-20     	; 0x4fa <__stack+0x9b>
 {
	 path.path[i]=0;
 }

	
	return path;
     50e:	e0 2f       	mov	r30, r16
     510:	ff 2d       	mov	r31, r15
     512:	de 01       	movw	r26, r28
     514:	11 96       	adiw	r26, 0x01	; 1
     516:	8f e0       	ldi	r24, 0x0F	; 15
     518:	0d 90       	ld	r0, X+
     51a:	01 92       	st	Z+, r0
     51c:	81 50       	subi	r24, 0x01	; 1
     51e:	e1 f7       	brne	.-8      	; 0x518 <__stack+0xb9>
}
     520:	80 2f       	mov	r24, r16
     522:	9f 2d       	mov	r25, r15
     524:	2f 96       	adiw	r28, 0x0f	; 15
     526:	0f b6       	in	r0, 0x3f	; 63
     528:	f8 94       	cli
     52a:	de bf       	out	0x3e, r29	; 62
     52c:	0f be       	out	0x3f, r0	; 63
     52e:	cd bf       	out	0x3d, r28	; 61
     530:	df 91       	pop	r29
     532:	cf 91       	pop	r28
     534:	1f 91       	pop	r17
     536:	0f 91       	pop	r16
     538:	ff 90       	pop	r15
     53a:	ef 90       	pop	r14
     53c:	df 90       	pop	r13
     53e:	cf 90       	pop	r12
     540:	08 95       	ret

00000542 <motion_pin_config_pos>:
volatile unsigned int Degrees; //to accept angle in degrees for turning

//Function to configure ports to enable robot's motion
void motion_pin_config_pos (void) 
{
 DDRB = DDRB | 0x0F;   //set direction of the PORTB3 to PORTB0 pins as output
     542:	87 b3       	in	r24, 0x17	; 23
     544:	8f 60       	ori	r24, 0x0F	; 15
     546:	87 bb       	out	0x17, r24	; 23
 PORTB = PORTB & 0xF0; // set initial value of the PORTB3 to PORTB0 pins to logic 0
     548:	88 b3       	in	r24, 0x18	; 24
     54a:	80 7f       	andi	r24, 0xF0	; 240
     54c:	88 bb       	out	0x18, r24	; 24
 DDRD = DDRD | 0x30;   //Setting PD4 and PD5 pins as output for PWM generation
     54e:	81 b3       	in	r24, 0x11	; 17
     550:	80 63       	ori	r24, 0x30	; 48
     552:	81 bb       	out	0x11, r24	; 17
 PORTD = PORTD | 0x30; //PD4 and PD5 pins are for velocity control using PWM
     554:	82 b3       	in	r24, 0x12	; 18
     556:	80 63       	ori	r24, 0x30	; 48
     558:	82 bb       	out	0x12, r24	; 18
}
     55a:	08 95       	ret

0000055c <left_encoder_pin_config>:

//Function to configure INT1 (PORTD 3) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xF7;  //Set the direction of the PORTD 3 pin as input
     55c:	8b 98       	cbi	0x11, 3	; 17
 PORTD = PORTD | 0x08; //Enable internal pull-up for PORTD 3 pin
     55e:	93 9a       	sbi	0x12, 3	; 18
}
     560:	08 95       	ret

00000562 <right_encoder_pin_config>:

//Function to configure INT0 (PORTD 2) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xFB;  //Set the direction of the PORTD 2 pin as input
     562:	8a 98       	cbi	0x11, 2	; 17
 PORTD = PORTD | 0x04; //Enable internal pull-up for PORTD 2 pin
     564:	92 9a       	sbi	0x12, 2	; 18
}
     566:	08 95       	ret

00000568 <port_init_pos>:

//Function to initialize ports
void port_init_pos()
{
 motion_pin_config_pos();          //robot motion pins config
     568:	0e 94 a1 02 	call	0x542	; 0x542 <motion_pin_config_pos>
 left_encoder_pin_config();    //left encoder pin config
     56c:	0e 94 ae 02 	call	0x55c	; 0x55c <left_encoder_pin_config>
 right_encoder_pin_config();   //right encoder pin config	
     570:	0e 94 b1 02 	call	0x562	; 0x562 <right_encoder_pin_config>
}
     574:	08 95       	ret

00000576 <left_position_encoder_interrupt_init>:

void left_position_encoder_interrupt_init (void) //Interrupt 1 enable
{
 cli(); //Clears the global interrupt
     576:	f8 94       	cli
 MCUCR = MCUCR | 0x08; // INT1 is set to trigger with falling edge
     578:	85 b7       	in	r24, 0x35	; 53
     57a:	88 60       	ori	r24, 0x08	; 8
     57c:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x80;   // Enable Interrupt INT1 for left position encoder
     57e:	8b b7       	in	r24, 0x3b	; 59
     580:	80 68       	ori	r24, 0x80	; 128
     582:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     584:	78 94       	sei
}
     586:	08 95       	ret

00000588 <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 0 enable
{
 cli(); //Clears the global interrupt
     588:	f8 94       	cli
 MCUCR = MCUCR | 0x02; // INT0 is set to trigger with falling edge
     58a:	85 b7       	in	r24, 0x35	; 53
     58c:	82 60       	ori	r24, 0x02	; 2
     58e:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x40;   // Enable Interrupt INT5 for right position encoder
     590:	8b b7       	in	r24, 0x3b	; 59
     592:	80 64       	ori	r24, 0x40	; 64
     594:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     596:	78 94       	sei
}
     598:	08 95       	ret

0000059a <__vector_1>:

//ISR for right position encoder
ISR(INT0_vect)  
{
     59a:	1f 92       	push	r1
     59c:	0f 92       	push	r0
     59e:	0f b6       	in	r0, 0x3f	; 63
     5a0:	0f 92       	push	r0
     5a2:	11 24       	eor	r1, r1
     5a4:	8f 93       	push	r24
     5a6:	9f 93       	push	r25
     5a8:	af 93       	push	r26
     5aa:	bf 93       	push	r27
 ShaftCountRight++;  //increment right shaft position count
     5ac:	80 91 78 00 	lds	r24, 0x0078
     5b0:	90 91 79 00 	lds	r25, 0x0079
     5b4:	a0 91 7a 00 	lds	r26, 0x007A
     5b8:	b0 91 7b 00 	lds	r27, 0x007B
     5bc:	01 96       	adiw	r24, 0x01	; 1
     5be:	a1 1d       	adc	r26, r1
     5c0:	b1 1d       	adc	r27, r1
     5c2:	80 93 78 00 	sts	0x0078, r24
     5c6:	90 93 79 00 	sts	0x0079, r25
     5ca:	a0 93 7a 00 	sts	0x007A, r26
     5ce:	b0 93 7b 00 	sts	0x007B, r27
}
     5d2:	bf 91       	pop	r27
     5d4:	af 91       	pop	r26
     5d6:	9f 91       	pop	r25
     5d8:	8f 91       	pop	r24
     5da:	0f 90       	pop	r0
     5dc:	0f be       	out	0x3f, r0	; 63
     5de:	0f 90       	pop	r0
     5e0:	1f 90       	pop	r1
     5e2:	18 95       	reti

000005e4 <__vector_2>:

//ISR for left position encoder
ISR(INT1_vect)
{
     5e4:	1f 92       	push	r1
     5e6:	0f 92       	push	r0
     5e8:	0f b6       	in	r0, 0x3f	; 63
     5ea:	0f 92       	push	r0
     5ec:	11 24       	eor	r1, r1
     5ee:	8f 93       	push	r24
     5f0:	9f 93       	push	r25
     5f2:	af 93       	push	r26
     5f4:	bf 93       	push	r27
 ShaftCountLeft++;  //increment left shaft position count
     5f6:	80 91 7c 00 	lds	r24, 0x007C
     5fa:	90 91 7d 00 	lds	r25, 0x007D
     5fe:	a0 91 7e 00 	lds	r26, 0x007E
     602:	b0 91 7f 00 	lds	r27, 0x007F
     606:	01 96       	adiw	r24, 0x01	; 1
     608:	a1 1d       	adc	r26, r1
     60a:	b1 1d       	adc	r27, r1
     60c:	80 93 7c 00 	sts	0x007C, r24
     610:	90 93 7d 00 	sts	0x007D, r25
     614:	a0 93 7e 00 	sts	0x007E, r26
     618:	b0 93 7f 00 	sts	0x007F, r27
}
     61c:	bf 91       	pop	r27
     61e:	af 91       	pop	r26
     620:	9f 91       	pop	r25
     622:	8f 91       	pop	r24
     624:	0f 90       	pop	r0
     626:	0f be       	out	0x3f, r0	; 63
     628:	0f 90       	pop	r0
     62a:	1f 90       	pop	r1
     62c:	18 95       	reti

0000062e <motion_set_pos>:
void motion_set_pos (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortBRestore = PORTB; 		// reading the PORT original status
     62e:	98 b3       	in	r25, 0x18	; 24
 PortBRestore &= 0xF0; 		// making lower direction nibbel to 0
     630:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set_pos (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
     632:	8f 70       	andi	r24, 0x0F	; 15
 PortBRestore = PORTB; 		// reading the PORT original status
 PortBRestore &= 0xF0; 		// making lower direction nibbel to 0
 PortBRestore |= Direction; // adding lower nibbel for forward command and restoring the PORTB status
     634:	98 2b       	or	r25, r24
 PORTB = PortBRestore; 		// executing the command
     636:	98 bb       	out	0x18, r25	; 24
}
     638:	08 95       	ret

0000063a <forward_pos>:

void forward_pos (void) //both wheels forward
{
  motion_set_pos(0x06);
     63a:	86 e0       	ldi	r24, 0x06	; 6
     63c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     640:	08 95       	ret

00000642 <back_pos>:

void back_pos (void) //both wheels backward
{
  motion_set_pos(0x09);
     642:	89 e0       	ldi	r24, 0x09	; 9
     644:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     648:	08 95       	ret

0000064a <left_pos>:

void left_pos (void) //Left wheel backward, Right wheel forward
{
  motion_set_pos(0x05);
     64a:	85 e0       	ldi	r24, 0x05	; 5
     64c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     650:	08 95       	ret

00000652 <right_pos>:

void right_pos (void) //Left wheel forward, Right wheel backward
{
  motion_set_pos(0x0A);
     652:	8a e0       	ldi	r24, 0x0A	; 10
     654:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     658:	08 95       	ret

0000065a <soft_left_pos>:

void soft_left_pos (void) //Left wheel stationary, Right wheel forward
{
 motion_set_pos(0x04);
     65a:	84 e0       	ldi	r24, 0x04	; 4
     65c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     660:	08 95       	ret

00000662 <soft_right_pos>:

void soft_right_pos (void) //Left wheel forward, Right wheel is stationary
{
 motion_set_pos(0x02);
     662:	82 e0       	ldi	r24, 0x02	; 2
     664:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     668:	08 95       	ret

0000066a <soft_left_2_pos>:

void soft_left_2_pos (void) //Left wheel backward, right wheel stationary
{
 motion_set_pos(0x01);
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     670:	08 95       	ret

00000672 <soft_right_2_pos>:

void soft_right_2_pos (void) //Left wheel stationary, Right wheel backward
{
 motion_set_pos(0x08);
     672:	88 e0       	ldi	r24, 0x08	; 8
     674:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     678:	08 95       	ret

0000067a <stop_pos>:

void stop_pos (void)
{
  motion_set_pos(0x00);
     67a:	80 e0       	ldi	r24, 0x00	; 0
     67c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     680:	08 95       	ret

00000682 <angle_rotate>:


//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     682:	0f 93       	push	r16
     684:	1f 93       	push	r17
     686:	cf 93       	push	r28
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = (float) Degrees/ 12.85; // division by resolution to get shaft count 
     688:	bc 01       	movw	r22, r24
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	90 e0       	ldi	r25, 0x00	; 0
     68e:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <__floatunsisf>
     692:	2a e9       	ldi	r18, 0x9A	; 154
     694:	39 e9       	ldi	r19, 0x99	; 153
     696:	4d e4       	ldi	r20, 0x4D	; 77
     698:	51 e4       	ldi	r21, 0x41	; 65
     69a:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__divsf3>
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     69e:	0e 94 be 0e 	call	0x1d7c	; 0x1d7c <__fixunssfsi>
     6a2:	dc 01       	movw	r26, r24
     6a4:	cb 01       	movw	r24, r22
     6a6:	a0 e0       	ldi	r26, 0x00	; 0
     6a8:	b0 e0       	ldi	r27, 0x00	; 0
 ShaftCountRight = 0; 
     6aa:	10 92 78 00 	sts	0x0078, r1
     6ae:	10 92 79 00 	sts	0x0079, r1
     6b2:	10 92 7a 00 	sts	0x007A, r1
     6b6:	10 92 7b 00 	sts	0x007B, r1
 ShaftCountLeft = 0; 
     6ba:	10 92 7c 00 	sts	0x007C, r1
     6be:	10 92 7d 00 	sts	0x007D, r1
     6c2:	10 92 7e 00 	sts	0x007E, r1
     6c6:	10 92 7f 00 	sts	0x007F, r1

 while (1)
 {
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     6ca:	f1 e0       	ldi	r31, 0x01	; 1
     6cc:	c0 e0       	ldi	r28, 0x00	; 0
     6ce:	40 91 78 00 	lds	r20, 0x0078
     6d2:	50 91 79 00 	lds	r21, 0x0079
     6d6:	60 91 7a 00 	lds	r22, 0x007A
     6da:	70 91 7b 00 	lds	r23, 0x007B
     6de:	00 91 7c 00 	lds	r16, 0x007C
     6e2:	10 91 7d 00 	lds	r17, 0x007D
     6e6:	20 91 7e 00 	lds	r18, 0x007E
     6ea:	30 91 7f 00 	lds	r19, 0x007F
     6ee:	ef 2f       	mov	r30, r31
     6f0:	48 17       	cp	r20, r24
     6f2:	59 07       	cpc	r21, r25
     6f4:	6a 07       	cpc	r22, r26
     6f6:	7b 07       	cpc	r23, r27
     6f8:	08 f4       	brcc	.+2      	; 0x6fc <angle_rotate+0x7a>
     6fa:	ec 2f       	mov	r30, r28
     6fc:	ee 23       	and	r30, r30
     6fe:	49 f4       	brne	.+18     	; 0x712 <angle_rotate+0x90>
     700:	4f 2f       	mov	r20, r31
     702:	08 17       	cp	r16, r24
     704:	19 07       	cpc	r17, r25
     706:	2a 07       	cpc	r18, r26
     708:	3b 07       	cpc	r19, r27
     70a:	08 f4       	brcc	.+2      	; 0x70e <angle_rotate+0x8c>
     70c:	4c 2f       	mov	r20, r28
     70e:	44 23       	and	r20, r20
     710:	f1 f2       	breq	.-68     	; 0x6ce <angle_rotate+0x4c>
  break;
 }
 stop_pos(); //Stop robot
     712:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
}
     716:	cf 91       	pop	r28
     718:	1f 91       	pop	r17
     71a:	0f 91       	pop	r16
     71c:	08 95       	ret

0000071e <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = DistanceInMM / 12.92; // division by resolution to get shaft count
     71e:	bc 01       	movw	r22, r24
     720:	80 e0       	ldi	r24, 0x00	; 0
     722:	90 e0       	ldi	r25, 0x00	; 0
     724:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <__floatunsisf>
     728:	22 e5       	ldi	r18, 0x52	; 82
     72a:	38 eb       	ldi	r19, 0xB8	; 184
     72c:	4e e4       	ldi	r20, 0x4E	; 78
     72e:	51 e4       	ldi	r21, 0x41	; 65
     730:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__divsf3>
 ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     734:	0e 94 be 0e 	call	0x1d7c	; 0x1d7c <__fixunssfsi>
     738:	46 2f       	mov	r20, r22
     73a:	57 2f       	mov	r21, r23
     73c:	68 2f       	mov	r22, r24
     73e:	79 2f       	mov	r23, r25
  
 ShaftCountRight = 0;
     740:	10 92 78 00 	sts	0x0078, r1
     744:	10 92 79 00 	sts	0x0079, r1
     748:	10 92 7a 00 	sts	0x007A, r1
     74c:	10 92 7b 00 	sts	0x007B, r1
 while(1)
 {
  if(ShaftCountRight > ReqdShaftCountInt)
     750:	80 91 78 00 	lds	r24, 0x0078
     754:	90 91 79 00 	lds	r25, 0x0079
     758:	a0 91 7a 00 	lds	r26, 0x007A
     75c:	b0 91 7b 00 	lds	r27, 0x007B
     760:	48 17       	cp	r20, r24
     762:	59 07       	cpc	r21, r25
     764:	6a 07       	cpc	r22, r26
     766:	7b 07       	cpc	r23, r27
     768:	98 f7       	brcc	.-26     	; 0x750 <linear_distance_mm+0x32>
  {
  	break;
  }
 } 
 stop_pos(); //Stop robot
     76a:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
}
     76e:	08 95       	ret

00000770 <forward_mm>:

void forward_mm(unsigned int DistanceInMM)
{
     770:	cf 93       	push	r28
     772:	df 93       	push	r29
     774:	ec 01       	movw	r28, r24
 forward_pos();
     776:	0e 94 1d 03 	call	0x63a	; 0x63a <forward_pos>
 linear_distance_mm(DistanceInMM);
     77a:	ce 01       	movw	r24, r28
     77c:	0e 94 8f 03 	call	0x71e	; 0x71e <linear_distance_mm>
}
     780:	df 91       	pop	r29
     782:	cf 91       	pop	r28
     784:	08 95       	ret

00000786 <back_mm>:

void back_mm(unsigned int DistanceInMM)
{
     786:	cf 93       	push	r28
     788:	df 93       	push	r29
     78a:	ec 01       	movw	r28, r24
 back_pos();
     78c:	0e 94 21 03 	call	0x642	; 0x642 <back_pos>
 linear_distance_mm(DistanceInMM);
     790:	ce 01       	movw	r24, r28
     792:	0e 94 8f 03 	call	0x71e	; 0x71e <linear_distance_mm>
}
     796:	df 91       	pop	r29
     798:	cf 91       	pop	r28
     79a:	08 95       	ret

0000079c <left_degrees>:

void left_degrees(unsigned int Degrees) 
{
     79c:	cf 93       	push	r28
     79e:	df 93       	push	r29
     7a0:	ec 01       	movw	r28, r24
// 28 pulses for 360 degrees rotation 12.92 degrees per count
 left_pos(); //Turn left
     7a2:	0e 94 25 03 	call	0x64a	; 0x64a <left_pos>
 angle_rotate(Degrees);
     7a6:	ce 01       	movw	r24, r28
     7a8:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     7ac:	df 91       	pop	r29
     7ae:	cf 91       	pop	r28
     7b0:	08 95       	ret

000007b2 <right_degrees>:



void right_degrees(unsigned int Degrees)
{
     7b2:	cf 93       	push	r28
     7b4:	df 93       	push	r29
     7b6:	ec 01       	movw	r28, r24
// 28 pulses for 360 degrees rotation 12.92 degrees per count
 right_pos(); //Turn right
     7b8:	0e 94 29 03 	call	0x652	; 0x652 <right_pos>
 angle_rotate(Degrees);
     7bc:	ce 01       	movw	r24, r28
     7be:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     7c2:	df 91       	pop	r29
     7c4:	cf 91       	pop	r28
     7c6:	08 95       	ret

000007c8 <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)
{
     7c8:	cf 93       	push	r28
     7ca:	df 93       	push	r29
     7cc:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_left_pos(); //Turn soft left
     7ce:	0e 94 2d 03 	call	0x65a	; 0x65a <soft_left_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     7d2:	ce 01       	movw	r24, r28
     7d4:	88 0f       	add	r24, r24
     7d6:	99 1f       	adc	r25, r25
     7d8:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     7dc:	df 91       	pop	r29
     7de:	cf 91       	pop	r28
     7e0:	08 95       	ret

000007e2 <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
     7e2:	cf 93       	push	r28
     7e4:	df 93       	push	r29
     7e6:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_right_pos();  //Turn soft right
     7e8:	0e 94 31 03 	call	0x662	; 0x662 <soft_right_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     7ec:	ce 01       	movw	r24, r28
     7ee:	88 0f       	add	r24, r24
     7f0:	99 1f       	adc	r25, r25
     7f2:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     7f6:	df 91       	pop	r29
     7f8:	cf 91       	pop	r28
     7fa:	08 95       	ret

000007fc <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
     7fc:	cf 93       	push	r28
     7fe:	df 93       	push	r29
     800:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_left_2_pos(); //Turn reverse soft left
     802:	0e 94 35 03 	call	0x66a	; 0x66a <soft_left_2_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     806:	ce 01       	movw	r24, r28
     808:	88 0f       	add	r24, r24
     80a:	99 1f       	adc	r25, r25
     80c:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     810:	df 91       	pop	r29
     812:	cf 91       	pop	r28
     814:	08 95       	ret

00000816 <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
     816:	cf 93       	push	r28
     818:	df 93       	push	r29
     81a:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_right_2_pos();  //Turn reverse soft right
     81c:	0e 94 39 03 	call	0x672	; 0x672 <soft_right_2_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     820:	ce 01       	movw	r24, r28
     822:	88 0f       	add	r24, r24
     824:	99 1f       	adc	r25, r25
     826:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     82a:	df 91       	pop	r29
     82c:	cf 91       	pop	r28
     82e:	08 95       	ret

00000830 <init_devices_pos>:

//Function to initialize all the devices
void init_devices_pos()
{
 cli(); //Clears the global interrupt
     830:	f8 94       	cli
 port_init_pos();  //Initializes all the ports
     832:	0e 94 b4 02 	call	0x568	; 0x568 <port_init_pos>
 left_position_encoder_interrupt_init();
     836:	0e 94 bb 02 	call	0x576	; 0x576 <left_position_encoder_interrupt_init>
 right_position_encoder_interrupt_init();
     83a:	0e 94 c4 02 	call	0x588	; 0x588 <right_position_encoder_interrupt_init>
 sei();   // Enables the global interrupt 
     83e:	78 94       	sei
}
     840:	08 95       	ret

00000842 <servo1_pin_config>:
#include <util/delay.h>

//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
	DDRD  = DDRD | 0x80;  //making PORTB 5 pin output
     842:	8f 9a       	sbi	0x11, 7	; 17
	PORTD = PORTD | 0x80; //setting PORTB 5 pin to logic 1
     844:	97 9a       	sbi	0x12, 7	; 18
}
     846:	08 95       	ret

00000848 <port_init_servo>:
void port_init_servo(void)
{
	servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
     848:	0e 94 21 04 	call	0x842	; 0x842 <servo1_pin_config>
	
}
     84c:	08 95       	ret

0000084e <timer2_init>:
void timer2_init(void)
{
 TCCR2= 0x00; //stop
     84e:	15 bc       	out	0x25, r1	; 37
 TCNT2 = 0xFE;
     850:	8e ef       	ldi	r24, 0xFE	; 254
     852:	84 bd       	out	0x24, r24	; 36
 OCR2 = 0x8F;
     854:	8f e8       	ldi	r24, 0x8F	; 143
     856:	83 bd       	out	0x23, r24	; 35
 TCCR2= (1<< COM21)|(1<<WGM20)|(1<<WGM21);
     858:	88 e6       	ldi	r24, 0x68	; 104
     85a:	85 bd       	out	0x25, r24	; 37
 //OCR2 = 0x8F;	//Output compare Register high value for servo 1
 
 
 
 
 TCCR2|= (1<<CS22)|(1<<CS20);
     85c:	85 b5       	in	r24, 0x25	; 37
     85e:	85 60       	ori	r24, 0x05	; 5
     860:	85 bd       	out	0x25, r24	; 37
 
}
     862:	08 95       	ret

00000864 <init_devices_servo>:
void init_devices_servo(void)
{
	cli(); //disable all interrupts
     864:	f8 94       	cli
	port_init_servo();
     866:	0e 94 24 04 	call	0x848	; 0x848 <port_init_servo>
	timer2_init();
     86a:	0e 94 27 04 	call	0x84e	; 0x84e <timer2_init>
	sei(); //re-enable interrupts
     86e:	78 94       	sei
}
     870:	08 95       	ret

00000872 <servo_1>:

void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
     872:	68 2f       	mov	r22, r24
     874:	70 e0       	ldi	r23, 0x00	; 0
     876:	80 e0       	ldi	r24, 0x00	; 0
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <__floatunsisf>
     87e:	2b e7       	ldi	r18, 0x7B	; 123
     880:	34 e1       	ldi	r19, 0x14	; 20
     882:	4e ee       	ldi	r20, 0xEE	; 238
     884:	5f e3       	ldi	r21, 0x3F	; 63
     886:	0e 94 56 0e 	call	0x1cac	; 0x1cac <__divsf3>
     88a:	20 e0       	ldi	r18, 0x00	; 0
     88c:	30 e0       	ldi	r19, 0x00	; 0
     88e:	4c e0       	ldi	r20, 0x0C	; 12
     890:	52 e4       	ldi	r21, 0x42	; 66
     892:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <__addsf3>
	
	//OCR1AH = 0x00;
	OCR2 = (unsigned char) PositionPanServo;
     896:	0e 94 be 0e 	call	0x1d7c	; 0x1d7c <__fixunssfsi>
     89a:	63 bd       	out	0x23, r22	; 35
}
     89c:	08 95       	ret

0000089e <servo_1_free>:
void servo_1_free (void) //makes servo 1 free rotating
{
	//OCR1AH = 0x03;
	OCR2 = 0x8F; //Servo 1 off
     89e:	8f e8       	ldi	r24, 0x8F	; 143
     8a0:	83 bd       	out	0x23, r24	; 35
}
     8a2:	08 95       	ret

000008a4 <adc_pin_config_sharp>:
}*/

//ADC pin configuration
void adc_pin_config_sharp (void)
{
 DDRA = 0x00;  //set PORTF direction as input
     8a4:	1a ba       	out	0x1a, r1	; 26
 PORTA = 0x00; //set PORTF pins floating
     8a6:	1b ba       	out	0x1b, r1	; 27
}
     8a8:	08 95       	ret

000008aa <ultrsonic_trigger_config>:

void ultrsonic_trigger_config(void)
{
 DDRD = DDRD | 0x40;   //all the LCD pin's direction set as output
     8aa:	8e 9a       	sbi	0x11, 6	; 17
 PORTD = PORTD & 0x00; // all the LCD pins are set to logic 0 except PORTC 7
     8ac:	82 b3       	in	r24, 0x12	; 18
     8ae:	12 ba       	out	0x12, r1	; 18
}
     8b0:	08 95       	ret

000008b2 <port_init_sharp>:

//Function to Initialize PORTs
void port_init_sharp()
{
 //lcd_port_config();
 adc_pin_config_sharp();		
     8b2:	0e 94 52 04 	call	0x8a4	; 0x8a4 <adc_pin_config_sharp>
 ultrsonic_trigger_config();
     8b6:	0e 94 55 04 	call	0x8aa	; 0x8aa <ultrsonic_trigger_config>
}
     8ba:	08 95       	ret

000008bc <adc_init_sharp>:

//Function to Initialize ADC
void adc_init_sharp()
{
 ADCSRA = 0x00;
     8bc:	16 b8       	out	0x06, r1	; 6
 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     8be:	80 e2       	ldi	r24, 0x20	; 32
     8c0:	87 b9       	out	0x07, r24	; 7
 ACSR = 0x80;
     8c2:	80 e8       	ldi	r24, 0x80	; 128
     8c4:	88 b9       	out	0x08, r24	; 8
 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     8c6:	86 e8       	ldi	r24, 0x86	; 134
     8c8:	86 b9       	out	0x06, r24	; 6
}
     8ca:	08 95       	ret

000008cc <ADC_Conversion_sharp>:

//This Function accepts the Channel Number and returns the corresponding Analog Value 
unsigned char ADC_Conversion_sharp(unsigned char Ch)
{
 unsigned char a;
 Ch = Ch & 0x07;  			
     8cc:	87 70       	andi	r24, 0x07	; 7
 ADMUX= 0x20| Ch;	   		
     8ce:	80 62       	ori	r24, 0x20	; 32
     8d0:	87 b9       	out	0x07, r24	; 7
 ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     8d2:	36 9a       	sbi	0x06, 6	; 6
 while((ADCSRA&0x10)==0);	    //Wait for ADC conversion to complete
     8d4:	34 9b       	sbis	0x06, 4	; 6
     8d6:	fe cf       	rjmp	.-4      	; 0x8d4 <ADC_Conversion_sharp+0x8>
 a=ADCH;
     8d8:	85 b1       	in	r24, 0x05	; 5
 ADCSRA = ADCSRA|0x10;          //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     8da:	34 9a       	sbi	0x06, 4	; 6
 return a;
}
     8dc:	08 95       	ret

000008de <ultrasonic_trigger>:

// Ultrasonic sensor are connected in chaining mode. This function rise a 
// trigger pulse of >20usec to command ringing.     
void ultrasonic_trigger(void)                 
{
 PORTD = PORTD | 0x40;  // make high the Trigger input for Ultrasonic sensor
     8de:	96 9a       	sbi	0x12, 6	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     8e0:	8b e7       	ldi	r24, 0x7B	; 123
     8e2:	8a 95       	dec	r24
     8e4:	f1 f7       	brne	.-4      	; 0x8e2 <ultrasonic_trigger+0x4>
 _delay_us(50);         // Wait for >20usec
 PORTD = PORTD & 0xBF;  // make low the Trigger input for Ultrasonic sensor
     8e6:	96 98       	cbi	0x12, 6	; 18
}
     8e8:	08 95       	ret

000008ea <init_devices_sharp>:

void init_devices_sharp (void)
{
 cli();           //Clears the global interrupts
     8ea:	f8 94       	cli
 port_init_sharp();
     8ec:	0e 94 59 04 	call	0x8b2	; 0x8b2 <port_init_sharp>
 adc_init_sharp();
     8f0:	0e 94 5e 04 	call	0x8bc	; 0x8bc <adc_init_sharp>
 sei();           //Enables the global interrupts
     8f4:	78 94       	sei
}
     8f6:	08 95       	ret

000008f8 <servo100>:
unsigned char Left_white_line = 0;
unsigned char Center_white_line = 0;
unsigned char Right_white_line = 0;

void servo100()
{
     8f8:	cf 93       	push	r28
     8fa:	cf e5       	ldi	r28, 0x5F	; 95
	for(int i=95;i<=180;i=i+3)
	{
		init_devices_sharp();
     8fc:	0e 94 75 04 	call	0x8ea	; 0x8ea <init_devices_sharp>
		//			lcd_set_4bit();
		//			lcd_init();
		for (int i=0;i<2;i++)
		{
			Center_ultrasonic_Sensor = ADC_Conversion_sharp(1) * 2;
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	0e 94 66 04 	call	0x8cc	; 0x8cc <ADC_Conversion_sharp>
     906:	88 0f       	add	r24, r24
     908:	80 93 d8 00 	sts	0x00D8, r24
     90c:	81 e0       	ldi	r24, 0x01	; 1
     90e:	0e 94 66 04 	call	0x8cc	; 0x8cc <ADC_Conversion_sharp>
     912:	88 0f       	add	r24, r24
     914:	80 93 d8 00 	sts	0x00D8, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     918:	8f ef       	ldi	r24, 0xFF	; 255
     91a:	9f e3       	ldi	r25, 0x3F	; 63
     91c:	a2 e0       	ldi	r26, 0x02	; 2
     91e:	81 50       	subi	r24, 0x01	; 1
     920:	90 40       	sbci	r25, 0x00	; 0
     922:	a0 40       	sbci	r26, 0x00	; 0
     924:	e1 f7       	brne	.-8      	; 0x91e <servo100+0x26>
     926:	00 c0       	rjmp	.+0      	; 0x928 <servo100+0x30>
     928:	00 00       	nop
			//lcd_print(2,12,Center_ultrasonic_Sensor,3);       // In Inches
			
		}
		_delay_ms(100);
		
		init_devices_servo();
     92a:	0e 94 32 04 	call	0x864	; 0x864 <init_devices_servo>
		servo_1(i);
     92e:	8c 2f       	mov	r24, r28
     930:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     934:	af ef       	ldi	r26, 0xFF	; 255
     936:	b7 e4       	ldi	r27, 0x47	; 71
     938:	11 97       	sbiw	r26, 0x01	; 1
     93a:	f1 f7       	brne	.-4      	; 0x938 <servo100+0x40>
     93c:	00 c0       	rjmp	.+0      	; 0x93e <servo100+0x46>
     93e:	00 00       	nop
		_delay_ms(10);
		
		
		if(Center_ultrasonic_Sensor>200 )
     940:	80 91 d8 00 	lds	r24, 0x00D8
     944:	89 3c       	cpi	r24, 0xC9	; 201
     946:	18 f1       	brcs	.+70     	; 0x98e <servo100+0x96>
     948:	8f ef       	ldi	r24, 0xFF	; 255
     94a:	9f e3       	ldi	r25, 0x3F	; 63
     94c:	ab e0       	ldi	r26, 0x0B	; 11
     94e:	81 50       	subi	r24, 0x01	; 1
     950:	90 40       	sbci	r25, 0x00	; 0
     952:	a0 40       	sbci	r26, 0x00	; 0
     954:	e1 f7       	brne	.-8      	; 0x94e <servo100+0x56>
     956:	00 c0       	rjmp	.+0      	; 0x958 <servo100+0x60>
     958:	00 00       	nop
		{
			//servo_1(i);
			_delay_ms(500);
			//buzzer_beep();
			side=100;
     95a:	84 e6       	ldi	r24, 0x64	; 100
     95c:	80 93 74 00 	sts	0x0074, r24
			color_sensor_work();
     960:	0e 94 c3 08 	call	0x1186	; 0x1186 <color_sensor_work>
     964:	8f ef       	ldi	r24, 0xFF	; 255
     966:	9f e3       	ldi	r25, 0x3F	; 63
     968:	a2 e0       	ldi	r26, 0x02	; 2
     96a:	81 50       	subi	r24, 0x01	; 1
     96c:	90 40       	sbci	r25, 0x00	; 0
     96e:	a0 40       	sbci	r26, 0x00	; 0
     970:	e1 f7       	brne	.-8      	; 0x96a <servo100+0x72>
     972:	00 c0       	rjmp	.+0      	; 0x974 <servo100+0x7c>
     974:	00 00       	nop
			
			_delay_ms(100);
			do_task();
     976:	0e 94 49 00 	call	0x92	; 0x92 <do_task>
     97a:	8f ef       	ldi	r24, 0xFF	; 255
     97c:	9f e3       	ldi	r25, 0x3F	; 63
     97e:	ab e0       	ldi	r26, 0x0B	; 11
     980:	81 50       	subi	r24, 0x01	; 1
     982:	90 40       	sbci	r25, 0x00	; 0
     984:	a0 40       	sbci	r26, 0x00	; 0
     986:	e1 f7       	brne	.-8      	; 0x980 <servo100+0x88>
     988:	00 c0       	rjmp	.+0      	; 0x98a <servo100+0x92>
     98a:	00 00       	nop
     98c:	04 c0       	rjmp	.+8      	; 0x996 <servo100+0x9e>
     98e:	cd 5f       	subi	r28, 0xFD	; 253
unsigned char Center_white_line = 0;
unsigned char Right_white_line = 0;

void servo100()
{
	for(int i=95;i<=180;i=i+3)
     990:	c6 3b       	cpi	r28, 0xB6	; 182
     992:	09 f0       	breq	.+2      	; 0x996 <servo100+0x9e>
     994:	b3 cf       	rjmp	.-154    	; 0x8fc <servo100+0x4>
			
			
		}
		
	}
	servo_1(95);
     996:	8f e5       	ldi	r24, 0x5F	; 95
     998:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     99c:	8f ef       	ldi	r24, 0xFF	; 255
     99e:	9f e3       	ldi	r25, 0x3F	; 63
     9a0:	ab e0       	ldi	r26, 0x0B	; 11
     9a2:	81 50       	subi	r24, 0x01	; 1
     9a4:	90 40       	sbci	r25, 0x00	; 0
     9a6:	a0 40       	sbci	r26, 0x00	; 0
     9a8:	e1 f7       	brne	.-8      	; 0x9a2 <servo100+0xaa>
     9aa:	00 c0       	rjmp	.+0      	; 0x9ac <servo100+0xb4>
     9ac:	00 00       	nop
	_delay_ms(500);
	
}
     9ae:	cf 91       	pop	r28
     9b0:	08 95       	ret

000009b2 <servo101>:
void servo101()
{
     9b2:	cf 93       	push	r28
     9b4:	cf e5       	ldi	r28, 0x5F	; 95
	for(int i=95;i>=10;i=i-3)
	{
		init_devices_sharp();
     9b6:	0e 94 75 04 	call	0x8ea	; 0x8ea <init_devices_sharp>
		//			lcd_set_4bit();
		//			lcd_init();
		for (int i=0;i<2;i++)
		{
			Center_ultrasonic_Sensor = ADC_Conversion_sharp(1) * 2;
     9ba:	81 e0       	ldi	r24, 0x01	; 1
     9bc:	0e 94 66 04 	call	0x8cc	; 0x8cc <ADC_Conversion_sharp>
     9c0:	88 0f       	add	r24, r24
     9c2:	80 93 d8 00 	sts	0x00D8, r24
     9c6:	81 e0       	ldi	r24, 0x01	; 1
     9c8:	0e 94 66 04 	call	0x8cc	; 0x8cc <ADC_Conversion_sharp>
     9cc:	88 0f       	add	r24, r24
     9ce:	80 93 d8 00 	sts	0x00D8, r24
     9d2:	8f ef       	ldi	r24, 0xFF	; 255
     9d4:	9f e3       	ldi	r25, 0x3F	; 63
     9d6:	a2 e0       	ldi	r26, 0x02	; 2
     9d8:	81 50       	subi	r24, 0x01	; 1
     9da:	90 40       	sbci	r25, 0x00	; 0
     9dc:	a0 40       	sbci	r26, 0x00	; 0
     9de:	e1 f7       	brne	.-8      	; 0x9d8 <servo101+0x26>
     9e0:	00 c0       	rjmp	.+0      	; 0x9e2 <servo101+0x30>
     9e2:	00 00       	nop
			//lcd_print(2,12,Center_ultrasonic_Sensor,3);       // In Inches
			
		}
		_delay_ms(100);
		
		init_devices_servo();
     9e4:	0e 94 32 04 	call	0x864	; 0x864 <init_devices_servo>
		servo_1(i);
     9e8:	8c 2f       	mov	r24, r28
     9ea:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     9ee:	af ef       	ldi	r26, 0xFF	; 255
     9f0:	b7 e4       	ldi	r27, 0x47	; 71
     9f2:	11 97       	sbiw	r26, 0x01	; 1
     9f4:	f1 f7       	brne	.-4      	; 0x9f2 <servo101+0x40>
     9f6:	00 c0       	rjmp	.+0      	; 0x9f8 <servo101+0x46>
     9f8:	00 00       	nop
		_delay_ms(10);
		
		
		if(Center_ultrasonic_Sensor>200 )
     9fa:	80 91 d8 00 	lds	r24, 0x00D8
     9fe:	89 3c       	cpi	r24, 0xC9	; 201
     a00:	18 f1       	brcs	.+70     	; 0xa48 <servo101+0x96>
     a02:	8f ef       	ldi	r24, 0xFF	; 255
     a04:	9f e3       	ldi	r25, 0x3F	; 63
     a06:	ab e0       	ldi	r26, 0x0B	; 11
     a08:	81 50       	subi	r24, 0x01	; 1
     a0a:	90 40       	sbci	r25, 0x00	; 0
     a0c:	a0 40       	sbci	r26, 0x00	; 0
     a0e:	e1 f7       	brne	.-8      	; 0xa08 <servo101+0x56>
     a10:	00 c0       	rjmp	.+0      	; 0xa12 <servo101+0x60>
     a12:	00 00       	nop
		{	//servo_1_free();
			_delay_ms(500);
			//buzzer_beep();
			side=101;
     a14:	85 e6       	ldi	r24, 0x65	; 101
     a16:	80 93 74 00 	sts	0x0074, r24
			color_sensor_work();
     a1a:	0e 94 c3 08 	call	0x1186	; 0x1186 <color_sensor_work>
     a1e:	8f ef       	ldi	r24, 0xFF	; 255
     a20:	9f e3       	ldi	r25, 0x3F	; 63
     a22:	a2 e0       	ldi	r26, 0x02	; 2
     a24:	81 50       	subi	r24, 0x01	; 1
     a26:	90 40       	sbci	r25, 0x00	; 0
     a28:	a0 40       	sbci	r26, 0x00	; 0
     a2a:	e1 f7       	brne	.-8      	; 0xa24 <servo101+0x72>
     a2c:	00 c0       	rjmp	.+0      	; 0xa2e <servo101+0x7c>
     a2e:	00 00       	nop
			
			_delay_ms(100);
			do_task();
     a30:	0e 94 49 00 	call	0x92	; 0x92 <do_task>
     a34:	8f ef       	ldi	r24, 0xFF	; 255
     a36:	9f e3       	ldi	r25, 0x3F	; 63
     a38:	ab e0       	ldi	r26, 0x0B	; 11
     a3a:	81 50       	subi	r24, 0x01	; 1
     a3c:	90 40       	sbci	r25, 0x00	; 0
     a3e:	a0 40       	sbci	r26, 0x00	; 0
     a40:	e1 f7       	brne	.-8      	; 0xa3a <servo101+0x88>
     a42:	00 c0       	rjmp	.+0      	; 0xa44 <servo101+0x92>
     a44:	00 00       	nop
     a46:	04 c0       	rjmp	.+8      	; 0xa50 <servo101+0x9e>
     a48:	c3 50       	subi	r28, 0x03	; 3
	_delay_ms(500);
	
}
void servo101()
{
	for(int i=95;i>=10;i=i-3)
     a4a:	c8 30       	cpi	r28, 0x08	; 8
     a4c:	09 f0       	breq	.+2      	; 0xa50 <servo101+0x9e>
     a4e:	b3 cf       	rjmp	.-154    	; 0x9b6 <servo101+0x4>
			
			break;
		}
		
	}
	servo_1(95);
     a50:	8f e5       	ldi	r24, 0x5F	; 95
     a52:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     a56:	8f ef       	ldi	r24, 0xFF	; 255
     a58:	9f e3       	ldi	r25, 0x3F	; 63
     a5a:	a2 e0       	ldi	r26, 0x02	; 2
     a5c:	81 50       	subi	r24, 0x01	; 1
     a5e:	90 40       	sbci	r25, 0x00	; 0
     a60:	a0 40       	sbci	r26, 0x00	; 0
     a62:	e1 f7       	brne	.-8      	; 0xa5c <servo101+0xaa>
     a64:	00 c0       	rjmp	.+0      	; 0xa66 <servo101+0xb4>
     a66:	00 00       	nop
	_delay_ms(100);
}
     a68:	cf 91       	pop	r28
     a6a:	08 95       	ret

00000a6c <lcd_port_config>:


//Function to configure LCD port
void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7;    //all the LCD pin's direction set as output
     a6c:	84 b3       	in	r24, 0x14	; 20
     a6e:	87 6f       	ori	r24, 0xF7	; 247
     a70:	84 bb       	out	0x14, r24	; 20
 PORTC = PORTC & 0x80;  // all the LCD pins are set to logic 0 except PORTC 7
     a72:	85 b3       	in	r24, 0x15	; 21
     a74:	80 78       	andi	r24, 0x80	; 128
     a76:	85 bb       	out	0x15, r24	; 21
}
     a78:	08 95       	ret

00000a7a <adc_pin_config>:

//ADC pin configuration
void adc_pin_config (void)
{
 DDRA = 0x00;   //set PORTF direction as input
     a7a:	1a ba       	out	0x1a, r1	; 26
 PORTA = 0x00;  //set PORTF pins floating
     a7c:	1b ba       	out	0x1b, r1	; 27
}
     a7e:	08 95       	ret

00000a80 <motion_pin_config>:

//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
 DDRB = DDRB | 0x0F;    //set direction of the PORTB3 to PORTB0 pins as output
     a80:	87 b3       	in	r24, 0x17	; 23
     a82:	8f 60       	ori	r24, 0x0F	; 15
     a84:	87 bb       	out	0x17, r24	; 23
 PORTB = PORTB & 0xF0;  //set initial value of the PORTB3 to PORTB0 pins to logic 0
     a86:	88 b3       	in	r24, 0x18	; 24
     a88:	80 7f       	andi	r24, 0xF0	; 240
     a8a:	88 bb       	out	0x18, r24	; 24
 DDRD = DDRD | 0x30;    //Setting PD5 and PD4 pins as output for PWM generation
     a8c:	81 b3       	in	r24, 0x11	; 17
     a8e:	80 63       	ori	r24, 0x30	; 48
     a90:	81 bb       	out	0x11, r24	; 17
 PORTD = PORTD | 0x30;  //PD5 and PD4 pins are for velocity control using PWM
     a92:	82 b3       	in	r24, 0x12	; 18
     a94:	80 63       	ori	r24, 0x30	; 48
     a96:	82 bb       	out	0x12, r24	; 18
}
     a98:	08 95       	ret

00000a9a <port_init>:

//Function to Initialize PORTS
void port_init()
{
 lcd_port_config();
     a9a:	0e 94 36 05 	call	0xa6c	; 0xa6c <lcd_port_config>
 adc_pin_config();		
     a9e:	0e 94 3d 05 	call	0xa7a	; 0xa7a <adc_pin_config>
 motion_pin_config();
     aa2:	0e 94 40 05 	call	0xa80	; 0xa80 <motion_pin_config>
}
     aa6:	08 95       	ret

00000aa8 <timer1_init>:
// WGM: 5) PWM 8bit fast, TOP=0x00FF
// desired value: 450Hz
// actual value: 450.000Hz (0.0%)
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     aa8:	1e bc       	out	0x2e, r1	; 46
 TCNT1H = 0xFF; //setup
     aaa:	8f ef       	ldi	r24, 0xFF	; 255
     aac:	8d bd       	out	0x2d, r24	; 45
 TCNT1L = 0x01;
     aae:	91 e0       	ldi	r25, 0x01	; 1
     ab0:	9c bd       	out	0x2c, r25	; 44
 OCR1AH = 0x00;
     ab2:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = 0xFF;
     ab4:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     ab6:	19 bc       	out	0x29, r1	; 41
 OCR1BL = 0xFF;
     ab8:	88 bd       	out	0x28, r24	; 40
 ICR1H  = 0x00;
     aba:	17 bc       	out	0x27, r1	; 39
 ICR1L  = 0xFF;
     abc:	86 bd       	out	0x26, r24	; 38
 TCCR1A = 0xA1;
     abe:	81 ea       	ldi	r24, 0xA1	; 161
     ac0:	8f bd       	out	0x2f, r24	; 47
 TCCR1B = 0x0D; //start Timer
     ac2:	8d e0       	ldi	r24, 0x0D	; 13
     ac4:	8e bd       	out	0x2e, r24	; 46
}
     ac6:	08 95       	ret

00000ac8 <adc_init>:


//Function to Initialize ADC
void adc_init()
{
 ADCSRA = 0x00;
     ac8:	16 b8       	out	0x06, r1	; 6
 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     aca:	80 e2       	ldi	r24, 0x20	; 32
     acc:	87 b9       	out	0x07, r24	; 7
 ACSR = 0x80;
     ace:	80 e8       	ldi	r24, 0x80	; 128
     ad0:	88 b9       	out	0x08, r24	; 8
 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     ad2:	86 e8       	ldi	r24, 0x86	; 134
     ad4:	86 b9       	out	0x06, r24	; 6
}
     ad6:	08 95       	ret

00000ad8 <ADC_Conversion>:

//This Function accepts the Channel Number and returns the corresponding Analog Value 
unsigned char ADC_Conversion(unsigned char Ch)
{
 unsigned char a;
 Ch = Ch & 0x07;  			
     ad8:	87 70       	andi	r24, 0x07	; 7
 ADMUX= 0x20| Ch;	   		
     ada:	80 62       	ori	r24, 0x20	; 32
     adc:	87 b9       	out	0x07, r24	; 7
 ADCSRA = ADCSRA | 0x40;	//Set start conversion bit
     ade:	36 9a       	sbi	0x06, 6	; 6
 while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     ae0:	34 9b       	sbis	0x06, 4	; 6
     ae2:	fe cf       	rjmp	.-4      	; 0xae0 <ADC_Conversion+0x8>
 a=ADCH;
     ae4:	85 b1       	in	r24, 0x05	; 5
 ADCSRA = ADCSRA|0x10;      //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     ae6:	34 9a       	sbi	0x06, 4	; 6
 return a;
}
     ae8:	08 95       	ret

00000aea <print_sensor>:

// This Function prints the Analog Value Of Corresponding Channel No. at required Row
// and Coloumn Location. 
void print_sensor(char row, char coloumn,unsigned char channel)
{
     aea:	84 2f       	mov	r24, r20
 ADC_Value = ADC_Conversion(channel);
     aec:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>
     af0:	80 93 d7 00 	sts	0x00D7, r24
// lcd_print(row, coloumn, ADC_Value, 3);
}
     af4:	08 95       	ret

00000af6 <motion_set>:
void motion_set (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 			// removing upper nibbel as it is not needed
 PortBRestore = PORTB; 			// reading the PORTB's original status
     af6:	98 b3       	in	r25, 0x18	; 24
 PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
     af8:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 			// removing upper nibbel as it is not needed
     afa:	8f 70       	andi	r24, 0x0F	; 15
 PortBRestore = PORTB; 			// reading the PORTB's original status
 PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
 PortBRestore |= Direction; 	// adding lower nibbel for direction command and restoring the PORTB status
     afc:	98 2b       	or	r25, r24
 PORTB = PortBRestore; 			// setting the command to the port
     afe:	98 bb       	out	0x18, r25	; 24
}
     b00:	08 95       	ret

00000b02 <forward>:

void forward (void) //both wheels forward
{
  motion_set(0x06);
     b02:	86 e0       	ldi	r24, 0x06	; 6
     b04:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b08:	08 95       	ret

00000b0a <back>:

void back (void) //hard stop
{
  motion_set(0x09);
     b0a:	89 e0       	ldi	r24, 0x09	; 9
     b0c:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b10:	08 95       	ret

00000b12 <left>:
void left (void) //hard stop
{
	motion_set(0x05);
     b12:	85 e0       	ldi	r24, 0x05	; 5
     b14:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b18:	08 95       	ret

00000b1a <right>:
void right (void) //hard stop
{
	motion_set(0x0A);
     b1a:	8a e0       	ldi	r24, 0x0A	; 10
     b1c:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b20:	08 95       	ret

00000b22 <hard_stop>:
void hard_stop (void) //hard stop
{
	motion_set(0x00);
     b22:	80 e0       	ldi	r24, 0x00	; 0
     b24:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b28:	08 95       	ret

00000b2a <s_L>:
void s_L (void) //hard stop
{
	motion_set(0x04);
     b2a:	84 e0       	ldi	r24, 0x04	; 4
     b2c:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b30:	08 95       	ret

00000b32 <S_R>:
void S_R (void) //hard stop
{
	motion_set(0x02);
     b32:	82 e0       	ldi	r24, 0x02	; 2
     b34:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b38:	08 95       	ret

00000b3a <S_STOP>:
void S_STOP (void) //hard stop
{
	motion_set(0x0F);
     b3a:	8f e0       	ldi	r24, 0x0F	; 15
     b3c:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <motion_set>
}
     b40:	08 95       	ret

00000b42 <velocity>:


//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
 OCR1AH = 0x00;
     b42:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = left_motor; 
     b44:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     b46:	19 bc       	out	0x29, r1	; 41
 OCR1BL = right_motor;
     b48:	68 bd       	out	0x28, r22	; 40
}
     b4a:	08 95       	ret

00000b4c <success>:
	}
}


void success(int x)
{
     b4c:	0f 93       	push	r16
     b4e:	1f 93       	push	r17
     b50:	cf 93       	push	r28
     b52:	df 93       	push	r29
     b54:	ec 01       	movw	r28, r24
	unsigned char Left_white_line = 0;
	unsigned char Center_white_line = 0;
	unsigned char Right_white_line = 0;
	
	buzzer_on();
     b56:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
     b5a:	8f ef       	ldi	r24, 0xFF	; 255
     b5c:	9f e3       	ldi	r25, 0x3F	; 63
     b5e:	ab e0       	ldi	r26, 0x0B	; 11
     b60:	81 50       	subi	r24, 0x01	; 1
     b62:	90 40       	sbci	r25, 0x00	; 0
     b64:	a0 40       	sbci	r26, 0x00	; 0
     b66:	e1 f7       	brne	.-8      	; 0xb60 <success+0x14>
     b68:	00 c0       	rjmp	.+0      	; 0xb6a <success+0x1e>
     b6a:	00 00       	nop
	_delay_ms(500);
	buzzer_off();
     b6c:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
	
	switch (x)
     b70:	c2 30       	cpi	r28, 0x02	; 2
     b72:	d1 05       	cpc	r29, r1
     b74:	b1 f0       	breq	.+44     	; 0xba2 <success+0x56>
     b76:	c3 30       	cpi	r28, 0x03	; 3
     b78:	d1 05       	cpc	r29, r1
     b7a:	19 f1       	breq	.+70     	; 0xbc2 <success+0x76>
     b7c:	c1 30       	cpi	r28, 0x01	; 1
     b7e:	d1 05       	cpc	r29, r1
     b80:	79 f5       	brne	.+94     	; 0xbe0 <success+0x94>
	{
		case 1:
		velocity(VELOCITY_MAX,VELOCITY_MAX+q);      // Run robot at max velocity
     b82:	8c e3       	ldi	r24, 0x3C	; 60
     b84:	61 e4       	ldi	r22, 0x41	; 65
     b86:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		forward();
     b8a:	0e 94 81 05 	call	0xb02	; 0xb02 <forward>
     b8e:	8f ef       	ldi	r24, 0xFF	; 255
     b90:	9f eb       	ldi	r25, 0xBF	; 191
     b92:	a6 e0       	ldi	r26, 0x06	; 6
     b94:	81 50       	subi	r24, 0x01	; 1
     b96:	90 40       	sbci	r25, 0x00	; 0
     b98:	a0 40       	sbci	r26, 0x00	; 0
     b9a:	e1 f7       	brne	.-8      	; 0xb94 <success+0x48>
     b9c:	00 c0       	rjmp	.+0      	; 0xb9e <success+0x52>
     b9e:	00 00       	nop
     ba0:	1f c0       	rjmp	.+62     	; 0xbe0 <success+0x94>
		_delay_ms(300);
		break;
		case 2:
		velocity(VELOCITY_MAX,VELOCITY_MIN+q);      // Run robot left wheel at max velocity and right wheel
     ba2:	8c e3       	ldi	r24, 0x3C	; 60
     ba4:	69 e1       	ldi	r22, 0x19	; 25
     ba6:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		right();
     baa:	0e 94 8d 05 	call	0xb1a	; 0xb1a <right>
     bae:	8f ef       	ldi	r24, 0xFF	; 255
     bb0:	9f e3       	ldi	r25, 0x3F	; 63
     bb2:	a4 e1       	ldi	r26, 0x14	; 20
     bb4:	81 50       	subi	r24, 0x01	; 1
     bb6:	90 40       	sbci	r25, 0x00	; 0
     bb8:	a0 40       	sbci	r26, 0x00	; 0
     bba:	e1 f7       	brne	.-8      	; 0xbb4 <success+0x68>
     bbc:	00 c0       	rjmp	.+0      	; 0xbbe <success+0x72>
     bbe:	00 00       	nop
     bc0:	0f c0       	rjmp	.+30     	; 0xbe0 <success+0x94>
		_delay_ms(900);
		
		break;
		case 3:
		velocity(VELOCITY_MIN,VELOCITY_MAX+q);      // Run robot right wheel at max velocity and left wheel
     bc2:	84 e1       	ldi	r24, 0x14	; 20
     bc4:	61 e4       	ldi	r22, 0x41	; 65
     bc6:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		left();
     bca:	0e 94 89 05 	call	0xb12	; 0xb12 <left>
     bce:	8f ef       	ldi	r24, 0xFF	; 255
     bd0:	9f e3       	ldi	r25, 0x3F	; 63
     bd2:	a4 e1       	ldi	r26, 0x14	; 20
     bd4:	81 50       	subi	r24, 0x01	; 1
     bd6:	90 40       	sbci	r25, 0x00	; 0
     bd8:	a0 40       	sbci	r26, 0x00	; 0
     bda:	e1 f7       	brne	.-8      	; 0xbd4 <success+0x88>
     bdc:	00 c0       	rjmp	.+0      	; 0xbde <success+0x92>
     bde:	00 00       	nop
	}
	
	while(1)
	{
		
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     be0:	83 e0       	ldi	r24, 0x03	; 3
     be2:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>
     be6:	08 2f       	mov	r16, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     be8:	82 e0       	ldi	r24, 0x02	; 2
     bea:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>
     bee:	18 2f       	mov	r17, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
     bf0:	81 e0       	ldi	r24, 0x01	; 1
     bf2:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>

		//		print_sensor(1,1,3);	//Prints value of White Line Sensor1
		//print_sensor(1,5,2);	//Prints Value of White Line Sensor2
		//	print_sensor(1,9,1);	//Prints Value of White Line Sensor3

		if(Center_white_line<THRESHOLD && Left_white_line<THRESHOLD && Right_white_line<THRESHOLD)
     bf6:	14 31       	cpi	r17, 0x14	; 20
     bf8:	08 f0       	brcs	.+2      	; 0xbfc <success+0xb0>
     bfa:	4c c0       	rjmp	.+152    	; 0xc94 <success+0x148>
     bfc:	04 31       	cpi	r16, 0x14	; 20
     bfe:	08 f0       	brcs	.+2      	; 0xc02 <success+0xb6>
     c00:	49 c0       	rjmp	.+146    	; 0xc94 <success+0x148>
     c02:	84 31       	cpi	r24, 0x14	; 20
     c04:	08 f0       	brcs	.+2      	; 0xc08 <success+0xbc>
     c06:	46 c0       	rjmp	.+140    	; 0xc94 <success+0x148>
		{	buzzer_on();
     c08:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
     c0c:	8f ef       	ldi	r24, 0xFF	; 255
     c0e:	9f e3       	ldi	r25, 0x3F	; 63
     c10:	ab e0       	ldi	r26, 0x0B	; 11
     c12:	81 50       	subi	r24, 0x01	; 1
     c14:	90 40       	sbci	r25, 0x00	; 0
     c16:	a0 40       	sbci	r26, 0x00	; 0
     c18:	e1 f7       	brne	.-8      	; 0xc12 <success+0xc6>
     c1a:	00 c0       	rjmp	.+0      	; 0xc1c <success+0xd0>
     c1c:	00 00       	nop
			_delay_ms(500);
			buzzer_off();
     c1e:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
			switch (x)
     c22:	c2 30       	cpi	r28, 0x02	; 2
     c24:	d1 05       	cpc	r29, r1
     c26:	b1 f0       	breq	.+44     	; 0xc54 <success+0x108>
     c28:	c3 30       	cpi	r28, 0x03	; 3
     c2a:	d1 05       	cpc	r29, r1
     c2c:	19 f1       	breq	.+70     	; 0xc74 <success+0x128>
     c2e:	c1 30       	cpi	r28, 0x01	; 1
     c30:	d1 05       	cpc	r29, r1
     c32:	b1 f6       	brne	.-84     	; 0xbe0 <success+0x94>
			{
				case 1:
				velocity(VELOCITY_MAX,VELOCITY_MAX+q);      // Run robot at max velocity
     c34:	8c e3       	ldi	r24, 0x3C	; 60
     c36:	61 e4       	ldi	r22, 0x41	; 65
     c38:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
				forward();
     c3c:	0e 94 81 05 	call	0xb02	; 0xb02 <forward>
     c40:	8f ef       	ldi	r24, 0xFF	; 255
     c42:	9f e7       	ldi	r25, 0x7F	; 127
     c44:	a4 e0       	ldi	r26, 0x04	; 4
     c46:	81 50       	subi	r24, 0x01	; 1
     c48:	90 40       	sbci	r25, 0x00	; 0
     c4a:	a0 40       	sbci	r26, 0x00	; 0
     c4c:	e1 f7       	brne	.-8      	; 0xc46 <success+0xfa>
     c4e:	00 c0       	rjmp	.+0      	; 0xc50 <success+0x104>
     c50:	00 00       	nop
     c52:	c6 cf       	rjmp	.-116    	; 0xbe0 <success+0x94>
				_delay_ms(200);
				break;
				case 2:
				velocity(VELOCITY_MAX,VELOCITY_MIN+q);      // Run robot left wheel at max velocity and right wheel
     c54:	8c e3       	ldi	r24, 0x3C	; 60
     c56:	69 e1       	ldi	r22, 0x19	; 25
     c58:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
				right();
     c5c:	0e 94 8d 05 	call	0xb1a	; 0xb1a <right>
     c60:	8f ef       	ldi	r24, 0xFF	; 255
     c62:	9f e3       	ldi	r25, 0x3F	; 63
     c64:	ab e0       	ldi	r26, 0x0B	; 11
     c66:	81 50       	subi	r24, 0x01	; 1
     c68:	90 40       	sbci	r25, 0x00	; 0
     c6a:	a0 40       	sbci	r26, 0x00	; 0
     c6c:	e1 f7       	brne	.-8      	; 0xc66 <success+0x11a>
     c6e:	00 c0       	rjmp	.+0      	; 0xc70 <success+0x124>
     c70:	00 00       	nop
     c72:	b6 cf       	rjmp	.-148    	; 0xbe0 <success+0x94>
				_delay_ms(500);
				
				break;
				case 3:
				velocity(VELOCITY_MIN,VELOCITY_MAX+q);      // Run robot right wheel at max velocity and left wheel
     c74:	84 e1       	ldi	r24, 0x14	; 20
     c76:	61 e4       	ldi	r22, 0x41	; 65
     c78:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
				left();
     c7c:	0e 94 89 05 	call	0xb12	; 0xb12 <left>
     c80:	8f ef       	ldi	r24, 0xFF	; 255
     c82:	9f e3       	ldi	r25, 0x3F	; 63
     c84:	ab e0       	ldi	r26, 0x0B	; 11
     c86:	81 50       	subi	r24, 0x01	; 1
     c88:	90 40       	sbci	r25, 0x00	; 0
     c8a:	a0 40       	sbci	r26, 0x00	; 0
     c8c:	e1 f7       	brne	.-8      	; 0xc86 <success+0x13a>
     c8e:	00 c0       	rjmp	.+0      	; 0xc90 <success+0x144>
     c90:	00 00       	nop
     c92:	a6 cf       	rjmp	.-180    	; 0xbe0 <success+0x94>
		}


		

		else if((Left_white_line>THRESHOLD)) //&& (flag==0))
     c94:	05 31       	cpi	r16, 0x15	; 21
     c96:	80 f0       	brcs	.+32     	; 0xcb8 <success+0x16c>
		{
			//flag=1;
			velocity(VELOCITY_MIN,VELOCITY_MAX+q);      // Run robot right wheel at max velocity and left wheel
     c98:	84 e1       	ldi	r24, 0x14	; 20
     c9a:	61 e4       	ldi	r22, 0x41	; 65
     c9c:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
			left();
     ca0:	0e 94 89 05 	call	0xb12	; 0xb12 <left>
     ca4:	8f ef       	ldi	r24, 0xFF	; 255
     ca6:	9f eb       	ldi	r25, 0xBF	; 191
     ca8:	a6 e0       	ldi	r26, 0x06	; 6
     caa:	81 50       	subi	r24, 0x01	; 1
     cac:	90 40       	sbci	r25, 0x00	; 0
     cae:	a0 40       	sbci	r26, 0x00	; 0
     cb0:	e1 f7       	brne	.-8      	; 0xcaa <success+0x15e>
     cb2:	00 c0       	rjmp	.+0      	; 0xcb4 <success+0x168>
     cb4:	00 00       	nop
     cb6:	24 c0       	rjmp	.+72     	; 0xd00 <success+0x1b4>
			_delay_ms(300);
			break;
		}

		else if((Right_white_line>THRESHOLD))// && (flag==0))
     cb8:	85 31       	cpi	r24, 0x15	; 21
     cba:	80 f0       	brcs	.+32     	; 0xcdc <success+0x190>
		{
			//	flag=1;
			
			velocity(VELOCITY_MAX,VELOCITY_MIN +q);      // Run robot left wheel at max velocity and right wheel
     cbc:	8c e3       	ldi	r24, 0x3C	; 60
     cbe:	69 e1       	ldi	r22, 0x19	; 25
     cc0:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
			right();
     cc4:	0e 94 8d 05 	call	0xb1a	; 0xb1a <right>
     cc8:	8f ef       	ldi	r24, 0xFF	; 255
     cca:	9f eb       	ldi	r25, 0xBF	; 191
     ccc:	a6 e0       	ldi	r26, 0x06	; 6
     cce:	81 50       	subi	r24, 0x01	; 1
     cd0:	90 40       	sbci	r25, 0x00	; 0
     cd2:	a0 40       	sbci	r26, 0x00	; 0
     cd4:	e1 f7       	brne	.-8      	; 0xcce <success+0x182>
     cd6:	00 c0       	rjmp	.+0      	; 0xcd8 <success+0x18c>
     cd8:	00 00       	nop
     cda:	12 c0       	rjmp	.+36     	; 0xd00 <success+0x1b4>
			_delay_ms(300);
			break;
		}
		else if(Center_white_line>THRESHOLD)
     cdc:	15 31       	cpi	r17, 0x15	; 21
     cde:	08 f4       	brcc	.+2      	; 0xce2 <success+0x196>
     ce0:	7f cf       	rjmp	.-258    	; 0xbe0 <success+0x94>
		{
			//flag=1;
			velocity(VELOCITY_MAX,VELOCITY_MAX+q);      // Run robot at max velocity
     ce2:	8c e3       	ldi	r24, 0x3C	; 60
     ce4:	61 e4       	ldi	r22, 0x41	; 65
     ce6:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
			forward();
     cea:	0e 94 81 05 	call	0xb02	; 0xb02 <forward>
     cee:	8f ef       	ldi	r24, 0xFF	; 255
     cf0:	9f eb       	ldi	r25, 0xBF	; 191
     cf2:	a6 e0       	ldi	r26, 0x06	; 6
     cf4:	81 50       	subi	r24, 0x01	; 1
     cf6:	90 40       	sbci	r25, 0x00	; 0
     cf8:	a0 40       	sbci	r26, 0x00	; 0
     cfa:	e1 f7       	brne	.-8      	; 0xcf4 <success+0x1a8>
     cfc:	00 c0       	rjmp	.+0      	; 0xcfe <success+0x1b2>
     cfe:	00 00       	nop
		
		

	}
	
     d00:	df 91       	pop	r29
     d02:	cf 91       	pop	r28
     d04:	1f 91       	pop	r17
     d06:	0f 91       	pop	r16
     d08:	08 95       	ret

00000d0a <init_devices>:

void init_devices (void)
{
 cli();          //Clears the global interrupts
     d0a:	f8 94       	cli
 port_init();
     d0c:	0e 94 4d 05 	call	0xa9a	; 0xa9a <port_init>
 timer1_init();
     d10:	0e 94 54 05 	call	0xaa8	; 0xaa8 <timer1_init>
 adc_init();
     d14:	0e 94 64 05 	call	0xac8	; 0xac8 <adc_init>
 sei();          //Enables the global interrupts
     d18:	78 94       	sei
}
     d1a:	08 95       	ret

00000d1c <line_follower>:

//Main Function
int line_follower(void)
{
     d1c:	8f 92       	push	r8
     d1e:	9f 92       	push	r9
     d20:	af 92       	push	r10
     d22:	bf 92       	push	r11
     d24:	cf 92       	push	r12
     d26:	df 92       	push	r13
     d28:	ef 92       	push	r14
     d2a:	ff 92       	push	r15
     d2c:	0f 93       	push	r16
     d2e:	1f 93       	push	r17
     d30:	cf 93       	push	r28
     d32:	df 93       	push	r29
 //unsigned char flag ;

 init_devices();
     d34:	0e 94 85 06 	call	0xd0a	; 0xd0a <init_devices>

 

 velocity(VELOCITY_MAX,VELOCITY_MAX+q);    // Set the speed to max velocity
     d38:	8c e3       	ldi	r24, 0x3C	; 60
     d3a:	61 e4       	ldi	r22, 0x41	; 65
     d3c:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		}
		
		if(stage==3)
		{	unsigned char count=0;
			unsigned char i;
			if(path1.path[t]==46 )
     d40:	0f 2e       	mov	r0, r31
     d42:	f8 ec       	ldi	r31, 0xC8	; 200
     d44:	cf 2e       	mov	r12, r31
     d46:	f0 e0       	ldi	r31, 0x00	; 0
     d48:	df 2e       	mov	r13, r31
     d4a:	f0 2d       	mov	r31, r0
			}
			
			for ( i=0;i<r;i++)
			{
				
				if(path1.path[t]==red_nodes[i])
     d4c:	03 ef       	ldi	r16, 0xF3	; 243
     d4e:	10 e0       	ldi	r17, 0x00	; 0
			servo101();
			//1000 1111
		}
		
		if(stage==3)
		{	unsigned char count=0;
     d50:	ee 24       	eor	r14, r14
     d52:	e3 94       	inc	r14
				buzzer_beep();
				
			}
			if(count==1)
			{
				if(red_side[i]==100)
     d54:	0f 2e       	mov	r0, r31
     d56:	ff ef       	ldi	r31, 0xFF	; 255
     d58:	af 2e       	mov	r10, r31
     d5a:	f0 e0       	ldi	r31, 0x00	; 0
     d5c:	bf 2e       	mov	r11, r31
     d5e:	f0 2d       	mov	r31, r0
			}
			
			for ( i=0;i<r;i++)
			{
				
				if(path1.path[t]==red_nodes[i])
     d60:	88 24       	eor	r8, r8
     d62:	99 24       	eor	r9, r9
 //forward();                              // start to move froward

 while(1)
 {
	 
	Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     d64:	83 e0       	ldi	r24, 0x03	; 3
     d66:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>
     d6a:	80 93 70 00 	sts	0x0070, r24
	Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
     d6e:	84 e0       	ldi	r24, 0x04	; 4
     d70:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>
     d74:	80 93 6f 00 	sts	0x006F, r24
	Right_white_line = ADC_Conversion(5);	//Getting data of Right WL Sensor
     d78:	85 e0       	ldi	r24, 0x05	; 5
     d7a:	0e 94 6c 05 	call	0xad8	; 0xad8 <ADC_Conversion>
     d7e:	80 93 6e 00 	sts	0x006E, r24
 
	

	//flag=0;

	if(Center_white_line<THRESHOLD && Left_white_line<THRESHOLD && Right_white_line<THRESHOLD)               // Is middle Whiteline is within threshold limit
     d82:	90 91 6f 00 	lds	r25, 0x006F
     d86:	94 31       	cpi	r25, 0x14	; 20
     d88:	68 f4       	brcc	.+26     	; 0xda4 <line_follower+0x88>
     d8a:	20 91 70 00 	lds	r18, 0x0070
     d8e:	24 31       	cpi	r18, 0x14	; 20
     d90:	48 f4       	brcc	.+18     	; 0xda4 <line_follower+0x88>
     d92:	84 31       	cpi	r24, 0x14	; 20
     d94:	38 f4       	brcc	.+14     	; 0xda4 <line_follower+0x88>
	{                                             
		//flag=1;                                                                                                  //c0,l0,r0  
		velocity(VELOCITY_MIN+2,VELOCITY_MIN+q+2);      // Run robot at max velocity 
     d96:	86 e1       	ldi	r24, 0x16	; 22
     d98:	6b e1       	ldi	r22, 0x1B	; 27
     d9a:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		//back();
		forward();
     d9e:	0e 94 81 05 	call	0xb02	; 0xb02 <forward>
     da2:	e0 cf       	rjmp	.-64     	; 0xd64 <line_follower+0x48>
		
		
	}
	else if(Center_white_line>THRESHOLD && Left_white_line<THRESHOLD && Right_white_line<THRESHOLD)               // Is middle Whiteline is within threshold limit
     da4:	95 31       	cpi	r25, 0x15	; 21
     da6:	68 f0       	brcs	.+26     	; 0xdc2 <line_follower+0xa6>
     da8:	20 91 70 00 	lds	r18, 0x0070
     dac:	24 31       	cpi	r18, 0x14	; 20
     dae:	48 f4       	brcc	.+18     	; 0xdc2 <line_follower+0xa6>
     db0:	84 31       	cpi	r24, 0x14	; 20
     db2:	38 f4       	brcc	.+14     	; 0xdc2 <line_follower+0xa6>
	{
		//flag=1;                                                                                                 //c1,l0,r0
		velocity(VELOCITY_MAX,VELOCITY_MAX+q);      // Run robot at max velocity
     db4:	8c e3       	ldi	r24, 0x3C	; 60
     db6:	61 e4       	ldi	r22, 0x41	; 65
     db8:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		forward();
     dbc:	0e 94 81 05 	call	0xb02	; 0xb02 <forward>
     dc0:	d1 cf       	rjmp	.-94     	; 0xd64 <line_follower+0x48>
		
	}


	
	else if(Center_white_line<THRESHOLD && Left_white_line<THRESHOLD && Right_white_line>THRESHOLD)  // Is left Whiteline is not within threshold limit
     dc2:	94 31       	cpi	r25, 0x14	; 20
     dc4:	68 f4       	brcc	.+26     	; 0xde0 <line_follower+0xc4>
     dc6:	20 91 70 00 	lds	r18, 0x0070
     dca:	24 31       	cpi	r18, 0x14	; 20
     dcc:	48 f4       	brcc	.+18     	; 0xde0 <line_follower+0xc4>
     dce:	85 31       	cpi	r24, 0x15	; 21
     dd0:	38 f0       	brcs	.+14     	; 0xde0 <line_follower+0xc4>
	{                                             
	    //	flag=1;                                                                                                     //c0,l0,r1
		velocity(VELOCITY_MAX,VELOCITY_MIN+q);      // Run robot left wheel at max velocity and right wheel 
     dd2:	8c e3       	ldi	r24, 0x3C	; 60
     dd4:	69 e1       	ldi	r22, 0x19	; 25
     dd6:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		right();
     dda:	0e 94 8d 05 	call	0xb1a	; 0xb1a <right>
     dde:	c2 cf       	rjmp	.-124    	; 0xd64 <line_follower+0x48>
		
	}
	
	else if(Center_white_line>THRESHOLD && Left_white_line<THRESHOLD && Right_white_line>THRESHOLD)  // Is left Whiteline is not within threshold limit
     de0:	95 31       	cpi	r25, 0x15	; 21
     de2:	68 f0       	brcs	.+26     	; 0xdfe <line_follower+0xe2>
     de4:	20 91 70 00 	lds	r18, 0x0070
     de8:	24 31       	cpi	r18, 0x14	; 20
     dea:	48 f4       	brcc	.+18     	; 0xdfe <line_follower+0xe2>
     dec:	85 31       	cpi	r24, 0x15	; 21
     dee:	38 f0       	brcs	.+14     	; 0xdfe <line_follower+0xe2>
	{                                                                                                                  //c1,l0,r1                 
		//	flag=1;
		velocity(VELOCITY_MAX,VELOCITY_MIN+q);      // Run robot left wheel at max velocity and right wheel
     df0:	8c e3       	ldi	r24, 0x3C	; 60
     df2:	69 e1       	ldi	r22, 0x19	; 25
     df4:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		S_R();
     df8:	0e 94 99 05 	call	0xb32	; 0xb32 <S_R>
     dfc:	b3 cf       	rjmp	.-154    	; 0xd64 <line_follower+0x48>
		
	}

	
	else if(Center_white_line<THRESHOLD && Left_white_line>THRESHOLD && Right_white_line<THRESHOLD ) // Is right Whiteline is not within threshold limit
     dfe:	94 31       	cpi	r25, 0x14	; 20
     e00:	68 f4       	brcc	.+26     	; 0xe1c <line_follower+0x100>
     e02:	20 91 70 00 	lds	r18, 0x0070
     e06:	25 31       	cpi	r18, 0x15	; 21
     e08:	48 f0       	brcs	.+18     	; 0xe1c <line_follower+0x100>
     e0a:	84 31       	cpi	r24, 0x14	; 20
     e0c:	38 f4       	brcc	.+14     	; 0xe1c <line_follower+0x100>
	{
		//flag=1;                                                                                                 //c0,l1,r0
		velocity(VELOCITY_MIN,VELOCITY_MAX+q);      // Run robot right wheel at max velocity and left wheel 
     e0e:	84 e1       	ldi	r24, 0x14	; 20
     e10:	61 e4       	ldi	r22, 0x41	; 65
     e12:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		s_L();
     e16:	0e 94 95 05 	call	0xb2a	; 0xb2a <s_L>
     e1a:	a4 cf       	rjmp	.-184    	; 0xd64 <line_follower+0x48>
		
	}
	else if(Center_white_line>THRESHOLD && Left_white_line>THRESHOLD && Right_white_line<THRESHOLD ) // Is right Whiteline is not within threshold limit
     e1c:	95 31       	cpi	r25, 0x15	; 21
     e1e:	08 f4       	brcc	.+2      	; 0xe22 <line_follower+0x106>
     e20:	a1 cf       	rjmp	.-190    	; 0xd64 <line_follower+0x48>
     e22:	90 91 70 00 	lds	r25, 0x0070
     e26:	95 31       	cpi	r25, 0x15	; 21
     e28:	08 f4       	brcc	.+2      	; 0xe2c <line_follower+0x110>
     e2a:	9c cf       	rjmp	.-200    	; 0xd64 <line_follower+0x48>
     e2c:	84 31       	cpi	r24, 0x14	; 20
     e2e:	08 f0       	brcs	.+2      	; 0xe32 <line_follower+0x116>
     e30:	b4 c0       	rjmp	.+360    	; 0xf9a <line_follower+0x27e>
	{                                                                                                             //c1,l1,r0
		//flag=1; 
		velocity(VELOCITY_MIN,VELOCITY_MAX+q);      // Run robot right wheel at max velocity and left wheel
     e32:	84 e1       	ldi	r24, 0x14	; 20
     e34:	61 e4       	ldi	r22, 0x41	; 65
     e36:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		left();
     e3a:	0e 94 89 05 	call	0xb12	; 0xb12 <left>
     e3e:	92 cf       	rjmp	.-220    	; 0xd64 <line_follower+0x48>
	                                // if all Whiteline sensor are not within threshold limit                      //c1,l1,r1   
	{                       
		//buzzer_beep();
		
		//stop_pos();
		velocity(VELOCITY_LOW,VELOCITY_LOW);
     e40:	80 e0       	ldi	r24, 0x00	; 0
     e42:	60 e0       	ldi	r22, 0x00	; 0
     e44:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
		hard_stop();
     e48:	0e 94 91 05 	call	0xb22	; 0xb22 <hard_stop>
		//	lcd_print(2,1,path1.path[l],3);
		//l++;
		
		if(stage==2)
     e4c:	80 91 65 00 	lds	r24, 0x0065
     e50:	82 30       	cpi	r24, 0x02	; 2
     e52:	21 f4       	brne	.+8      	; 0xe5c <line_follower+0x140>
		{
			servo100();
     e54:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <servo100>
			servo101();
     e58:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <servo101>
			//1000 1111
		}
		
		if(stage==3)
     e5c:	80 91 65 00 	lds	r24, 0x0065
     e60:	83 30       	cpi	r24, 0x03	; 3
     e62:	09 f0       	breq	.+2      	; 0xe66 <line_follower+0x14a>
     e64:	82 c0       	rjmp	.+260    	; 0xf6a <line_follower+0x24e>
		{	unsigned char count=0;
			unsigned char i;
			if(path1.path[t]==46 )
     e66:	80 91 76 00 	lds	r24, 0x0076
     e6a:	f6 01       	movw	r30, r12
     e6c:	e8 0f       	add	r30, r24
     e6e:	f1 1d       	adc	r31, r1
     e70:	80 81       	ld	r24, Z
     e72:	8e 32       	cpi	r24, 0x2E	; 46
     e74:	a1 f4       	brne	.+40     	; 0xe9e <line_follower+0x182>
			{
				init_devices_pos();
     e76:	0e 94 18 04 	call	0x830	; 0x830 <init_devices_pos>
				right_degrees(100);
     e7a:	84 e6       	ldi	r24, 0x64	; 100
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <right_degrees>
				stop_pos();
     e82:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
     e86:	8f ef       	ldi	r24, 0xFF	; 255
     e88:	9f e3       	ldi	r25, 0x3F	; 63
     e8a:	ab e0       	ldi	r26, 0x0B	; 11
     e8c:	81 50       	subi	r24, 0x01	; 1
     e8e:	90 40       	sbci	r25, 0x00	; 0
     e90:	a0 40       	sbci	r26, 0x00	; 0
     e92:	e1 f7       	brne	.-8      	; 0xe8c <line_follower+0x170>
     e94:	00 c0       	rjmp	.+0      	; 0xe96 <line_follower+0x17a>
     e96:	00 00       	nop
				_delay_ms(500);
				dir=1;
     e98:	e0 92 66 00 	sts	0x0066, r14
     e9c:	1a c0       	rjmp	.+52     	; 0xed2 <line_follower+0x1b6>
				
			}
			else if(path1.path[t]==2 )
     e9e:	82 30       	cpi	r24, 0x02	; 2
     ea0:	c1 f4       	brne	.+48     	; 0xed2 <line_follower+0x1b6>
			{
				
				init_devices_pos();
     ea2:	0e 94 18 04 	call	0x830	; 0x830 <init_devices_pos>
				
				if(des!=8)
     ea6:	80 91 67 00 	lds	r24, 0x0067
     eaa:	88 30       	cpi	r24, 0x08	; 8
     eac:	91 f0       	breq	.+36     	; 0xed2 <line_follower+0x1b6>
				{
					left_degrees(100);
     eae:	84 e6       	ldi	r24, 0x64	; 100
     eb0:	90 e0       	ldi	r25, 0x00	; 0
     eb2:	0e 94 ce 03 	call	0x79c	; 0x79c <left_degrees>
					stop_pos();
     eb6:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
     eba:	8f ef       	ldi	r24, 0xFF	; 255
     ebc:	9f e3       	ldi	r25, 0x3F	; 63
     ebe:	ab e0       	ldi	r26, 0x0B	; 11
     ec0:	81 50       	subi	r24, 0x01	; 1
     ec2:	90 40       	sbci	r25, 0x00	; 0
     ec4:	a0 40       	sbci	r26, 0x00	; 0
     ec6:	e1 f7       	brne	.-8      	; 0xec0 <line_follower+0x1a4>
     ec8:	00 c0       	rjmp	.+0      	; 0xeca <line_follower+0x1ae>
     eca:	00 00       	nop
					_delay_ms(500);
					dir=3;
     ecc:	83 e0       	ldi	r24, 0x03	; 3
     ece:	80 93 66 00 	sts	0x0066, r24
				}
				
				
			}
			
			for ( i=0;i<r;i++)
     ed2:	80 91 73 00 	lds	r24, 0x0073
     ed6:	88 23       	and	r24, r24
     ed8:	09 f4       	brne	.+2      	; 0xedc <line_follower+0x1c0>
     eda:	5d c0       	rjmp	.+186    	; 0xf96 <line_follower+0x27a>
			{
				
				if(path1.path[t]==red_nodes[i])
     edc:	80 91 76 00 	lds	r24, 0x0076
     ee0:	f6 01       	movw	r30, r12
     ee2:	e8 0f       	add	r30, r24
     ee4:	f1 1d       	adc	r31, r1
     ee6:	20 81       	ld	r18, Z
     ee8:	d8 01       	movw	r26, r16
     eea:	8c 91       	ld	r24, X
     eec:	28 17       	cp	r18, r24
     eee:	59 f0       	breq	.+22     	; 0xf06 <line_follower+0x1ea>
				}
				
				
			}
			
			for ( i=0;i<r;i++)
     ef0:	c0 e0       	ldi	r28, 0x00	; 0
     ef2:	1c c0       	rjmp	.+56     	; 0xf2c <line_follower+0x210>
			{
				
				if(path1.path[t]==red_nodes[i])
     ef4:	8c 2f       	mov	r24, r28
     ef6:	90 e0       	ldi	r25, 0x00	; 0
     ef8:	f8 01       	movw	r30, r16
     efa:	e8 0f       	add	r30, r24
     efc:	f9 1f       	adc	r31, r25
     efe:	30 81       	ld	r19, Z
     f00:	23 17       	cp	r18, r19
     f02:	a1 f4       	brne	.+40     	; 0xf2c <line_follower+0x210>
     f04:	02 c0       	rjmp	.+4      	; 0xf0a <line_follower+0x1ee>
     f06:	c4 01       	movw	r24, r8
				}
				
				
			}
			
			for ( i=0;i<r;i++)
     f08:	c0 e0       	ldi	r28, 0x00	; 0
			{
				
				if(path1.path[t]==red_nodes[i])
				{
					if (path1.path[t]==red_nodes[i+1])
     f0a:	fc 01       	movw	r30, r24
     f0c:	31 96       	adiw	r30, 0x01	; 1
     f0e:	e0 0f       	add	r30, r16
     f10:	f1 1f       	adc	r31, r17
     f12:	80 81       	ld	r24, Z
			servo101();
			//1000 1111
		}
		
		if(stage==3)
		{	unsigned char count=0;
     f14:	fe 2c       	mov	r15, r14
     f16:	28 13       	cpse	r18, r24
     f18:	ff 24       	eor	r15, r15
					}
					count++;
					break;
				}
			}
			if (count>0)
     f1a:	f3 94       	inc	r15
			{buzzer_beep();
     f1c:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_beep>
				buzzer_beep();
     f20:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_beep>
				
			}
			if(count==1)
     f24:	b1 e0       	ldi	r27, 0x01	; 1
     f26:	fb 16       	cp	r15, r27
     f28:	41 f0       	breq	.+16     	; 0xf3a <line_follower+0x21e>
     f2a:	18 c0       	rjmp	.+48     	; 0xf5c <line_follower+0x240>
				}
				
				
			}
			
			for ( i=0;i<r;i++)
     f2c:	cf 5f       	subi	r28, 0xFF	; 255
     f2e:	80 91 73 00 	lds	r24, 0x0073
     f32:	c8 17       	cp	r28, r24
     f34:	f8 f2       	brcs	.-66     	; 0xef4 <line_follower+0x1d8>
     f36:	ff 24       	eor	r15, r15
     f38:	11 c0       	rjmp	.+34     	; 0xf5c <line_follower+0x240>
				buzzer_beep();
				
			}
			if(count==1)
			{
				if(red_side[i]==100)
     f3a:	d0 e0       	ldi	r29, 0x00	; 0
     f3c:	f5 01       	movw	r30, r10
     f3e:	ec 0f       	add	r30, r28
     f40:	fd 1f       	adc	r31, r29
     f42:	80 81       	ld	r24, Z
     f44:	84 36       	cpi	r24, 0x64	; 100
     f46:	19 f4       	brne	.+6      	; 0xf4e <line_follower+0x232>
				{
					servo100();
     f48:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <servo100>
     f4c:	0e c0       	rjmp	.+28     	; 0xf6a <line_follower+0x24e>
				}
				else if(red_side[i]==101)
     f4e:	ca 0d       	add	r28, r10
     f50:	db 1d       	adc	r29, r11
     f52:	88 81       	ld	r24, Y
     f54:	85 36       	cpi	r24, 0x65	; 101
     f56:	11 f4       	brne	.+4      	; 0xf5c <line_follower+0x240>
				{
					servo101();
     f58:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <servo101>
				}
				
			}
			if(count==2)
     f5c:	e2 e0       	ldi	r30, 0x02	; 2
     f5e:	fe 16       	cp	r15, r30
     f60:	21 f4       	brne	.+8      	; 0xf6a <line_follower+0x24e>
			{
				servo100();
     f62:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <servo100>
				servo101();
     f66:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <servo101>
			}
			count=0;
		}
		
		init_devices();
     f6a:	0e 94 85 06 	call	0xd0a	; 0xd0a <init_devices>
		direction();
     f6e:	0e 94 45 0a 	call	0x148a	; 0x148a <direction>
		if (g==1)
     f72:	80 91 81 00 	lds	r24, 0x0081
     f76:	81 30       	cpi	r24, 0x01	; 1
     f78:	09 f0       	breq	.+2      	; 0xf7c <line_follower+0x260>
     f7a:	f4 ce       	rjmp	.-536    	; 0xd64 <line_follower+0x48>
		
	}
	

 }
}
     f7c:	df 91       	pop	r29
     f7e:	cf 91       	pop	r28
     f80:	1f 91       	pop	r17
     f82:	0f 91       	pop	r16
     f84:	ff 90       	pop	r15
     f86:	ef 90       	pop	r14
     f88:	df 90       	pop	r13
     f8a:	cf 90       	pop	r12
     f8c:	bf 90       	pop	r11
     f8e:	af 90       	pop	r10
     f90:	9f 90       	pop	r9
     f92:	8f 90       	pop	r8
     f94:	08 95       	ret
				}
				
				
			}
			
			for ( i=0;i<r;i++)
     f96:	ff 24       	eor	r15, r15
     f98:	e1 cf       	rjmp	.-62     	; 0xf5c <line_follower+0x240>
		velocity(VELOCITY_MIN,VELOCITY_MAX+q);      // Run robot right wheel at max velocity and left wheel
		left();
		
	}
                
	else if(Center_white_line>THRESHOLD && Left_white_line>THRESHOLD && Right_white_line>THRESHOLD)
     f9a:	85 31       	cpi	r24, 0x15	; 21
     f9c:	08 f0       	brcs	.+2      	; 0xfa0 <line_follower+0x284>
     f9e:	50 cf       	rjmp	.-352    	; 0xe40 <line_follower+0x124>
     fa0:	e1 ce       	rjmp	.-574    	; 0xd64 <line_follower+0x48>

00000fa2 <color_sensor_pin_config>:
Blue_led pc6
*/

void color_sensor_pin_config(void)
{
	DDRD  = DDRD & 0xBF;  //Set the direction of the PORTD 6 pin as input 1011 1111
     fa2:	8e 98       	cbi	0x11, 6	; 17
	PORTD = PORTD | 0x40; //pullup pd6 0100 0000
     fa4:	96 9a       	sbi	0x12, 6	; 18
}
     fa6:	08 95       	ret

00000fa8 <port_init_color>:
void port_init_color(void)
{
	
	color_sensor_pin_config();//color sensor pin configuration
     fa8:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <color_sensor_pin_config>
}
     fac:	08 95       	ret

00000fae <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
     fae:	f8 94       	cli
	//EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
	TCCR1A=0;
     fb0:	1f bc       	out	0x2f, r1	; 47
	TCCR1B=0x81;//falling edge,noise cancel, no prescale
     fb2:	81 e8       	ldi	r24, 0x81	; 129
     fb4:	8e bd       	out	0x2e, r24	; 46
	TIMSK=(1<<TICIE1);//ip capt and  NO overflow interrupt
     fb6:	80 e2       	ldi	r24, 0x20	; 32
     fb8:	89 bf       	out	0x39, r24	; 57
	//EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
	sei(); // Enables the global interrupt
     fba:	78 94       	sei
}
     fbc:	08 95       	ret

00000fbe <__vector_5>:
ISR(TIMER1_CAPT_vect)
{
     fbe:	1f 92       	push	r1
     fc0:	0f 92       	push	r0
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	0f 92       	push	r0
     fc6:	11 24       	eor	r1, r1
     fc8:	8f 93       	push	r24
     fca:	9f 93       	push	r25
     fcc:	af 93       	push	r26
     fce:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     fd0:	80 91 6a 00 	lds	r24, 0x006A
     fd4:	90 91 6b 00 	lds	r25, 0x006B
     fd8:	a0 91 6c 00 	lds	r26, 0x006C
     fdc:	b0 91 6d 00 	lds	r27, 0x006D
     fe0:	01 96       	adiw	r24, 0x01	; 1
     fe2:	a1 1d       	adc	r26, r1
     fe4:	b1 1d       	adc	r27, r1
     fe6:	80 93 6a 00 	sts	0x006A, r24
     fea:	90 93 6b 00 	sts	0x006B, r25
     fee:	a0 93 6c 00 	sts	0x006C, r26
     ff2:	b0 93 6d 00 	sts	0x006D, r27
}
     ff6:	bf 91       	pop	r27
     ff8:	af 91       	pop	r26
     ffa:	9f 91       	pop	r25
     ffc:	8f 91       	pop	r24
     ffe:	0f 90       	pop	r0
    1000:	0f be       	out	0x3f, r0	; 63
    1002:	0f 90       	pop	r0
    1004:	1f 90       	pop	r1
    1006:	18 95       	reti

00001008 <init_devices_color>:
void init_devices_color(void)
{
	cli(); //Clears the global interrupt
    1008:	f8 94       	cli
	port_init_color();  //Initializes all the ports
    100a:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <port_init_color>
	color_sensor_pin_interrupt_init();
    100e:	0e 94 d7 07 	call	0xfae	; 0xfae <color_sensor_pin_interrupt_init>
	sei();   // Enables the global interrupt
    1012:	78 94       	sei
}
    1014:	08 95       	ret

00001016 <filter_red>:
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	/*PORTC= PORTC & 0xFE; //set S2 low
	PORTC = PORTC & 0xF7; //set S37F lowpd2*/
	PORTC= PORTC & 0xFB; //set S2 low 1111 1011
    1016:	aa 98       	cbi	0x15, 2	; 21
	PORTC = PORTC & 0x7F; //set S37F lowpd2 0111 1111
    1018:	af 98       	cbi	0x15, 7	; 21
}
    101a:	08 95       	ret

0000101c <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	
	PORTC = PORTC | 0x04; //set S2 High 0000 0100
    101c:	aa 9a       	sbi	0x15, 2	; 21
	PORTC = PORTC | 0x80; //set S3 High 1000 0000
    101e:	af 9a       	sbi	0x15, 7	; 21
}
    1020:	08 95       	ret

00001022 <filter_blue>:
void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	/*PORTD = PORTD & 0xF7; //set S2 low
	PORTD = PORTD | 0x04; //set S3 High*/
	PORTC= PORTC & 0xFB; //set S2 low 1111 1011
    1022:	aa 98       	cbi	0x15, 2	; 21
	PORTC = PORTC | 0x80; //set S3 High 1000 0000
    1024:	af 9a       	sbi	0x15, 7	; 21
}
    1026:	08 95       	ret

00001028 <filter_clear>:
void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	/*PORTD = PORTD | 0x08; //set S2 High
	PORTD = PORTD & 0xFB; //set S3 Low*/
	PORTC = PORTC | 0x04;  //set S2 High 0000 0100
    1028:	aa 9a       	sbi	0x15, 2	; 21
	PORTC = PORTC & 0x7F; //set S3 Low 0111 1111
    102a:	af 98       	cbi	0x15, 7	; 21
}
    102c:	08 95       	ret

0000102e <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xFE;
	PORTC = PORTC | 0x01; //set S0 high 0000 0001
    102e:	a8 9a       	sbi	0x15, 0	; 21
	PORTC = PORTC & 0xFD; //set S1 low 1111 1101
    1030:	a9 98       	cbi	0x15, 1	; 21
	//PORTD = PORTD | 0x02; //set S1 high 
}
    1032:	08 95       	ret

00001034 <red_read>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
    1034:	0e 94 0b 08 	call	0x1016	; 0x1016 <filter_red>
	pulse=0; //reset the count to 0
    1038:	10 92 6a 00 	sts	0x006A, r1
    103c:	10 92 6b 00 	sts	0x006B, r1
    1040:	10 92 6c 00 	sts	0x006C, r1
    1044:	10 92 6d 00 	sts	0x006D, r1
    1048:	8f ef       	ldi	r24, 0xFF	; 255
    104a:	9f e3       	ldi	r25, 0x3F	; 63
    104c:	a2 e0       	ldi	r26, 0x02	; 2
    104e:	81 50       	subi	r24, 0x01	; 1
    1050:	90 40       	sbci	r25, 0x00	; 0
    1052:	a0 40       	sbci	r26, 0x00	; 0
    1054:	e1 f7       	brne	.-8      	; 0x104e <red_read+0x1a>
    1056:	00 c0       	rjmp	.+0      	; 0x1058 <red_read+0x24>
    1058:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
    105a:	80 91 6a 00 	lds	r24, 0x006A
    105e:	90 91 6b 00 	lds	r25, 0x006B
    1062:	a0 91 6c 00 	lds	r26, 0x006C
    1066:	b0 91 6d 00 	lds	r27, 0x006D
    106a:	80 93 c4 00 	sts	0x00C4, r24
    106e:	90 93 c5 00 	sts	0x00C5, r25
    1072:	a0 93 c6 00 	sts	0x00C6, r26
    1076:	b0 93 c7 00 	sts	0x00C7, r27
	lcd_string("Red Pulses"); // Display "Red Pulses" on LCD
	lcd_print(2,1,red,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD
	*/
}
    107a:	08 95       	ret

0000107c <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
    107c:	0e 94 0e 08 	call	0x101c	; 0x101c <filter_green>
	pulse=0; //reset the count to 0
    1080:	10 92 6a 00 	sts	0x006A, r1
    1084:	10 92 6b 00 	sts	0x006B, r1
    1088:	10 92 6c 00 	sts	0x006C, r1
    108c:	10 92 6d 00 	sts	0x006D, r1
    1090:	8f ef       	ldi	r24, 0xFF	; 255
    1092:	9f e3       	ldi	r25, 0x3F	; 63
    1094:	a2 e0       	ldi	r26, 0x02	; 2
    1096:	81 50       	subi	r24, 0x01	; 1
    1098:	90 40       	sbci	r25, 0x00	; 0
    109a:	a0 40       	sbci	r26, 0x00	; 0
    109c:	e1 f7       	brne	.-8      	; 0x1096 <green_read+0x1a>
    109e:	00 c0       	rjmp	.+0      	; 0x10a0 <green_read+0x24>
    10a0:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
    10a2:	80 91 6a 00 	lds	r24, 0x006A
    10a6:	90 91 6b 00 	lds	r25, 0x006B
    10aa:	a0 91 6c 00 	lds	r26, 0x006C
    10ae:	b0 91 6d 00 	lds	r27, 0x006D
    10b2:	80 93 c0 00 	sts	0x00C0, r24
    10b6:	90 93 c1 00 	sts	0x00C1, r25
    10ba:	a0 93 c2 00 	sts	0x00C2, r26
    10be:	b0 93 c3 00 	sts	0x00C3, r27
	lcd_string("Green Pulses"); // Display "Green Pulses" on LCD
	lcd_print(2,1,green,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD

*/}
    10c2:	08 95       	ret

000010c4 <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
    10c4:	0e 94 11 08 	call	0x1022	; 0x1022 <filter_blue>
	pulse=0; //reset the count to 0
    10c8:	10 92 6a 00 	sts	0x006A, r1
    10cc:	10 92 6b 00 	sts	0x006B, r1
    10d0:	10 92 6c 00 	sts	0x006C, r1
    10d4:	10 92 6d 00 	sts	0x006D, r1
    10d8:	8f ef       	ldi	r24, 0xFF	; 255
    10da:	9f e3       	ldi	r25, 0x3F	; 63
    10dc:	a2 e0       	ldi	r26, 0x02	; 2
    10de:	81 50       	subi	r24, 0x01	; 1
    10e0:	90 40       	sbci	r25, 0x00	; 0
    10e2:	a0 40       	sbci	r26, 0x00	; 0
    10e4:	e1 f7       	brne	.-8      	; 0x10de <blue_read+0x1a>
    10e6:	00 c0       	rjmp	.+0      	; 0x10e8 <blue_read+0x24>
    10e8:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
    10ea:	80 91 6a 00 	lds	r24, 0x006A
    10ee:	90 91 6b 00 	lds	r25, 0x006B
    10f2:	a0 91 6c 00 	lds	r26, 0x006C
    10f6:	b0 91 6d 00 	lds	r27, 0x006D
    10fa:	80 93 9a 00 	sts	0x009A, r24
    10fe:	90 93 9b 00 	sts	0x009B, r25
    1102:	a0 93 9c 00 	sts	0x009C, r26
    1106:	b0 93 9d 00 	sts	0x009D, r27
	lcd_string("Blue Pulses"); // Display "Blue Pulses" on LCD
	lcd_print(2,1,blue,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD
	*/
}
    110a:	08 95       	ret

0000110c <colour>:
void colour(unsigned long int red_pulse, unsigned long int green_pulse,unsigned long int blue_pulse)
{	
    110c:	8f 92       	push	r8
    110e:	9f 92       	push	r9
    1110:	af 92       	push	r10
    1112:	bf 92       	push	r11
    1114:	ef 92       	push	r14
    1116:	ff 92       	push	r15
    1118:	0f 93       	push	r16
    111a:	1f 93       	push	r17
    111c:	4b 01       	movw	r8, r22
    111e:	5c 01       	movw	r10, r24
    1120:	da 01       	movw	r26, r20
    1122:	c9 01       	movw	r24, r18
    1124:	b8 01       	movw	r22, r16
    1126:	a7 01       	movw	r20, r14
	if(red_pulse>green_pulse && red_pulse>blue_pulse)
    1128:	88 15       	cp	r24, r8
    112a:	99 05       	cpc	r25, r9
    112c:	aa 05       	cpc	r26, r10
    112e:	bb 05       	cpc	r27, r11
    1130:	68 f4       	brcc	.+26     	; 0x114c <colour+0x40>
    1132:	e8 14       	cp	r14, r8
    1134:	f9 04       	cpc	r15, r9
    1136:	0a 05       	cpc	r16, r10
    1138:	1b 05       	cpc	r17, r11
    113a:	40 f4       	brcc	.+16     	; 0x114c <colour+0x40>
	{
		//red greatest
		PORTC=PORTC|(1<<PC4);
    113c:	ac 9a       	sbi	0x15, 4	; 21
		PORTC=PORTC & 0x9F; //clear pc5 and pc6 1001 1111
    113e:	85 b3       	in	r24, 0x15	; 21
    1140:	8f 79       	andi	r24, 0x9F	; 159
    1142:	85 bb       	out	0x15, r24	; 21
		task=1;
    1144:	81 e0       	ldi	r24, 0x01	; 1
    1146:	80 93 75 00 	sts	0x0075, r24
    114a:	14 c0       	rjmp	.+40     	; 0x1174 <colour+0x68>
	}
	else if(green_pulse>blue_pulse)
    114c:	48 17       	cp	r20, r24
    114e:	59 07       	cpc	r21, r25
    1150:	6a 07       	cpc	r22, r26
    1152:	7b 07       	cpc	r23, r27
    1154:	40 f4       	brcc	.+16     	; 0x1166 <colour+0x5a>
	{
		//green greatest
		PORTC=PORTC|(1<<PC5);
    1156:	ad 9a       	sbi	0x15, 5	; 21
		PORTC=PORTC & 0xAF; //clear pc4 and pc6 1010 1111
    1158:	85 b3       	in	r24, 0x15	; 21
    115a:	8f 7a       	andi	r24, 0xAF	; 175
    115c:	85 bb       	out	0x15, r24	; 21
		task=2;
    115e:	82 e0       	ldi	r24, 0x02	; 2
    1160:	80 93 75 00 	sts	0x0075, r24
    1164:	07 c0       	rjmp	.+14     	; 0x1174 <colour+0x68>
		
	}
	else
	{
		//blue greatest
		PORTC=PORTC|(1<<PC6);
    1166:	ae 9a       	sbi	0x15, 6	; 21
		PORTC=PORTC & 0xCF; //clear pc5 and pc4 1100 1111
    1168:	85 b3       	in	r24, 0x15	; 21
    116a:	8f 7c       	andi	r24, 0xCF	; 207
    116c:	85 bb       	out	0x15, r24	; 21
		task=3;
    116e:	83 e0       	ldi	r24, 0x03	; 3
    1170:	80 93 75 00 	sts	0x0075, r24
	}
}
    1174:	1f 91       	pop	r17
    1176:	0f 91       	pop	r16
    1178:	ff 90       	pop	r15
    117a:	ef 90       	pop	r14
    117c:	bf 90       	pop	r11
    117e:	af 90       	pop	r10
    1180:	9f 90       	pop	r9
    1182:	8f 90       	pop	r8
    1184:	08 95       	ret

00001186 <color_sensor_work>:


void color_sensor_work()
{	
    1186:	ef 92       	push	r14
    1188:	ff 92       	push	r15
    118a:	0f 93       	push	r16
    118c:	1f 93       	push	r17
    118e:	cf 93       	push	r28
    1190:	df 93       	push	r29
	
	init_devices_color();
    1192:	0e 94 04 08 	call	0x1008	; 0x1008 <init_devices_color>
	DDRC = DDRC | 0xFF;//port c pins as output 
    1196:	84 b3       	in	r24, 0x14	; 20
    1198:	8f ef       	ldi	r24, 0xFF	; 255
    119a:	84 bb       	out	0x14, r24	; 20
	PORTC=0x00;
    119c:	15 ba       	out	0x15, r1	; 21
	color_sensor_scaling();
    119e:	0e 94 17 08 	call	0x102e	; 0x102e <color_sensor_scaling>
	if(stage==2)
    11a2:	80 91 65 00 	lds	r24, 0x0065
    11a6:	82 30       	cpi	r24, 0x02	; 2
    11a8:	71 f5       	brne	.+92     	; 0x1206 <color_sensor_work+0x80>
    11aa:	c5 e0       	ldi	r28, 0x05	; 5
    11ac:	d0 e0       	ldi	r29, 0x00	; 0
	{
		for (int i=0;i<5;i++)
		{
			red_read(); //display the pulse count when red filter is selected
    11ae:	0e 94 1a 08 	call	0x1034	; 0x1034 <red_read>
			//_delay_ms(500);
			green_read(); //display the pulse count when green filter is selected
    11b2:	0e 94 3e 08 	call	0x107c	; 0x107c <green_read>
			//_delay_ms(500);
			blue_read(); //display the pulse count when blue filter is selected
    11b6:	0e 94 62 08 	call	0x10c4	; 0x10c4 <blue_read>
			//_delay_ms(500);
			colour(red,green,blue);
    11ba:	60 91 c4 00 	lds	r22, 0x00C4
    11be:	70 91 c5 00 	lds	r23, 0x00C5
    11c2:	80 91 c6 00 	lds	r24, 0x00C6
    11c6:	90 91 c7 00 	lds	r25, 0x00C7
    11ca:	20 91 c0 00 	lds	r18, 0x00C0
    11ce:	30 91 c1 00 	lds	r19, 0x00C1
    11d2:	40 91 c2 00 	lds	r20, 0x00C2
    11d6:	50 91 c3 00 	lds	r21, 0x00C3
    11da:	e0 90 9a 00 	lds	r14, 0x009A
    11de:	f0 90 9b 00 	lds	r15, 0x009B
    11e2:	00 91 9c 00 	lds	r16, 0x009C
    11e6:	10 91 9d 00 	lds	r17, 0x009D
    11ea:	0e 94 86 08 	call	0x110c	; 0x110c <colour>
    11ee:	8f ef       	ldi	r24, 0xFF	; 255
    11f0:	9f e3       	ldi	r25, 0x3F	; 63
    11f2:	ab e0       	ldi	r26, 0x0B	; 11
    11f4:	81 50       	subi	r24, 0x01	; 1
    11f6:	90 40       	sbci	r25, 0x00	; 0
    11f8:	a0 40       	sbci	r26, 0x00	; 0
    11fa:	e1 f7       	brne	.-8      	; 0x11f4 <color_sensor_work+0x6e>
    11fc:	00 c0       	rjmp	.+0      	; 0x11fe <color_sensor_work+0x78>
    11fe:	00 00       	nop
    1200:	21 97       	sbiw	r28, 0x01	; 1
	DDRC = DDRC | 0xFF;//port c pins as output 
	PORTC=0x00;
	color_sensor_scaling();
	if(stage==2)
	{
		for (int i=0;i<5;i++)
    1202:	a9 f6       	brne	.-86     	; 0x11ae <color_sensor_work+0x28>
    1204:	10 c0       	rjmp	.+32     	; 0x1226 <color_sensor_work+0xa0>
		}
		
	}
	else
	{	//red greatest
		PORTC=PORTC|(1<<PC4);
    1206:	ac 9a       	sbi	0x15, 4	; 21
		PORTC=PORTC & 0x9F; //clear pc5 and pc6 1001 1111
    1208:	85 b3       	in	r24, 0x15	; 21
    120a:	8f 79       	andi	r24, 0x9F	; 159
    120c:	85 bb       	out	0x15, r24	; 21
		task=1;
    120e:	81 e0       	ldi	r24, 0x01	; 1
    1210:	80 93 75 00 	sts	0x0075, r24
    1214:	8f ef       	ldi	r24, 0xFF	; 255
    1216:	9f e3       	ldi	r25, 0x3F	; 63
    1218:	ab e0       	ldi	r26, 0x0B	; 11
    121a:	81 50       	subi	r24, 0x01	; 1
    121c:	90 40       	sbci	r25, 0x00	; 0
    121e:	a0 40       	sbci	r26, 0x00	; 0
    1220:	e1 f7       	brne	.-8      	; 0x121a <color_sensor_work+0x94>
    1222:	00 c0       	rjmp	.+0      	; 0x1224 <color_sensor_work+0x9e>
    1224:	00 00       	nop
		_delay_ms(500);
	}	
	//PORTC=PORTC& 0x8F;//1000 1111
    1226:	df 91       	pop	r29
    1228:	cf 91       	pop	r28
    122a:	1f 91       	pop	r17
    122c:	0f 91       	pop	r16
    122e:	ff 90       	pop	r15
    1230:	ef 90       	pop	r14
    1232:	08 95       	ret

00001234 <buzzer_pin_config_zigbee>:
}
*/

void buzzer_pin_config_zigbee (void)
{
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as outpt
    1234:	a3 9a       	sbi	0x14, 3	; 20
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
    1236:	ab 98       	cbi	0x15, 3	; 21
}
    1238:	08 95       	ret

0000123a <port_init_zigbee>:

//Function to initialize ports
void port_init_zigbee()
{
 //motion_pin_config();
 buzzer_pin_config_zigbee();
    123a:	0e 94 1a 09 	call	0x1234	; 0x1234 <buzzer_pin_config_zigbee>
}
    123e:	08 95       	ret

00001240 <uart0_init_zigbee>:
// actual: baud rate:9600 (0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init_zigbee(void)
{
 UCSRB = 0x00; //disable while setting baud rate
    1240:	1a b8       	out	0x0a, r1	; 10
 UCSRA = 0x00;
    1242:	1b b8       	out	0x0b, r1	; 11
 UCSRC = 0x86;
    1244:	86 e8       	ldi	r24, 0x86	; 134
    1246:	80 bd       	out	0x20, r24	; 32
 UBRRL = 0x2F; //set baud rate lo  //67 is for 16MHz 9600 baudrate
    1248:	8f e2       	ldi	r24, 0x2F	; 47
    124a:	89 b9       	out	0x09, r24	; 9
 UBRRH = 0x00; //set baud rate hi
    124c:	10 bc       	out	0x20, r1	; 32
 UCSRB = 0x98; 
    124e:	88 e9       	ldi	r24, 0x98	; 152
    1250:	8a b9       	out	0x0a, r24	; 10
}
    1252:	08 95       	ret

00001254 <conversion>:
unsigned char conversion(unsigned char hex)
{	unsigned char node;	
	
	switch(hex)
    1254:	89 31       	cpi	r24, 0x19	; 25
    1256:	e9 f1       	breq	.+122    	; 0x12d2 <conversion+0x7e>
    1258:	8a 31       	cpi	r24, 0x1A	; 26
    125a:	90 f4       	brcc	.+36     	; 0x1280 <conversion+0x2c>
    125c:	8b 30       	cpi	r24, 0x0B	; 11
    125e:	a9 f1       	breq	.+106    	; 0x12ca <conversion+0x76>
    1260:	8c 30       	cpi	r24, 0x0C	; 12
    1262:	38 f4       	brcc	.+14     	; 0x1272 <conversion+0x1e>
    1264:	84 30       	cpi	r24, 0x04	; 4
    1266:	79 f1       	breq	.+94     	; 0x12c6 <conversion+0x72>
    1268:	89 30       	cpi	r24, 0x09	; 9
    126a:	09 f1       	breq	.+66     	; 0x12ae <conversion+0x5a>
    126c:	82 30       	cpi	r24, 0x02	; 2
    126e:	f1 f5       	brne	.+124    	; 0x12ec <conversion+0x98>
    1270:	3c c0       	rjmp	.+120    	; 0x12ea <conversion+0x96>
    1272:	82 31       	cpi	r24, 0x12	; 18
    1274:	61 f1       	breq	.+88     	; 0x12ce <conversion+0x7a>
    1276:	87 31       	cpi	r24, 0x17	; 23
    1278:	f1 f0       	breq	.+60     	; 0x12b6 <conversion+0x62>
    127a:	80 31       	cpi	r24, 0x10	; 16
    127c:	b9 f5       	brne	.+110    	; 0x12ec <conversion+0x98>
    127e:	19 c0       	rjmp	.+50     	; 0x12b2 <conversion+0x5e>
    1280:	87 32       	cpi	r24, 0x27	; 39
    1282:	59 f1       	breq	.+86     	; 0x12da <conversion+0x86>
    1284:	88 32       	cpi	r24, 0x28	; 40
    1286:	38 f4       	brcc	.+14     	; 0x1296 <conversion+0x42>
    1288:	80 32       	cpi	r24, 0x20	; 32
    128a:	29 f1       	breq	.+74     	; 0x12d6 <conversion+0x82>
    128c:	85 32       	cpi	r24, 0x25	; 37
    128e:	b9 f0       	breq	.+46     	; 0x12be <conversion+0x6a>
    1290:	8e 31       	cpi	r24, 0x1E	; 30
    1292:	61 f5       	brne	.+88     	; 0x12ec <conversion+0x98>
    1294:	12 c0       	rjmp	.+36     	; 0x12ba <conversion+0x66>
    1296:	8e 32       	cpi	r24, 0x2E	; 46
    1298:	11 f1       	breq	.+68     	; 0x12de <conversion+0x8a>
    129a:	8f 32       	cpi	r24, 0x2F	; 47
    129c:	18 f4       	brcc	.+6      	; 0x12a4 <conversion+0x50>
    129e:	8c 32       	cpi	r24, 0x2C	; 44
    12a0:	29 f5       	brne	.+74     	; 0x12ec <conversion+0x98>
    12a2:	0f c0       	rjmp	.+30     	; 0x12c2 <conversion+0x6e>
    12a4:	84 36       	cpi	r24, 0x64	; 100
    12a6:	e9 f0       	breq	.+58     	; 0x12e2 <conversion+0x8e>
    12a8:	85 36       	cpi	r24, 0x65	; 101
    12aa:	01 f5       	brne	.+64     	; 0x12ec <conversion+0x98>
    12ac:	1c c0       	rjmp	.+56     	; 0x12e6 <conversion+0x92>
	{
		case 0x02:
		node=2;
		break;
		case 0x09:
		node=9;
    12ae:	99 e0       	ldi	r25, 0x09	; 9
		break;
    12b0:	1d c0       	rjmp	.+58     	; 0x12ec <conversion+0x98>
		case 0x10:
		node=16;
    12b2:	90 e1       	ldi	r25, 0x10	; 16
		break;
    12b4:	1b c0       	rjmp	.+54     	; 0x12ec <conversion+0x98>
		case 0x17:
		node=23;
    12b6:	97 e1       	ldi	r25, 0x17	; 23
		break;
    12b8:	19 c0       	rjmp	.+50     	; 0x12ec <conversion+0x98>
		case 0x1E:
		node=30;
    12ba:	9e e1       	ldi	r25, 0x1E	; 30
		break;
    12bc:	17 c0       	rjmp	.+46     	; 0x12ec <conversion+0x98>
		case 0x25:
		node=37;
    12be:	95 e2       	ldi	r25, 0x25	; 37
		break;
    12c0:	15 c0       	rjmp	.+42     	; 0x12ec <conversion+0x98>
		case 0x2C:
		node=44;
    12c2:	9c e2       	ldi	r25, 0x2C	; 44
		break;
    12c4:	13 c0       	rjmp	.+38     	; 0x12ec <conversion+0x98>
		
		case 0x04:
		node=4;
    12c6:	94 e0       	ldi	r25, 0x04	; 4
		break;
    12c8:	11 c0       	rjmp	.+34     	; 0x12ec <conversion+0x98>
		case 0x0B:
		node=11;
    12ca:	9b e0       	ldi	r25, 0x0B	; 11
		break;
    12cc:	0f c0       	rjmp	.+30     	; 0x12ec <conversion+0x98>
		case 0x12:
		node=18;
    12ce:	92 e1       	ldi	r25, 0x12	; 18
		break;
    12d0:	0d c0       	rjmp	.+26     	; 0x12ec <conversion+0x98>
		case 0x19:
		node=25;
    12d2:	99 e1       	ldi	r25, 0x19	; 25
		break;
    12d4:	0b c0       	rjmp	.+22     	; 0x12ec <conversion+0x98>
		case 0x20:
		node=32;
    12d6:	90 e2       	ldi	r25, 0x20	; 32
		break;
    12d8:	09 c0       	rjmp	.+18     	; 0x12ec <conversion+0x98>
		case 0x27:
		node=39;
    12da:	97 e2       	ldi	r25, 0x27	; 39
		break;
    12dc:	07 c0       	rjmp	.+14     	; 0x12ec <conversion+0x98>
		case 0x2E:
		node=46;
    12de:	9e e2       	ldi	r25, 0x2E	; 46
		break;
    12e0:	05 c0       	rjmp	.+10     	; 0x12ec <conversion+0x98>
		
		case 0x64:
		node=100;
    12e2:	94 e6       	ldi	r25, 0x64	; 100
		break;
    12e4:	03 c0       	rjmp	.+6      	; 0x12ec <conversion+0x98>
		case 0x65:
		node=101;
    12e6:	95 e6       	ldi	r25, 0x65	; 101
		break;
    12e8:	01 c0       	rjmp	.+2      	; 0x12ec <conversion+0x98>
{	unsigned char node;	
	
	switch(hex)
	{
		case 0x02:
		node=2;
    12ea:	92 e0       	ldi	r25, 0x02	; 2
		break;
			
	}
	
	return node;
}
    12ec:	89 2f       	mov	r24, r25
    12ee:	08 95       	ret

000012f0 <buzzer_on_zigbee>:
}*/

void buzzer_on_zigbee (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
    12f0:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore | 0x08;
    12f2:	88 60       	ori	r24, 0x08	; 8
 PORTC = port_restore;
    12f4:	85 bb       	out	0x15, r24	; 21
}
    12f6:	08 95       	ret

000012f8 <buzzer_off_zigbee>:

void buzzer_off_zigbee (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
    12f8:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore & 0xF7;
    12fa:	87 7f       	andi	r24, 0xF7	; 247
 PORTC = port_restore;
    12fc:	85 bb       	out	0x15, r24	; 21
}
    12fe:	08 95       	ret

00001300 <init_devices_zigbee>:

void init_devices_zigbee (void)
{
 cli();         //Clears the global interrupts
    1300:	f8 94       	cli
 port_init_zigbee();
    1302:	0e 94 1d 09 	call	0x123a	; 0x123a <port_init_zigbee>
 uart0_init_zigbee();
    1306:	0e 94 20 09 	call	0x1240	; 0x1240 <uart0_init_zigbee>
 sei();         //Enables the global interrupts
    130a:	78 94       	sei
}
    130c:	08 95       	ret

0000130e <__vector_11>:

SIGNAL(SIG_UART_RECV) 
{	//init_devices_buzzer();
    130e:	1f 92       	push	r1
    1310:	0f 92       	push	r0
    1312:	0f b6       	in	r0, 0x3f	; 63
    1314:	0f 92       	push	r0
    1316:	11 24       	eor	r1, r1
    1318:	0f 93       	push	r16
    131a:	1f 93       	push	r17
    131c:	2f 93       	push	r18
    131e:	3f 93       	push	r19
    1320:	4f 93       	push	r20
    1322:	5f 93       	push	r21
    1324:	6f 93       	push	r22
    1326:	7f 93       	push	r23
    1328:	8f 93       	push	r24
    132a:	9f 93       	push	r25
    132c:	af 93       	push	r26
    132e:	bf 93       	push	r27
    1330:	cf 93       	push	r28
    1332:	ef 93       	push	r30
    1334:	ff 93       	push	r31
	
	          
 unsigned char k;
 k=UDR;         // Echo the received data plus 1
    1336:	cc b1       	in	r28, 0x0c	; 12
if(k==0x33)//51
    1338:	c3 33       	cpi	r28, 0x33	; 51
    133a:	d1 f4       	brne	.+52     	; 0x1370 <__vector_11+0x62>
{
	mark=1;
    133c:	81 e0       	ldi	r24, 0x01	; 1
    133e:	80 93 60 00 	sts	0x0060, r24
	buzzer_on();
    1342:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1346:	8f ef       	ldi	r24, 0xFF	; 255
    1348:	9f eb       	ldi	r25, 0xBF	; 191
    134a:	a6 e0       	ldi	r26, 0x06	; 6
    134c:	81 50       	subi	r24, 0x01	; 1
    134e:	90 40       	sbci	r25, 0x00	; 0
    1350:	a0 40       	sbci	r26, 0x00	; 0
    1352:	e1 f7       	brne	.-8      	; 0x134c <__vector_11+0x3e>
    1354:	00 c0       	rjmp	.+0      	; 0x1356 <__vector_11+0x48>
    1356:	00 00       	nop
	_delay_ms(300);
	buzzer_off();
    1358:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    135c:	8f ef       	ldi	r24, 0xFF	; 255
    135e:	9f eb       	ldi	r25, 0xBF	; 191
    1360:	a6 e0       	ldi	r26, 0x06	; 6
    1362:	81 50       	subi	r24, 0x01	; 1
    1364:	90 40       	sbci	r25, 0x00	; 0
    1366:	a0 40       	sbci	r26, 0x00	; 0
    1368:	e1 f7       	brne	.-8      	; 0x1362 <__vector_11+0x54>
    136a:	00 c0       	rjmp	.+0      	; 0x136c <__vector_11+0x5e>
    136c:	00 00       	nop
    136e:	1f c0       	rjmp	.+62     	; 0x13ae <__vector_11+0xa0>
	_delay_ms(300);
}
if (k==0x34)//52
    1370:	c4 33       	cpi	r28, 0x34	; 52
    1372:	e9 f4       	brne	.+58     	; 0x13ae <__vector_11+0xa0>
{
	mark=0;
    1374:	10 92 60 00 	sts	0x0060, r1
	next++;
    1378:	80 91 71 00 	lds	r24, 0x0071
    137c:	8f 5f       	subi	r24, 0xFF	; 255
    137e:	80 93 71 00 	sts	0x0071, r24
	buzzer_on();
    1382:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1386:	8f ef       	ldi	r24, 0xFF	; 255
    1388:	9f eb       	ldi	r25, 0xBF	; 191
    138a:	a6 e0       	ldi	r26, 0x06	; 6
    138c:	81 50       	subi	r24, 0x01	; 1
    138e:	90 40       	sbci	r25, 0x00	; 0
    1390:	a0 40       	sbci	r26, 0x00	; 0
    1392:	e1 f7       	brne	.-8      	; 0x138c <__vector_11+0x7e>
    1394:	00 c0       	rjmp	.+0      	; 0x1396 <__vector_11+0x88>
    1396:	00 00       	nop
	_delay_ms(300);
	buzzer_off();
    1398:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    139c:	8f ef       	ldi	r24, 0xFF	; 255
    139e:	9f eb       	ldi	r25, 0xBF	; 191
    13a0:	a6 e0       	ldi	r26, 0x06	; 6
    13a2:	81 50       	subi	r24, 0x01	; 1
    13a4:	90 40       	sbci	r25, 0x00	; 0
    13a6:	a0 40       	sbci	r26, 0x00	; 0
    13a8:	e1 f7       	brne	.-8      	; 0x13a2 <__vector_11+0x94>
    13aa:	00 c0       	rjmp	.+0      	; 0x13ac <__vector_11+0x9e>
    13ac:	00 00       	nop
	_delay_ms(300);
}

	if (mark==1)
    13ae:	80 91 60 00 	lds	r24, 0x0060
    13b2:	81 30       	cpi	r24, 0x01	; 1
    13b4:	09 f0       	breq	.+2      	; 0x13b8 <__vector_11+0xaa>
    13b6:	53 c0       	rjmp	.+166    	; 0x145e <__vector_11+0x150>
	{
		if(k>0x00 && k<0x31)//0-49
    13b8:	8c 2f       	mov	r24, r28
    13ba:	81 50       	subi	r24, 0x01	; 1
    13bc:	80 33       	cpi	r24, 0x30	; 48
    13be:	30 f5       	brcc	.+76     	; 0x140c <__vector_11+0xfe>
		{
			red_nodes[r]=conversion(k);
    13c0:	00 91 73 00 	lds	r16, 0x0073
    13c4:	10 e0       	ldi	r17, 0x00	; 0
    13c6:	8c 2f       	mov	r24, r28
    13c8:	0e 94 2a 09 	call	0x1254	; 0x1254 <conversion>
    13cc:	f8 01       	movw	r30, r16
    13ce:	ed 50       	subi	r30, 0x0D	; 13
    13d0:	ff 4f       	sbci	r31, 0xFF	; 255
    13d2:	80 83       	st	Z, r24
			
			r++;
    13d4:	80 91 73 00 	lds	r24, 0x0073
    13d8:	8f 5f       	subi	r24, 0xFF	; 255
    13da:	80 93 73 00 	sts	0x0073, r24
			buzzer_on();
    13de:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    13e2:	8f ef       	ldi	r24, 0xFF	; 255
    13e4:	9f eb       	ldi	r25, 0xBF	; 191
    13e6:	a6 e0       	ldi	r26, 0x06	; 6
    13e8:	81 50       	subi	r24, 0x01	; 1
    13ea:	90 40       	sbci	r25, 0x00	; 0
    13ec:	a0 40       	sbci	r26, 0x00	; 0
    13ee:	e1 f7       	brne	.-8      	; 0x13e8 <__vector_11+0xda>
    13f0:	00 c0       	rjmp	.+0      	; 0x13f2 <__vector_11+0xe4>
    13f2:	00 00       	nop
			_delay_ms(300);
			buzzer_off();
    13f4:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    13f8:	8f ef       	ldi	r24, 0xFF	; 255
    13fa:	9f eb       	ldi	r25, 0xBF	; 191
    13fc:	a6 e0       	ldi	r26, 0x06	; 6
    13fe:	81 50       	subi	r24, 0x01	; 1
    1400:	90 40       	sbci	r25, 0x00	; 0
    1402:	a0 40       	sbci	r26, 0x00	; 0
    1404:	e1 f7       	brne	.-8      	; 0x13fe <__vector_11+0xf0>
    1406:	00 c0       	rjmp	.+0      	; 0x1408 <__vector_11+0xfa>
    1408:	00 00       	nop
    140a:	29 c0       	rjmp	.+82     	; 0x145e <__vector_11+0x150>
			_delay_ms(300);
			
		}
		else if(k==0x64 || k==0x65)//100-101
    140c:	8c 2f       	mov	r24, r28
    140e:	84 56       	subi	r24, 0x64	; 100
    1410:	82 30       	cpi	r24, 0x02	; 2
    1412:	28 f5       	brcc	.+74     	; 0x145e <__vector_11+0x150>
		{
			red_side[rs]=conversion(k);
    1414:	00 91 72 00 	lds	r16, 0x0072
    1418:	10 e0       	ldi	r17, 0x00	; 0
    141a:	8c 2f       	mov	r24, r28
    141c:	0e 94 2a 09 	call	0x1254	; 0x1254 <conversion>
    1420:	f8 01       	movw	r30, r16
    1422:	e1 50       	subi	r30, 0x01	; 1
    1424:	ff 4f       	sbci	r31, 0xFF	; 255
    1426:	80 83       	st	Z, r24
			rs++;
    1428:	80 91 72 00 	lds	r24, 0x0072
    142c:	8f 5f       	subi	r24, 0xFF	; 255
    142e:	80 93 72 00 	sts	0x0072, r24
			buzzer_on();
    1432:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1436:	8f ef       	ldi	r24, 0xFF	; 255
    1438:	9f eb       	ldi	r25, 0xBF	; 191
    143a:	a6 e0       	ldi	r26, 0x06	; 6
    143c:	81 50       	subi	r24, 0x01	; 1
    143e:	90 40       	sbci	r25, 0x00	; 0
    1440:	a0 40       	sbci	r26, 0x00	; 0
    1442:	e1 f7       	brne	.-8      	; 0x143c <__vector_11+0x12e>
    1444:	00 c0       	rjmp	.+0      	; 0x1446 <__vector_11+0x138>
    1446:	00 00       	nop
			_delay_ms(300);
			buzzer_off();
    1448:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    144c:	8f ef       	ldi	r24, 0xFF	; 255
    144e:	9f eb       	ldi	r25, 0xBF	; 191
    1450:	a6 e0       	ldi	r26, 0x06	; 6
    1452:	81 50       	subi	r24, 0x01	; 1
    1454:	90 40       	sbci	r25, 0x00	; 0
    1456:	a0 40       	sbci	r26, 0x00	; 0
    1458:	e1 f7       	brne	.-8      	; 0x1452 <__vector_11+0x144>
    145a:	00 c0       	rjmp	.+0      	; 0x145c <__vector_11+0x14e>
    145c:	00 00       	nop
			_delay_ms(300);
		}
	}		
 
}
    145e:	ff 91       	pop	r31
    1460:	ef 91       	pop	r30
    1462:	cf 91       	pop	r28
    1464:	bf 91       	pop	r27
    1466:	af 91       	pop	r26
    1468:	9f 91       	pop	r25
    146a:	8f 91       	pop	r24
    146c:	7f 91       	pop	r23
    146e:	6f 91       	pop	r22
    1470:	5f 91       	pop	r21
    1472:	4f 91       	pop	r20
    1474:	3f 91       	pop	r19
    1476:	2f 91       	pop	r18
    1478:	1f 91       	pop	r17
    147a:	0f 91       	pop	r16
    147c:	0f 90       	pop	r0
    147e:	0f be       	out	0x3f, r0	; 63
    1480:	0f 90       	pop	r0
    1482:	1f 90       	pop	r1
    1484:	18 95       	reti

00001486 <USARTWriteChar>:
		//Do nothing
	*/

	//Now write the data to USART buffer
  
	UDR=data;
    1486:	8c b9       	out	0x0c, r24	; 12
		
	
}
    1488:	08 95       	ret

0000148a <direction>:
	PORTC=PORTC& 0x8F;
	//buzzer_beep();
}

void direction(void)
{	init_devices_buzzer();
    148a:	0f 93       	push	r16
    148c:	1f 93       	push	r17
    148e:	cf 93       	push	r28
    1490:	df 93       	push	r29
    1492:	0e 94 db 00 	call	0x1b6	; 0x1b6 <init_devices_buzzer>
	int w=0;
	if(t==max)
    1496:	90 91 76 00 	lds	r25, 0x0076
    149a:	80 91 80 00 	lds	r24, 0x0080
    149e:	98 17       	cp	r25, r24
    14a0:	09 f0       	breq	.+2      	; 0x14a4 <direction+0x1a>
    14a2:	69 c1       	rjmp	.+722    	; 0x1776 <direction+0x2ec>
	{	if(stage==1)
    14a4:	80 91 65 00 	lds	r24, 0x0065
    14a8:	81 30       	cpi	r24, 0x01	; 1
    14aa:	09 f0       	breq	.+2      	; 0x14ae <direction+0x24>
    14ac:	4f c0       	rjmp	.+158    	; 0x154c <direction+0xc2>
		{	
			if(dir==1)
    14ae:	80 91 66 00 	lds	r24, 0x0066
    14b2:	81 30       	cpi	r24, 0x01	; 1
    14b4:	81 f4       	brne	.+32     	; 0x14d6 <direction+0x4c>
			{	//buzzer_beep();
				right_degrees(190);
    14b6:	8e eb       	ldi	r24, 0xBE	; 190
    14b8:	90 e0       	ldi	r25, 0x00	; 0
    14ba:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <right_degrees>
				stop_pos();
    14be:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
    14c2:	8f ef       	ldi	r24, 0xFF	; 255
    14c4:	9f e3       	ldi	r25, 0x3F	; 63
    14c6:	ab e0       	ldi	r26, 0x0B	; 11
    14c8:	81 50       	subi	r24, 0x01	; 1
    14ca:	90 40       	sbci	r25, 0x00	; 0
    14cc:	a0 40       	sbci	r26, 0x00	; 0
    14ce:	e1 f7       	brne	.-8      	; 0x14c8 <direction+0x3e>
    14d0:	00 c0       	rjmp	.+0      	; 0x14d2 <direction+0x48>
    14d2:	00 00       	nop
    14d4:	23 c0       	rjmp	.+70     	; 0x151c <direction+0x92>
				_delay_ms(500);
			}
			else if(dir==2)
    14d6:	82 30       	cpi	r24, 0x02	; 2
    14d8:	81 f4       	brne	.+32     	; 0x14fa <direction+0x70>
			{
				right_degrees(100);
    14da:	84 e6       	ldi	r24, 0x64	; 100
    14dc:	90 e0       	ldi	r25, 0x00	; 0
    14de:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <right_degrees>
				stop_pos();
    14e2:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
    14e6:	8f ef       	ldi	r24, 0xFF	; 255
    14e8:	9f e3       	ldi	r25, 0x3F	; 63
    14ea:	ab e0       	ldi	r26, 0x0B	; 11
    14ec:	81 50       	subi	r24, 0x01	; 1
    14ee:	90 40       	sbci	r25, 0x00	; 0
    14f0:	a0 40       	sbci	r26, 0x00	; 0
    14f2:	e1 f7       	brne	.-8      	; 0x14ec <direction+0x62>
    14f4:	00 c0       	rjmp	.+0      	; 0x14f6 <direction+0x6c>
    14f6:	00 00       	nop
    14f8:	11 c0       	rjmp	.+34     	; 0x151c <direction+0x92>
				_delay_ms(500);
			}
			else if(dir==4)
    14fa:	84 30       	cpi	r24, 0x04	; 4
    14fc:	79 f4       	brne	.+30     	; 0x151c <direction+0x92>
			{
				left_degrees(100);
    14fe:	84 e6       	ldi	r24, 0x64	; 100
    1500:	90 e0       	ldi	r25, 0x00	; 0
    1502:	0e 94 ce 03 	call	0x79c	; 0x79c <left_degrees>
				stop_pos();
    1506:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
    150a:	8f ef       	ldi	r24, 0xFF	; 255
    150c:	9f e3       	ldi	r25, 0x3F	; 63
    150e:	ab e0       	ldi	r26, 0x0B	; 11
    1510:	81 50       	subi	r24, 0x01	; 1
    1512:	90 40       	sbci	r25, 0x00	; 0
    1514:	a0 40       	sbci	r26, 0x00	; 0
    1516:	e1 f7       	brne	.-8      	; 0x1510 <direction+0x86>
    1518:	00 c0       	rjmp	.+0      	; 0x151a <direction+0x90>
    151a:	00 00       	nop
				_delay_ms(500);
			}
			
			dir=3;
    151c:	83 e0       	ldi	r24, 0x03	; 3
    151e:	80 93 66 00 	sts	0x0066, r24
		//	lcd_print(2,4,dir,3);
			back_mm(100);
    1522:	84 e6       	ldi	r24, 0x64	; 100
    1524:	90 e0       	ldi	r25, 0x00	; 0
    1526:	0e 94 c3 03 	call	0x786	; 0x786 <back_mm>
			stop_pos();
    152a:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
    152e:	8f ef       	ldi	r24, 0xFF	; 255
    1530:	9f e3       	ldi	r25, 0x3F	; 63
    1532:	ab e0       	ldi	r26, 0x0B	; 11
    1534:	81 50       	subi	r24, 0x01	; 1
    1536:	90 40       	sbci	r25, 0x00	; 0
    1538:	a0 40       	sbci	r26, 0x00	; 0
    153a:	e1 f7       	brne	.-8      	; 0x1534 <direction+0xaa>
    153c:	00 c0       	rjmp	.+0      	; 0x153e <direction+0xb4>
    153e:	00 00       	nop
			_delay_ms(500);
			g=1;
    1540:	81 e0       	ldi	r24, 0x01	; 1
    1542:	80 93 81 00 	sts	0x0081, r24
			buzzer_beep();
    1546:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_beep>
    154a:	15 c1       	rjmp	.+554    	; 0x1776 <direction+0x2ec>
		}
		else if(stage==2)
    154c:	82 30       	cpi	r24, 0x02	; 2
    154e:	09 f0       	breq	.+2      	; 0x1552 <direction+0xc8>
    1550:	07 c1       	rjmp	.+526    	; 0x1760 <direction+0x2d6>
    1552:	8f ef       	ldi	r24, 0xFF	; 255
    1554:	9f e3       	ldi	r25, 0x3F	; 63
    1556:	a2 e0       	ldi	r26, 0x02	; 2
    1558:	81 50       	subi	r24, 0x01	; 1
    155a:	90 40       	sbci	r25, 0x00	; 0
    155c:	a0 40       	sbci	r26, 0x00	; 0
    155e:	e1 f7       	brne	.-8      	; 0x1558 <direction+0xce>
    1560:	00 c0       	rjmp	.+0      	; 0x1562 <direction+0xd8>
    1562:	00 00       	nop
			
			
			_delay_ms(100);
			while (1)
			{
				if(next>1)
    1564:	80 91 71 00 	lds	r24, 0x0071
    1568:	82 30       	cpi	r24, 0x02	; 2
    156a:	e0 f3       	brcs	.-8      	; 0x1564 <direction+0xda>
					break;
					
				}
			}
			
			green_nodes[0]=55;
    156c:	97 e3       	ldi	r25, 0x37	; 55
    156e:	90 93 82 00 	sts	0x0082, r25
			green_nodes[gn]=56;
    1572:	e0 91 62 00 	lds	r30, 0x0062
    1576:	f0 e0       	ldi	r31, 0x00	; 0
    1578:	ee 57       	subi	r30, 0x7E	; 126
    157a:	ff 4f       	sbci	r31, 0xFF	; 255
    157c:	88 e3       	ldi	r24, 0x38	; 56
    157e:	80 83       	st	Z, r24
			green_side[0]=55;
    1580:	90 93 a0 00 	sts	0x00A0, r25
			green_side[gs]=56;
    1584:	e0 91 61 00 	lds	r30, 0x0061
    1588:	f0 e0       	ldi	r31, 0x00	; 0
    158a:	e0 56       	subi	r30, 0x60	; 96
    158c:	ff 4f       	sbci	r31, 0xFF	; 255
    158e:	80 83       	st	Z, r24
			for(int i=0;i<=10;i++)
			{	if(green_nodes[i]==0)
    1590:	80 91 82 00 	lds	r24, 0x0082
    1594:	88 23       	and	r24, r24
    1596:	09 f0       	breq	.+2      	; 0x159a <direction+0x110>
    1598:	a5 c1       	rjmp	.+842    	; 0x18e4 <direction+0x45a>
    159a:	19 c0       	rjmp	.+50     	; 0x15ce <direction+0x144>
    159c:	f8 01       	movw	r30, r16
    159e:	ec 0f       	add	r30, r28
    15a0:	fd 1f       	adc	r31, r29
    15a2:	80 81       	ld	r24, Z
    15a4:	88 23       	and	r24, r24
    15a6:	99 f0       	breq	.+38     	; 0x15ce <direction+0x144>
				{
					
					break;
					
				}
				USARTWriteChar(green_nodes[i]);
    15a8:	f8 01       	movw	r30, r16
    15aa:	ec 0f       	add	r30, r28
    15ac:	fd 1f       	adc	r31, r29
    15ae:	80 81       	ld	r24, Z
    15b0:	0e 94 43 0a 	call	0x1486	; 0x1486 <USARTWriteChar>
    15b4:	8f ef       	ldi	r24, 0xFF	; 255
    15b6:	9f e7       	ldi	r25, 0x7F	; 127
    15b8:	a6 e1       	ldi	r26, 0x16	; 22
    15ba:	81 50       	subi	r24, 0x01	; 1
    15bc:	90 40       	sbci	r25, 0x00	; 0
    15be:	a0 40       	sbci	r26, 0x00	; 0
    15c0:	e1 f7       	brne	.-8      	; 0x15ba <direction+0x130>
    15c2:	00 c0       	rjmp	.+0      	; 0x15c4 <direction+0x13a>
    15c4:	00 00       	nop
			
			green_nodes[0]=55;
			green_nodes[gn]=56;
			green_side[0]=55;
			green_side[gs]=56;
			for(int i=0;i<=10;i++)
    15c6:	21 96       	adiw	r28, 0x01	; 1
    15c8:	cb 30       	cpi	r28, 0x0B	; 11
    15ca:	d1 05       	cpc	r29, r1
    15cc:	39 f7       	brne	.-50     	; 0x159c <direction+0x112>
				
				_delay_ms(1000);
				//buzzer_beep();
				
			}
			buzzer_on();
    15ce:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    15d2:	8f ef       	ldi	r24, 0xFF	; 255
    15d4:	9f e7       	ldi	r25, 0x7F	; 127
    15d6:	a6 e1       	ldi	r26, 0x16	; 22
    15d8:	81 50       	subi	r24, 0x01	; 1
    15da:	90 40       	sbci	r25, 0x00	; 0
    15dc:	a0 40       	sbci	r26, 0x00	; 0
    15de:	e1 f7       	brne	.-8      	; 0x15d8 <direction+0x14e>
    15e0:	00 c0       	rjmp	.+0      	; 0x15e2 <direction+0x158>
    15e2:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    15e4:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
			for(int i=0;i<10;i++)
			{	if(green_side[i]==0)
    15e8:	80 91 a0 00 	lds	r24, 0x00A0
    15ec:	88 23       	and	r24, r24
    15ee:	09 f0       	breq	.+2      	; 0x15f2 <direction+0x168>
    15f0:	67 c1       	rjmp	.+718    	; 0x18c0 <direction+0x436>
    15f2:	19 c0       	rjmp	.+50     	; 0x1626 <direction+0x19c>
    15f4:	f8 01       	movw	r30, r16
    15f6:	ec 0f       	add	r30, r28
    15f8:	fd 1f       	adc	r31, r29
    15fa:	80 81       	ld	r24, Z
    15fc:	88 23       	and	r24, r24
    15fe:	99 f0       	breq	.+38     	; 0x1626 <direction+0x19c>
				{
					break;
				}
				USARTWriteChar(green_side[i]);
    1600:	f8 01       	movw	r30, r16
    1602:	ec 0f       	add	r30, r28
    1604:	fd 1f       	adc	r31, r29
    1606:	80 81       	ld	r24, Z
    1608:	0e 94 43 0a 	call	0x1486	; 0x1486 <USARTWriteChar>
    160c:	8f ef       	ldi	r24, 0xFF	; 255
    160e:	9f e7       	ldi	r25, 0x7F	; 127
    1610:	a6 e1       	ldi	r26, 0x16	; 22
    1612:	81 50       	subi	r24, 0x01	; 1
    1614:	90 40       	sbci	r25, 0x00	; 0
    1616:	a0 40       	sbci	r26, 0x00	; 0
    1618:	e1 f7       	brne	.-8      	; 0x1612 <direction+0x188>
    161a:	00 c0       	rjmp	.+0      	; 0x161c <direction+0x192>
    161c:	00 00       	nop
				
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    161e:	21 96       	adiw	r28, 0x01	; 1
    1620:	ca 30       	cpi	r28, 0x0A	; 10
    1622:	d1 05       	cpc	r29, r1
    1624:	39 f7       	brne	.-50     	; 0x15f4 <direction+0x16a>
				}
				USARTWriteChar(green_side[i]);
				_delay_ms(1000);
				//buzzer_beep();
			}
			buzzer_on();
    1626:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    162a:	8f ef       	ldi	r24, 0xFF	; 255
    162c:	9f e7       	ldi	r25, 0x7F	; 127
    162e:	a6 e1       	ldi	r26, 0x16	; 22
    1630:	81 50       	subi	r24, 0x01	; 1
    1632:	90 40       	sbci	r25, 0x00	; 0
    1634:	a0 40       	sbci	r26, 0x00	; 0
    1636:	e1 f7       	brne	.-8      	; 0x1630 <direction+0x1a6>
    1638:	00 c0       	rjmp	.+0      	; 0x163a <direction+0x1b0>
    163a:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    163c:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
			blue_nodes[0]=53;
    1640:	95 e3       	ldi	r25, 0x35	; 53
    1642:	90 93 8e 00 	sts	0x008E, r25
			blue_nodes[b]=54;
    1646:	e0 91 64 00 	lds	r30, 0x0064
    164a:	f0 e0       	ldi	r31, 0x00	; 0
    164c:	e2 57       	subi	r30, 0x72	; 114
    164e:	ff 4f       	sbci	r31, 0xFF	; 255
    1650:	86 e3       	ldi	r24, 0x36	; 54
    1652:	80 83       	st	Z, r24
			blue_side[0]=53;
    1654:	90 93 ac 00 	sts	0x00AC, r25
			blue_side[bs]=54;
    1658:	e0 91 63 00 	lds	r30, 0x0063
    165c:	f0 e0       	ldi	r31, 0x00	; 0
    165e:	e4 55       	subi	r30, 0x54	; 84
    1660:	ff 4f       	sbci	r31, 0xFF	; 255
    1662:	80 83       	st	Z, r24
			for(int i=0;i<=10;i++)
			{	if(blue_nodes[i]==0)
    1664:	80 91 8e 00 	lds	r24, 0x008E
    1668:	88 23       	and	r24, r24
    166a:	09 f0       	breq	.+2      	; 0x166e <direction+0x1e4>
    166c:	16 c1       	rjmp	.+556    	; 0x189a <direction+0x410>
    166e:	1a c0       	rjmp	.+52     	; 0x16a4 <direction+0x21a>
    1670:	f8 01       	movw	r30, r16
    1672:	ec 0f       	add	r30, r28
    1674:	fd 1f       	adc	r31, r29
    1676:	80 81       	ld	r24, Z
    1678:	88 23       	and	r24, r24
    167a:	a1 f0       	breq	.+40     	; 0x16a4 <direction+0x21a>
				{
					
					break;
					
				}
				USARTWriteChar(blue_nodes[i]+7);
    167c:	f8 01       	movw	r30, r16
    167e:	ec 0f       	add	r30, r28
    1680:	fd 1f       	adc	r31, r29
    1682:	80 81       	ld	r24, Z
    1684:	89 5f       	subi	r24, 0xF9	; 249
    1686:	0e 94 43 0a 	call	0x1486	; 0x1486 <USARTWriteChar>
    168a:	8f ef       	ldi	r24, 0xFF	; 255
    168c:	9f e7       	ldi	r25, 0x7F	; 127
    168e:	a6 e1       	ldi	r26, 0x16	; 22
    1690:	81 50       	subi	r24, 0x01	; 1
    1692:	90 40       	sbci	r25, 0x00	; 0
    1694:	a0 40       	sbci	r26, 0x00	; 0
    1696:	e1 f7       	brne	.-8      	; 0x1690 <direction+0x206>
    1698:	00 c0       	rjmp	.+0      	; 0x169a <direction+0x210>
    169a:	00 00       	nop
			buzzer_off();
			blue_nodes[0]=53;
			blue_nodes[b]=54;
			blue_side[0]=53;
			blue_side[bs]=54;
			for(int i=0;i<=10;i++)
    169c:	21 96       	adiw	r28, 0x01	; 1
    169e:	cb 30       	cpi	r28, 0x0B	; 11
    16a0:	d1 05       	cpc	r29, r1
    16a2:	31 f7       	brne	.-52     	; 0x1670 <direction+0x1e6>
				
				_delay_ms(1000);
				//buzzer_beep();
				
			}
			buzzer_on();
    16a4:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    16a8:	8f ef       	ldi	r24, 0xFF	; 255
    16aa:	9f e7       	ldi	r25, 0x7F	; 127
    16ac:	a6 e1       	ldi	r26, 0x16	; 22
    16ae:	81 50       	subi	r24, 0x01	; 1
    16b0:	90 40       	sbci	r25, 0x00	; 0
    16b2:	a0 40       	sbci	r26, 0x00	; 0
    16b4:	e1 f7       	brne	.-8      	; 0x16ae <direction+0x224>
    16b6:	00 c0       	rjmp	.+0      	; 0x16b8 <direction+0x22e>
    16b8:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    16ba:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
			for(int i=0;i<10;i++)
			{	if(blue_side[i]==0)
    16be:	80 91 ac 00 	lds	r24, 0x00AC
    16c2:	88 23       	and	r24, r24
    16c4:	a1 f1       	breq	.+104    	; 0x172e <direction+0x2a4>
				
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    16c6:	c0 e0       	ldi	r28, 0x00	; 0
    16c8:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(blue_side[i]==0)
				{
					break;
				}
				if(blue_side[i]==100)
    16ca:	0c ea       	ldi	r16, 0xAC	; 172
    16cc:	10 e0       	ldi	r17, 0x00	; 0
    16ce:	06 c0       	rjmp	.+12     	; 0x16dc <direction+0x252>
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
			{	if(blue_side[i]==0)
    16d0:	f8 01       	movw	r30, r16
    16d2:	ec 0f       	add	r30, r28
    16d4:	fd 1f       	adc	r31, r29
    16d6:	80 81       	ld	r24, Z
    16d8:	88 23       	and	r24, r24
    16da:	49 f1       	breq	.+82     	; 0x172e <direction+0x2a4>
				{
					break;
				}
				if(blue_side[i]==100)
    16dc:	f8 01       	movw	r30, r16
    16de:	ec 0f       	add	r30, r28
    16e0:	fd 1f       	adc	r31, r29
    16e2:	80 81       	ld	r24, Z
    16e4:	84 36       	cpi	r24, 0x64	; 100
    16e6:	69 f4       	brne	.+26     	; 0x1702 <direction+0x278>
				{
					USARTWriteChar(101);
    16e8:	85 e6       	ldi	r24, 0x65	; 101
    16ea:	0e 94 43 0a 	call	0x1486	; 0x1486 <USARTWriteChar>
    16ee:	8f ef       	ldi	r24, 0xFF	; 255
    16f0:	9f e7       	ldi	r25, 0x7F	; 127
    16f2:	a6 e1       	ldi	r26, 0x16	; 22
    16f4:	81 50       	subi	r24, 0x01	; 1
    16f6:	90 40       	sbci	r25, 0x00	; 0
    16f8:	a0 40       	sbci	r26, 0x00	; 0
    16fa:	e1 f7       	brne	.-8      	; 0x16f4 <direction+0x26a>
    16fc:	00 c0       	rjmp	.+0      	; 0x16fe <direction+0x274>
    16fe:	00 00       	nop
    1700:	12 c0       	rjmp	.+36     	; 0x1726 <direction+0x29c>
					_delay_ms(1000);
				}
				else if(blue_side[i]==101)
    1702:	f8 01       	movw	r30, r16
    1704:	ec 0f       	add	r30, r28
    1706:	fd 1f       	adc	r31, r29
    1708:	80 81       	ld	r24, Z
    170a:	85 36       	cpi	r24, 0x65	; 101
    170c:	61 f4       	brne	.+24     	; 0x1726 <direction+0x29c>
				{
					USARTWriteChar(100);
    170e:	84 e6       	ldi	r24, 0x64	; 100
    1710:	0e 94 43 0a 	call	0x1486	; 0x1486 <USARTWriteChar>
    1714:	8f ef       	ldi	r24, 0xFF	; 255
    1716:	9f e7       	ldi	r25, 0x7F	; 127
    1718:	a6 e1       	ldi	r26, 0x16	; 22
    171a:	81 50       	subi	r24, 0x01	; 1
    171c:	90 40       	sbci	r25, 0x00	; 0
    171e:	a0 40       	sbci	r26, 0x00	; 0
    1720:	e1 f7       	brne	.-8      	; 0x171a <direction+0x290>
    1722:	00 c0       	rjmp	.+0      	; 0x1724 <direction+0x29a>
    1724:	00 00       	nop
				
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    1726:	21 96       	adiw	r28, 0x01	; 1
    1728:	ca 30       	cpi	r28, 0x0A	; 10
    172a:	d1 05       	cpc	r29, r1
    172c:	89 f6       	brne	.-94     	; 0x16d0 <direction+0x246>
					_delay_ms(1000);
				}
				
				//buzzer_beep();
			}
			buzzer_on();
    172e:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1732:	8f ef       	ldi	r24, 0xFF	; 255
    1734:	9f e7       	ldi	r25, 0x7F	; 127
    1736:	a6 e1       	ldi	r26, 0x16	; 22
    1738:	81 50       	subi	r24, 0x01	; 1
    173a:	90 40       	sbci	r25, 0x00	; 0
    173c:	a0 40       	sbci	r26, 0x00	; 0
    173e:	e1 f7       	brne	.-8      	; 0x1738 <direction+0x2ae>
    1740:	00 c0       	rjmp	.+0      	; 0x1742 <direction+0x2b8>
    1742:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    1744:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
			while (1)
			{
				if(next>3)
    1748:	80 91 71 00 	lds	r24, 0x0071
    174c:	84 30       	cpi	r24, 0x04	; 4
    174e:	e0 f3       	brcs	.-8      	; 0x1748 <direction+0x2be>
				{	buzzer_beep();
    1750:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_beep>
					buzzer_beep();
    1754:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_beep>
					break;
				}
				
			}
			
			g=1;
    1758:	81 e0       	ldi	r24, 0x01	; 1
    175a:	80 93 81 00 	sts	0x0081, r24
    175e:	0b c0       	rjmp	.+22     	; 0x1776 <direction+0x2ec>
			_delay_ms(1000);
			buzzer_off();*/
			
			
		}
		else if(stage==3)
    1760:	83 30       	cpi	r24, 0x03	; 3
    1762:	21 f4       	brne	.+8      	; 0x176c <direction+0x2e2>
		{
			g=1;
    1764:	81 e0       	ldi	r24, 0x01	; 1
    1766:	80 93 81 00 	sts	0x0081, r24
    176a:	05 c0       	rjmp	.+10     	; 0x1776 <direction+0x2ec>
			/*buzzer_beep();
			buzzer_beep();
			buzzer_beep();*/
		
		}		
		else if(stage==4)
    176c:	84 30       	cpi	r24, 0x04	; 4
    176e:	19 f4       	brne	.+6      	; 0x1776 <direction+0x2ec>
		{
			g=1;
    1770:	81 e0       	ldi	r24, 0x01	; 1
    1772:	80 93 81 00 	sts	0x0081, r24
		}		
		
		
		
	}
	if(t<max)
    1776:	20 91 76 00 	lds	r18, 0x0076
    177a:	80 91 80 00 	lds	r24, 0x0080
    177e:	28 17       	cp	r18, r24
    1780:	08 f0       	brcs	.+2      	; 0x1784 <direction+0x2fa>
    1782:	c2 c0       	rjmp	.+388    	; 0x1908 <direction+0x47e>
	{
		w=(path1.path[t]-path1.path[t+1]);
    1784:	e8 ec       	ldi	r30, 0xC8	; 200
    1786:	f0 e0       	ldi	r31, 0x00	; 0
    1788:	e2 0f       	add	r30, r18
    178a:	f1 1d       	adc	r31, r1
    178c:	80 81       	ld	r24, Z
    178e:	90 e0       	ldi	r25, 0x00	; 0
    1790:	31 81       	ldd	r19, Z+1	; 0x01
    1792:	83 1b       	sub	r24, r19
    1794:	91 09       	sbc	r25, r1
		t++;
    1796:	2f 5f       	subi	r18, 0xFF	; 255
    1798:	20 93 76 00 	sts	0x0076, r18
			lcd_init();
			
		
		lcd_print(2,1,w,3);
		_delay_ms(4000);*/
		switch (w)
    179c:	af ef       	ldi	r26, 0xFF	; 255
    179e:	8f 3f       	cpi	r24, 0xFF	; 255
    17a0:	9a 07       	cpc	r25, r26
    17a2:	69 f1       	breq	.+90     	; 0x17fe <direction+0x374>
    17a4:	bf ef       	ldi	r27, 0xFF	; 255
    17a6:	8f 3f       	cpi	r24, 0xFF	; 255
    17a8:	9b 07       	cpc	r25, r27
    17aa:	09 f0       	breq	.+2      	; 0x17ae <direction+0x324>
    17ac:	34 f4       	brge	.+12     	; 0x17ba <direction+0x330>
    17ae:	2f ef       	ldi	r18, 0xFF	; 255
    17b0:	89 3f       	cpi	r24, 0xF9	; 249
    17b2:	92 07       	cpc	r25, r18
    17b4:	09 f0       	breq	.+2      	; 0x17b8 <direction+0x32e>
    17b6:	a8 c0       	rjmp	.+336    	; 0x1908 <direction+0x47e>
    17b8:	56 c0       	rjmp	.+172    	; 0x1866 <direction+0x3dc>
    17ba:	81 30       	cpi	r24, 0x01	; 1
    17bc:	91 05       	cpc	r25, r1
    17be:	29 f0       	breq	.+10     	; 0x17ca <direction+0x340>
    17c0:	87 30       	cpi	r24, 0x07	; 7
    17c2:	91 05       	cpc	r25, r1
    17c4:	09 f0       	breq	.+2      	; 0x17c8 <direction+0x33e>
    17c6:	a0 c0       	rjmp	.+320    	; 0x1908 <direction+0x47e>
    17c8:	34 c0       	rjmp	.+104    	; 0x1832 <direction+0x3a8>
		{ 
			case 1:
			
				if(dir==1)
    17ca:	80 91 66 00 	lds	r24, 0x0066
    17ce:	81 30       	cpi	r24, 0x01	; 1
    17d0:	29 f4       	brne	.+10     	; 0x17dc <direction+0x352>
				success(3);
    17d2:	83 e0       	ldi	r24, 0x03	; 3
    17d4:	90 e0       	ldi	r25, 0x00	; 0
    17d6:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    17da:	0d c0       	rjmp	.+26     	; 0x17f6 <direction+0x36c>
				else if(dir==3)
    17dc:	83 30       	cpi	r24, 0x03	; 3
    17de:	29 f4       	brne	.+10     	; 0x17ea <direction+0x360>
				success(2);
    17e0:	82 e0       	ldi	r24, 0x02	; 2
    17e2:	90 e0       	ldi	r25, 0x00	; 0
    17e4:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    17e8:	06 c0       	rjmp	.+12     	; 0x17f6 <direction+0x36c>
				else if(dir==4)
    17ea:	84 30       	cpi	r24, 0x04	; 4
    17ec:	21 f4       	brne	.+8      	; 0x17f6 <direction+0x36c>
				success(1);
    17ee:	81 e0       	ldi	r24, 0x01	; 1
    17f0:	90 e0       	ldi	r25, 0x00	; 0
    17f2:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
				
				dir=4;
    17f6:	84 e0       	ldi	r24, 0x04	; 4
    17f8:	80 93 66 00 	sts	0x0066, r24
				break;
    17fc:	85 c0       	rjmp	.+266    	; 0x1908 <direction+0x47e>
			
			case (-1):
			
				if(dir==1)
    17fe:	80 91 66 00 	lds	r24, 0x0066
    1802:	81 30       	cpi	r24, 0x01	; 1
    1804:	29 f4       	brne	.+10     	; 0x1810 <direction+0x386>
				success(2);
    1806:	82 e0       	ldi	r24, 0x02	; 2
    1808:	90 e0       	ldi	r25, 0x00	; 0
    180a:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    180e:	0d c0       	rjmp	.+26     	; 0x182a <direction+0x3a0>
				else if(dir==2)
    1810:	82 30       	cpi	r24, 0x02	; 2
    1812:	29 f4       	brne	.+10     	; 0x181e <direction+0x394>
				success(1);
    1814:	81 e0       	ldi	r24, 0x01	; 1
    1816:	90 e0       	ldi	r25, 0x00	; 0
    1818:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    181c:	06 c0       	rjmp	.+12     	; 0x182a <direction+0x3a0>
				else if(dir==3)
    181e:	83 30       	cpi	r24, 0x03	; 3
    1820:	21 f4       	brne	.+8      	; 0x182a <direction+0x3a0>
				success(3);
    1822:	83 e0       	ldi	r24, 0x03	; 3
    1824:	90 e0       	ldi	r25, 0x00	; 0
    1826:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
				
				dir=2;
    182a:	82 e0       	ldi	r24, 0x02	; 2
    182c:	80 93 66 00 	sts	0x0066, r24
				break;
    1830:	6b c0       	rjmp	.+214    	; 0x1908 <direction+0x47e>
				
			
			case (7):
			
				if(dir==1)
    1832:	80 91 66 00 	lds	r24, 0x0066
    1836:	81 30       	cpi	r24, 0x01	; 1
    1838:	29 f4       	brne	.+10     	; 0x1844 <direction+0x3ba>
				success(1);
    183a:	81 e0       	ldi	r24, 0x01	; 1
    183c:	90 e0       	ldi	r25, 0x00	; 0
    183e:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    1842:	0d c0       	rjmp	.+26     	; 0x185e <direction+0x3d4>
				else if(dir==2)
    1844:	82 30       	cpi	r24, 0x02	; 2
    1846:	29 f4       	brne	.+10     	; 0x1852 <direction+0x3c8>
				success(3);
    1848:	83 e0       	ldi	r24, 0x03	; 3
    184a:	90 e0       	ldi	r25, 0x00	; 0
    184c:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    1850:	06 c0       	rjmp	.+12     	; 0x185e <direction+0x3d4>
				else if(dir==4)
    1852:	84 30       	cpi	r24, 0x04	; 4
    1854:	21 f4       	brne	.+8      	; 0x185e <direction+0x3d4>
				success(2);
    1856:	82 e0       	ldi	r24, 0x02	; 2
    1858:	90 e0       	ldi	r25, 0x00	; 0
    185a:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
				
				dir=1;
    185e:	81 e0       	ldi	r24, 0x01	; 1
    1860:	80 93 66 00 	sts	0x0066, r24
				break;
    1864:	51 c0       	rjmp	.+162    	; 0x1908 <direction+0x47e>
				
			
			case (-7):
			
				if(dir==2)
    1866:	80 91 66 00 	lds	r24, 0x0066
    186a:	82 30       	cpi	r24, 0x02	; 2
    186c:	29 f4       	brne	.+10     	; 0x1878 <direction+0x3ee>
				success(2);
    186e:	82 e0       	ldi	r24, 0x02	; 2
    1870:	90 e0       	ldi	r25, 0x00	; 0
    1872:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    1876:	0d c0       	rjmp	.+26     	; 0x1892 <direction+0x408>
				else if(dir==3)
    1878:	83 30       	cpi	r24, 0x03	; 3
    187a:	29 f4       	brne	.+10     	; 0x1886 <direction+0x3fc>
				success(1);
    187c:	81 e0       	ldi	r24, 0x01	; 1
    187e:	90 e0       	ldi	r25, 0x00	; 0
    1880:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
    1884:	06 c0       	rjmp	.+12     	; 0x1892 <direction+0x408>
				else if(dir==4)
    1886:	84 30       	cpi	r24, 0x04	; 4
    1888:	21 f4       	brne	.+8      	; 0x1892 <direction+0x408>
				success(3);
    188a:	83 e0       	ldi	r24, 0x03	; 3
    188c:	90 e0       	ldi	r25, 0x00	; 0
    188e:	0e 94 a6 05 	call	0xb4c	; 0xb4c <success>
				
				dir=3;
    1892:	83 e0       	ldi	r24, 0x03	; 3
    1894:	80 93 66 00 	sts	0x0066, r24
				break;
    1898:	37 c0       	rjmp	.+110    	; 0x1908 <direction+0x47e>
				{
					
					break;
					
				}
				USARTWriteChar(blue_nodes[i]+7);
    189a:	80 91 8e 00 	lds	r24, 0x008E
    189e:	89 5f       	subi	r24, 0xF9	; 249
    18a0:	0e 94 43 0a 	call	0x1486	; 0x1486 <USARTWriteChar>
    18a4:	8f ef       	ldi	r24, 0xFF	; 255
    18a6:	9f e7       	ldi	r25, 0x7F	; 127
    18a8:	a6 e1       	ldi	r26, 0x16	; 22
    18aa:	81 50       	subi	r24, 0x01	; 1
    18ac:	90 40       	sbci	r25, 0x00	; 0
    18ae:	a0 40       	sbci	r26, 0x00	; 0
    18b0:	e1 f7       	brne	.-8      	; 0x18aa <direction+0x420>
    18b2:	00 c0       	rjmp	.+0      	; 0x18b4 <direction+0x42a>
    18b4:	00 00       	nop
			buzzer_off();
			blue_nodes[0]=53;
			blue_nodes[b]=54;
			blue_side[0]=53;
			blue_side[bs]=54;
			for(int i=0;i<=10;i++)
    18b6:	c1 e0       	ldi	r28, 0x01	; 1
    18b8:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(blue_nodes[i]==0)
    18ba:	0e e8       	ldi	r16, 0x8E	; 142
    18bc:	10 e0       	ldi	r17, 0x00	; 0
    18be:	d8 ce       	rjmp	.-592    	; 0x1670 <direction+0x1e6>
			for(int i=0;i<10;i++)
			{	if(green_side[i]==0)
				{
					break;
				}
				USARTWriteChar(green_side[i]);
    18c0:	80 91 a0 00 	lds	r24, 0x00A0
    18c4:	0e 94 43 0a 	call	0x1486	; 0x1486 <USARTWriteChar>
    18c8:	8f ef       	ldi	r24, 0xFF	; 255
    18ca:	9f e7       	ldi	r25, 0x7F	; 127
    18cc:	a6 e1       	ldi	r26, 0x16	; 22
    18ce:	81 50       	subi	r24, 0x01	; 1
    18d0:	90 40       	sbci	r25, 0x00	; 0
    18d2:	a0 40       	sbci	r26, 0x00	; 0
    18d4:	e1 f7       	brne	.-8      	; 0x18ce <direction+0x444>
    18d6:	00 c0       	rjmp	.+0      	; 0x18d8 <direction+0x44e>
    18d8:	00 00       	nop
				
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    18da:	c1 e0       	ldi	r28, 0x01	; 1
    18dc:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(green_side[i]==0)
    18de:	00 ea       	ldi	r16, 0xA0	; 160
    18e0:	10 e0       	ldi	r17, 0x00	; 0
    18e2:	88 ce       	rjmp	.-752    	; 0x15f4 <direction+0x16a>
				{
					
					break;
					
				}
				USARTWriteChar(green_nodes[i]);
    18e4:	80 91 82 00 	lds	r24, 0x0082
    18e8:	0e 94 43 0a 	call	0x1486	; 0x1486 <USARTWriteChar>
    18ec:	8f ef       	ldi	r24, 0xFF	; 255
    18ee:	9f e7       	ldi	r25, 0x7F	; 127
    18f0:	a6 e1       	ldi	r26, 0x16	; 22
    18f2:	81 50       	subi	r24, 0x01	; 1
    18f4:	90 40       	sbci	r25, 0x00	; 0
    18f6:	a0 40       	sbci	r26, 0x00	; 0
    18f8:	e1 f7       	brne	.-8      	; 0x18f2 <direction+0x468>
    18fa:	00 c0       	rjmp	.+0      	; 0x18fc <direction+0x472>
    18fc:	00 00       	nop
			
			green_nodes[0]=55;
			green_nodes[gn]=56;
			green_side[0]=55;
			green_side[gs]=56;
			for(int i=0;i<=10;i++)
    18fe:	c1 e0       	ldi	r28, 0x01	; 1
    1900:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(green_nodes[i]==0)
    1902:	02 e8       	ldi	r16, 0x82	; 130
    1904:	10 e0       	ldi	r17, 0x00	; 0
    1906:	4a ce       	rjmp	.-876    	; 0x159c <direction+0x112>
			
			
		}
//		lcd_print(2,5,dir,2);
	}
}
    1908:	df 91       	pop	r29
    190a:	cf 91       	pop	r28
    190c:	1f 91       	pop	r17
    190e:	0f 91       	pop	r16
    1910:	08 95       	ret

00001912 <array_init>:


void array_init()
{
	for(int i=0;i<=10;i++)
    1912:	80 e0       	ldi	r24, 0x00	; 0
    1914:	90 e0       	ldi	r25, 0x00	; 0
	{
		blue_nodes[i]=0;
    1916:	2e e8       	ldi	r18, 0x8E	; 142
    1918:	30 e0       	ldi	r19, 0x00	; 0
		green_nodes[i]=0;
    191a:	42 e8       	ldi	r20, 0x82	; 130
    191c:	50 e0       	ldi	r21, 0x00	; 0

void array_init()
{
	for(int i=0;i<=10;i++)
	{
		blue_nodes[i]=0;
    191e:	f9 01       	movw	r30, r18
    1920:	e8 0f       	add	r30, r24
    1922:	f9 1f       	adc	r31, r25
    1924:	10 82       	st	Z, r1
		green_nodes[i]=0;
    1926:	fa 01       	movw	r30, r20
    1928:	e8 0f       	add	r30, r24
    192a:	f9 1f       	adc	r31, r25
    192c:	10 82       	st	Z, r1


void array_init()
{
	for(int i=0;i<=10;i++)
    192e:	01 96       	adiw	r24, 0x01	; 1
    1930:	8b 30       	cpi	r24, 0x0B	; 11
    1932:	91 05       	cpc	r25, r1
    1934:	a1 f7       	brne	.-24     	; 0x191e <array_init+0xc>
    1936:	80 e0       	ldi	r24, 0x00	; 0
    1938:	90 e0       	ldi	r25, 0x00	; 0
		blue_nodes[i]=0;
		green_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
	{
		blue_side[i]=0;
    193a:	2c ea       	ldi	r18, 0xAC	; 172
    193c:	30 e0       	ldi	r19, 0x00	; 0
		green_side[i]=0;
    193e:	40 ea       	ldi	r20, 0xA0	; 160
    1940:	50 e0       	ldi	r21, 0x00	; 0
		blue_nodes[i]=0;
		green_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
	{
		blue_side[i]=0;
    1942:	f9 01       	movw	r30, r18
    1944:	e8 0f       	add	r30, r24
    1946:	f9 1f       	adc	r31, r25
    1948:	10 82       	st	Z, r1
		green_side[i]=0;
    194a:	fa 01       	movw	r30, r20
    194c:	e8 0f       	add	r30, r24
    194e:	f9 1f       	adc	r31, r25
    1950:	10 82       	st	Z, r1
	for(int i=0;i<=10;i++)
	{
		blue_nodes[i]=0;
		green_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
    1952:	01 96       	adiw	r24, 0x01	; 1
    1954:	85 31       	cpi	r24, 0x15	; 21
    1956:	91 05       	cpc	r25, r1
    1958:	a1 f7       	brne	.-24     	; 0x1942 <array_init+0x30>
	{
		blue_side[i]=0;
		green_side[i]=0;
	}
}
    195a:	08 95       	ret

0000195c <ReachDestinationAvoidingNode>:
#include "direction.h"
//#include "adjsrc4.h"


void ReachDestinationAvoidingNode(unsigned char Xd,unsigned char Yd)
{
    195c:	cf 93       	push	r28
    195e:	df 93       	push	r29
    1960:	cd b7       	in	r28, 0x3d	; 61
    1962:	de b7       	in	r29, 0x3e	; 62
    1964:	2f 97       	sbiw	r28, 0x0f	; 15
    1966:	0f b6       	in	r0, 0x3f	; 63
    1968:	f8 94       	cli
    196a:	de bf       	out	0x3e, r29	; 62
    196c:	0f be       	out	0x3f, r0	; 63
    196e:	cd bf       	out	0x3d, r28	; 61
	
	

	path1 = main_function7( start,des);
    1970:	ce 01       	movw	r24, r28
    1972:	01 96       	adiw	r24, 0x01	; 1
    1974:	60 91 68 00 	lds	r22, 0x0068
    1978:	40 91 67 00 	lds	r20, 0x0067
    197c:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <main_function7>
    1980:	a8 ec       	ldi	r26, 0xC8	; 200
    1982:	b0 e0       	ldi	r27, 0x00	; 0
    1984:	fe 01       	movw	r30, r28
    1986:	31 96       	adiw	r30, 0x01	; 1
    1988:	8f e0       	ldi	r24, 0x0F	; 15
    198a:	01 90       	ld	r0, Z+
    198c:	0d 92       	st	X+, r0
    198e:	81 50       	subi	r24, 0x01	; 1
    1990:	e1 f7       	brne	.-8      	; 0x198a <ReachDestinationAvoidingNode+0x2e>
	
	
	

	init_devices();
    1992:	0e 94 85 06 	call	0xd0a	; 0xd0a <init_devices>

	

	while(1)
	{
		line_follower();
    1996:	0e 94 8e 06 	call	0xd1c	; 0xd1c <line_follower>
		if (g==1)
    199a:	80 91 81 00 	lds	r24, 0x0081
    199e:	81 30       	cpi	r24, 0x01	; 1
    19a0:	d1 f7       	brne	.-12     	; 0x1996 <ReachDestinationAvoidingNode+0x3a>
			
		
		
	}
	
	g=0;
    19a2:	10 92 81 00 	sts	0x0081, r1
	l=0;
    19a6:	10 92 77 00 	sts	0x0077, r1
	t=0;
    19aa:	10 92 76 00 	sts	0x0076, r1
	/*back();
	velocity(100,100);
	
	_delay_ms(1500);*/
	start=des;
    19ae:	80 91 67 00 	lds	r24, 0x0067
    19b2:	80 93 68 00 	sts	0x0068, r24
}
    19b6:	2f 96       	adiw	r28, 0x0f	; 15
    19b8:	0f b6       	in	r0, 0x3f	; 63
    19ba:	f8 94       	cli
    19bc:	de bf       	out	0x3e, r29	; 62
    19be:	0f be       	out	0x3f, r0	; 63
    19c0:	cd bf       	out	0x3d, r28	; 61
    19c2:	df 91       	pop	r29
    19c4:	cf 91       	pop	r28
    19c6:	08 95       	ret

000019c8 <main>:


//Do not make changes in main function

int main(void)
{   DDRB=0x20; 
    19c8:	80 e2       	ldi	r24, 0x20	; 32
    19ca:	87 bb       	out	0x17, r24	; 23
	init_devices_zigbee();
    19cc:	0e 94 80 09 	call	0x1300	; 0x1300 <init_devices_zigbee>
	init_devices_pos();
    19d0:	0e 94 18 04 	call	0x830	; 0x830 <init_devices_pos>
	stage=1;
    19d4:	81 e0       	ldi	r24, 0x01	; 1
    19d6:	80 93 65 00 	sts	0x0065, r24
	t=0;
    19da:	10 92 76 00 	sts	0x0076, r1
     ReachDestinationAvoidingNode(start,des);//22-6
    19de:	80 91 68 00 	lds	r24, 0x0068
    19e2:	60 91 67 00 	lds	r22, 0x0067
    19e6:	0e 94 ae 0c 	call	0x195c	; 0x195c <ReachDestinationAvoidingNode>
	 buzzer_on();
    19ea:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    19ee:	8f ef       	ldi	r24, 0xFF	; 255
    19f0:	9f e7       	ldi	r25, 0x7F	; 127
    19f2:	a6 e1       	ldi	r26, 0x16	; 22
    19f4:	81 50       	subi	r24, 0x01	; 1
    19f6:	90 40       	sbci	r25, 0x00	; 0
    19f8:	a0 40       	sbci	r26, 0x00	; 0
    19fa:	e1 f7       	brne	.-8      	; 0x19f4 <main+0x2c>
    19fc:	00 c0       	rjmp	.+0      	; 0x19fe <main+0x36>
    19fe:	00 00       	nop
	   _delay_ms(1000);
	   buzzer_off();
    1a00:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
	stage=2;
    1a04:	82 e0       	ldi	r24, 0x02	; 2
    1a06:	80 93 65 00 	sts	0x0065, r24
	//start=5;
	des=48;
    1a0a:	80 e3       	ldi	r24, 0x30	; 48
    1a0c:	80 93 67 00 	sts	0x0067, r24
	array_init();
    1a10:	0e 94 89 0c 	call	0x1912	; 0x1912 <array_init>
		ReachDestinationAvoidingNode(start,des);//6-48
    1a14:	80 91 68 00 	lds	r24, 0x0068
    1a18:	60 91 67 00 	lds	r22, 0x0067
    1a1c:	0e 94 ae 0c 	call	0x195c	; 0x195c <ReachDestinationAvoidingNode>
		buzzer_on();
    1a20:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1a24:	8f ef       	ldi	r24, 0xFF	; 255
    1a26:	9f e7       	ldi	r25, 0x7F	; 127
    1a28:	a6 e1       	ldi	r26, 0x16	; 22
    1a2a:	81 50       	subi	r24, 0x01	; 1
    1a2c:	90 40       	sbci	r25, 0x00	; 0
    1a2e:	a0 40       	sbci	r26, 0x00	; 0
    1a30:	e1 f7       	brne	.-8      	; 0x1a2a <main+0x62>
    1a32:	00 c0       	rjmp	.+0      	; 0x1a34 <main+0x6c>
    1a34:	00 00       	nop
		_delay_ms(1000);
		buzzer_off();
    1a36:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
	//stage=4;
	//des=2;
	//ReachDestinationAvoidingNode(start,des);//4-2
	
 	stage=3;
    1a3a:	83 e0       	ldi	r24, 0x03	; 3
    1a3c:	80 93 65 00 	sts	0x0065, r24
	//start=2;////////
	/////////////stage==3/////start=4///
	des=4;
    1a40:	84 e0       	ldi	r24, 0x04	; 4
    1a42:	80 93 67 00 	sts	0x0067, r24
	ReachDestinationAvoidingNode(start,des);///48-4
    1a46:	80 91 68 00 	lds	r24, 0x0068
    1a4a:	64 e0       	ldi	r22, 0x04	; 4
    1a4c:	0e 94 ae 0c 	call	0x195c	; 0x195c <ReachDestinationAvoidingNode>
	buzzer_on();
    1a50:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1a54:	8f ef       	ldi	r24, 0xFF	; 255
    1a56:	9f e7       	ldi	r25, 0x7F	; 127
    1a58:	a6 e1       	ldi	r26, 0x16	; 22
    1a5a:	81 50       	subi	r24, 0x01	; 1
    1a5c:	90 40       	sbci	r25, 0x00	; 0
    1a5e:	a0 40       	sbci	r26, 0x00	; 0
    1a60:	e1 f7       	brne	.-8      	; 0x1a5a <main+0x92>
    1a62:	00 c0       	rjmp	.+0      	; 0x1a64 <main+0x9c>
    1a64:	00 00       	nop
	_delay_ms(1000);
	buzzer_off();
    1a66:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    1a6a:	60 91 67 00 	lds	r22, 0x0067
    1a6e:	80 e0       	ldi	r24, 0x00	; 0
    1a70:	90 e0       	ldi	r25, 0x00	; 0
	
	//stage=4;
	//des=48;
	_Bool red_des_count=0;
    1a72:	40 e0       	ldi	r20, 0x00	; 0
	for (unsigned char i=0;i<=10;i++)
	{
		switch (red_nodes[i])
    1a74:	23 ef       	ldi	r18, 0xF3	; 243
    1a76:	30 e0       	ldi	r19, 0x00	; 0
			case 9:
			des=9;
			red_des_count=1;
			break;
			case 16:
			des=16;
    1a78:	10 e1       	ldi	r17, 0x10	; 16
			red_des_count=1;
    1a7a:	71 e0       	ldi	r23, 0x01	; 1
			case 23:
			des=23;
			red_des_count=1;
			break;
			case 30:
			des=30;
    1a7c:	de e1       	ldi	r29, 0x1E	; 30
			case 16:
			des=16;
			red_des_count=1;
			break;
			case 23:
			des=23;
    1a7e:	c7 e1       	ldi	r28, 0x17	; 23
	for (unsigned char i=0;i<=10;i++)
	{
		switch (red_nodes[i])
		{
			case 2:
			des=2;
    1a80:	b2 e0       	ldi	r27, 0x02	; 2
			red_des_count=1;
			break;
			case 9:
			des=9;
    1a82:	a9 e0       	ldi	r26, 0x09	; 9
	//stage=4;
	//des=48;
	_Bool red_des_count=0;
	for (unsigned char i=0;i<=10;i++)
	{
		switch (red_nodes[i])
    1a84:	f9 01       	movw	r30, r18
    1a86:	e8 0f       	add	r30, r24
    1a88:	f9 1f       	adc	r31, r25
    1a8a:	50 81       	ld	r21, Z
    1a8c:	50 31       	cpi	r21, 0x10	; 16
    1a8e:	a1 f0       	breq	.+40     	; 0x1ab8 <main+0xf0>
    1a90:	51 31       	cpi	r21, 0x11	; 17
    1a92:	28 f4       	brcc	.+10     	; 0x1a9e <main+0xd6>
    1a94:	52 30       	cpi	r21, 0x02	; 2
    1a96:	51 f0       	breq	.+20     	; 0x1aac <main+0xe4>
    1a98:	59 30       	cpi	r21, 0x09	; 9
    1a9a:	c9 f4       	brne	.+50     	; 0x1ace <main+0x106>
    1a9c:	0a c0       	rjmp	.+20     	; 0x1ab2 <main+0xea>
    1a9e:	5e 31       	cpi	r21, 0x1E	; 30
    1aa0:	89 f0       	breq	.+34     	; 0x1ac4 <main+0xfc>
    1aa2:	55 32       	cpi	r21, 0x25	; 37
    1aa4:	91 f0       	breq	.+36     	; 0x1aca <main+0x102>
    1aa6:	57 31       	cpi	r21, 0x17	; 23
    1aa8:	91 f4       	brne	.+36     	; 0x1ace <main+0x106>
    1aaa:	09 c0       	rjmp	.+18     	; 0x1abe <main+0xf6>
		{
			case 2:
			des=2;
    1aac:	6b 2f       	mov	r22, r27
			red_des_count=1;
    1aae:	47 2f       	mov	r20, r23
			break;
    1ab0:	0e c0       	rjmp	.+28     	; 0x1ace <main+0x106>
			case 9:
			des=9;
    1ab2:	6a 2f       	mov	r22, r26
			red_des_count=1;
    1ab4:	47 2f       	mov	r20, r23
			break;
    1ab6:	0b c0       	rjmp	.+22     	; 0x1ace <main+0x106>
			case 16:
			des=16;
    1ab8:	61 2f       	mov	r22, r17
			red_des_count=1;
    1aba:	47 2f       	mov	r20, r23
			break;
    1abc:	08 c0       	rjmp	.+16     	; 0x1ace <main+0x106>
			case 23:
			des=23;
    1abe:	6c 2f       	mov	r22, r28
			red_des_count=1;
    1ac0:	47 2f       	mov	r20, r23
			break;
    1ac2:	05 c0       	rjmp	.+10     	; 0x1ace <main+0x106>
			case 30:
			des=30;
    1ac4:	6d 2f       	mov	r22, r29
			red_des_count=1;
    1ac6:	47 2f       	mov	r20, r23
			break;
    1ac8:	02 c0       	rjmp	.+4      	; 0x1ace <main+0x106>
			case 37:
			des=37;
    1aca:	65 e2       	ldi	r22, 0x25	; 37
			red_des_count=1;
    1acc:	47 2f       	mov	r20, r23
			break;
    1ace:	01 96       	adiw	r24, 0x01	; 1
	buzzer_off();
	
	//stage=4;
	//des=48;
	_Bool red_des_count=0;
	for (unsigned char i=0;i<=10;i++)
    1ad0:	8b 30       	cpi	r24, 0x0B	; 11
    1ad2:	91 05       	cpc	r25, r1
    1ad4:	b9 f6       	brne	.-82     	; 0x1a84 <main+0xbc>
    1ad6:	60 93 67 00 	sts	0x0067, r22
			break;
			
			
		}
	}
	if (red_des_count==1)
    1ada:	44 23       	and	r20, r20
    1adc:	09 f4       	brne	.+2      	; 0x1ae0 <main+0x118>
    1ade:	46 c0       	rjmp	.+140    	; 0x1b6c <main+0x1a4>
	{
		ReachDestinationAvoidingNode(start,des);//4-X
    1ae0:	80 91 68 00 	lds	r24, 0x0068
    1ae4:	0e 94 ae 0c 	call	0x195c	; 0x195c <ReachDestinationAvoidingNode>
		buzzer_on();
    1ae8:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1aec:	8f ef       	ldi	r24, 0xFF	; 255
    1aee:	9f e7       	ldi	r25, 0x7F	; 127
    1af0:	a6 e1       	ldi	r26, 0x16	; 22
    1af2:	81 50       	subi	r24, 0x01	; 1
    1af4:	90 40       	sbci	r25, 0x00	; 0
    1af6:	a0 40       	sbci	r26, 0x00	; 0
    1af8:	e1 f7       	brne	.-8      	; 0x1af2 <main+0x12a>
    1afa:	00 c0       	rjmp	.+0      	; 0x1afc <main+0x134>
    1afc:	00 00       	nop
		_delay_ms(1000);
		buzzer_off();
    1afe:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
		des=8;
    1b02:	88 e0       	ldi	r24, 0x08	; 8
    1b04:	80 93 67 00 	sts	0x0067, r24
		ReachDestinationAvoidingNode(start,des);//X-8
    1b08:	80 91 68 00 	lds	r24, 0x0068
    1b0c:	68 e0       	ldi	r22, 0x08	; 8
    1b0e:	0e 94 ae 0c 	call	0x195c	; 0x195c <ReachDestinationAvoidingNode>
		buzzer_on();
    1b12:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1b16:	8f ef       	ldi	r24, 0xFF	; 255
    1b18:	9f e3       	ldi	r25, 0x3F	; 63
    1b1a:	ab e0       	ldi	r26, 0x0B	; 11
    1b1c:	81 50       	subi	r24, 0x01	; 1
    1b1e:	90 40       	sbci	r25, 0x00	; 0
    1b20:	a0 40       	sbci	r26, 0x00	; 0
    1b22:	e1 f7       	brne	.-8      	; 0x1b1c <main+0x154>
    1b24:	00 c0       	rjmp	.+0      	; 0x1b26 <main+0x15e>
    1b26:	00 00       	nop
		_delay_ms(500);
		buzzer_off();
    1b28:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    1b2c:	8f ef       	ldi	r24, 0xFF	; 255
    1b2e:	9f e3       	ldi	r25, 0x3F	; 63
    1b30:	ab e0       	ldi	r26, 0x0B	; 11
    1b32:	81 50       	subi	r24, 0x01	; 1
    1b34:	90 40       	sbci	r25, 0x00	; 0
    1b36:	a0 40       	sbci	r26, 0x00	; 0
    1b38:	e1 f7       	brne	.-8      	; 0x1b32 <main+0x16a>
    1b3a:	00 c0       	rjmp	.+0      	; 0x1b3c <main+0x174>
    1b3c:	00 00       	nop
		_delay_ms(500);
		buzzer_on();
    1b3e:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1b42:	8f ef       	ldi	r24, 0xFF	; 255
    1b44:	9f e3       	ldi	r25, 0x3F	; 63
    1b46:	ab e0       	ldi	r26, 0x0B	; 11
    1b48:	81 50       	subi	r24, 0x01	; 1
    1b4a:	90 40       	sbci	r25, 0x00	; 0
    1b4c:	a0 40       	sbci	r26, 0x00	; 0
    1b4e:	e1 f7       	brne	.-8      	; 0x1b48 <main+0x180>
    1b50:	00 c0       	rjmp	.+0      	; 0x1b52 <main+0x18a>
    1b52:	00 00       	nop
		_delay_ms(500);
		buzzer_off();
    1b54:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    1b58:	8f ef       	ldi	r24, 0xFF	; 255
    1b5a:	9f e3       	ldi	r25, 0x3F	; 63
    1b5c:	ab e0       	ldi	r26, 0x0B	; 11
    1b5e:	81 50       	subi	r24, 0x01	; 1
    1b60:	90 40       	sbci	r25, 0x00	; 0
    1b62:	a0 40       	sbci	r26, 0x00	; 0
    1b64:	e1 f7       	brne	.-8      	; 0x1b5e <main+0x196>
    1b66:	00 c0       	rjmp	.+0      	; 0x1b68 <main+0x1a0>
    1b68:	00 00       	nop
    1b6a:	34 c0       	rjmp	.+104    	; 0x1bd4 <main+0x20c>
		_delay_ms(500);
	}
	else if (red_des_count==0)
	{	des=8;
    1b6c:	88 e0       	ldi	r24, 0x08	; 8
    1b6e:	80 93 67 00 	sts	0x0067, r24
		ReachDestinationAvoidingNode(start,des);//4-8
    1b72:	80 91 68 00 	lds	r24, 0x0068
    1b76:	68 e0       	ldi	r22, 0x08	; 8
    1b78:	0e 94 ae 0c 	call	0x195c	; 0x195c <ReachDestinationAvoidingNode>
		buzzer_on();
    1b7c:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1b80:	8f ef       	ldi	r24, 0xFF	; 255
    1b82:	9f e3       	ldi	r25, 0x3F	; 63
    1b84:	ab e0       	ldi	r26, 0x0B	; 11
    1b86:	81 50       	subi	r24, 0x01	; 1
    1b88:	90 40       	sbci	r25, 0x00	; 0
    1b8a:	a0 40       	sbci	r26, 0x00	; 0
    1b8c:	e1 f7       	brne	.-8      	; 0x1b86 <main+0x1be>
    1b8e:	00 c0       	rjmp	.+0      	; 0x1b90 <main+0x1c8>
    1b90:	00 00       	nop
		_delay_ms(500);
		buzzer_off();
    1b92:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    1b96:	8f ef       	ldi	r24, 0xFF	; 255
    1b98:	9f e3       	ldi	r25, 0x3F	; 63
    1b9a:	ab e0       	ldi	r26, 0x0B	; 11
    1b9c:	81 50       	subi	r24, 0x01	; 1
    1b9e:	90 40       	sbci	r25, 0x00	; 0
    1ba0:	a0 40       	sbci	r26, 0x00	; 0
    1ba2:	e1 f7       	brne	.-8      	; 0x1b9c <main+0x1d4>
    1ba4:	00 c0       	rjmp	.+0      	; 0x1ba6 <main+0x1de>
    1ba6:	00 00       	nop
		_delay_ms(500);
		
		buzzer_on();
    1ba8:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1bac:	8f ef       	ldi	r24, 0xFF	; 255
    1bae:	9f e3       	ldi	r25, 0x3F	; 63
    1bb0:	ab e0       	ldi	r26, 0x0B	; 11
    1bb2:	81 50       	subi	r24, 0x01	; 1
    1bb4:	90 40       	sbci	r25, 0x00	; 0
    1bb6:	a0 40       	sbci	r26, 0x00	; 0
    1bb8:	e1 f7       	brne	.-8      	; 0x1bb2 <main+0x1ea>
    1bba:	00 c0       	rjmp	.+0      	; 0x1bbc <main+0x1f4>
    1bbc:	00 00       	nop
		_delay_ms(500);
		buzzer_off();
    1bbe:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    1bc2:	8f ef       	ldi	r24, 0xFF	; 255
    1bc4:	9f e3       	ldi	r25, 0x3F	; 63
    1bc6:	ab e0       	ldi	r26, 0x0B	; 11
    1bc8:	81 50       	subi	r24, 0x01	; 1
    1bca:	90 40       	sbci	r25, 0x00	; 0
    1bcc:	a0 40       	sbci	r26, 0x00	; 0
    1bce:	e1 f7       	brne	.-8      	; 0x1bc8 <main+0x200>
    1bd0:	00 c0       	rjmp	.+0      	; 0x1bd2 <main+0x20a>
    1bd2:	00 00       	nop
	
	
	
	
	
	forward();
    1bd4:	0e 94 81 05 	call	0xb02	; 0xb02 <forward>
	velocity(0,0);
    1bd8:	80 e0       	ldi	r24, 0x00	; 0
    1bda:	60 e0       	ldi	r22, 0x00	; 0
    1bdc:	0e 94 a1 05 	call	0xb42	; 0xb42 <velocity>
    1be0:	ff cf       	rjmp	.-2      	; 0x1be0 <main+0x218>

00001be2 <__subsf3>:
    1be2:	50 58       	subi	r21, 0x80	; 128

00001be4 <__addsf3>:
    1be4:	bb 27       	eor	r27, r27
    1be6:	aa 27       	eor	r26, r26
    1be8:	0e d0       	rcall	.+28     	; 0x1c06 <__addsf3x>
    1bea:	48 c1       	rjmp	.+656    	; 0x1e7c <__fp_round>
    1bec:	39 d1       	rcall	.+626    	; 0x1e60 <__fp_pscA>
    1bee:	30 f0       	brcs	.+12     	; 0x1bfc <__addsf3+0x18>
    1bf0:	3e d1       	rcall	.+636    	; 0x1e6e <__fp_pscB>
    1bf2:	20 f0       	brcs	.+8      	; 0x1bfc <__addsf3+0x18>
    1bf4:	31 f4       	brne	.+12     	; 0x1c02 <__addsf3+0x1e>
    1bf6:	9f 3f       	cpi	r25, 0xFF	; 255
    1bf8:	11 f4       	brne	.+4      	; 0x1bfe <__addsf3+0x1a>
    1bfa:	1e f4       	brtc	.+6      	; 0x1c02 <__addsf3+0x1e>
    1bfc:	2e c1       	rjmp	.+604    	; 0x1e5a <__fp_nan>
    1bfe:	0e f4       	brtc	.+2      	; 0x1c02 <__addsf3+0x1e>
    1c00:	e0 95       	com	r30
    1c02:	e7 fb       	bst	r30, 7
    1c04:	24 c1       	rjmp	.+584    	; 0x1e4e <__fp_inf>

00001c06 <__addsf3x>:
    1c06:	e9 2f       	mov	r30, r25
    1c08:	4a d1       	rcall	.+660    	; 0x1e9e <__fp_split3>
    1c0a:	80 f3       	brcs	.-32     	; 0x1bec <__addsf3+0x8>
    1c0c:	ba 17       	cp	r27, r26
    1c0e:	62 07       	cpc	r22, r18
    1c10:	73 07       	cpc	r23, r19
    1c12:	84 07       	cpc	r24, r20
    1c14:	95 07       	cpc	r25, r21
    1c16:	18 f0       	brcs	.+6      	; 0x1c1e <__addsf3x+0x18>
    1c18:	71 f4       	brne	.+28     	; 0x1c36 <__addsf3x+0x30>
    1c1a:	9e f5       	brtc	.+102    	; 0x1c82 <__addsf3x+0x7c>
    1c1c:	62 c1       	rjmp	.+708    	; 0x1ee2 <__fp_zero>
    1c1e:	0e f4       	brtc	.+2      	; 0x1c22 <__addsf3x+0x1c>
    1c20:	e0 95       	com	r30
    1c22:	0b 2e       	mov	r0, r27
    1c24:	ba 2f       	mov	r27, r26
    1c26:	a0 2d       	mov	r26, r0
    1c28:	0b 01       	movw	r0, r22
    1c2a:	b9 01       	movw	r22, r18
    1c2c:	90 01       	movw	r18, r0
    1c2e:	0c 01       	movw	r0, r24
    1c30:	ca 01       	movw	r24, r20
    1c32:	a0 01       	movw	r20, r0
    1c34:	11 24       	eor	r1, r1
    1c36:	ff 27       	eor	r31, r31
    1c38:	59 1b       	sub	r21, r25
    1c3a:	99 f0       	breq	.+38     	; 0x1c62 <__addsf3x+0x5c>
    1c3c:	59 3f       	cpi	r21, 0xF9	; 249
    1c3e:	50 f4       	brcc	.+20     	; 0x1c54 <__addsf3x+0x4e>
    1c40:	50 3e       	cpi	r21, 0xE0	; 224
    1c42:	68 f1       	brcs	.+90     	; 0x1c9e <__addsf3x+0x98>
    1c44:	1a 16       	cp	r1, r26
    1c46:	f0 40       	sbci	r31, 0x00	; 0
    1c48:	a2 2f       	mov	r26, r18
    1c4a:	23 2f       	mov	r18, r19
    1c4c:	34 2f       	mov	r19, r20
    1c4e:	44 27       	eor	r20, r20
    1c50:	58 5f       	subi	r21, 0xF8	; 248
    1c52:	f3 cf       	rjmp	.-26     	; 0x1c3a <__addsf3x+0x34>
    1c54:	46 95       	lsr	r20
    1c56:	37 95       	ror	r19
    1c58:	27 95       	ror	r18
    1c5a:	a7 95       	ror	r26
    1c5c:	f0 40       	sbci	r31, 0x00	; 0
    1c5e:	53 95       	inc	r21
    1c60:	c9 f7       	brne	.-14     	; 0x1c54 <__addsf3x+0x4e>
    1c62:	7e f4       	brtc	.+30     	; 0x1c82 <__addsf3x+0x7c>
    1c64:	1f 16       	cp	r1, r31
    1c66:	ba 0b       	sbc	r27, r26
    1c68:	62 0b       	sbc	r22, r18
    1c6a:	73 0b       	sbc	r23, r19
    1c6c:	84 0b       	sbc	r24, r20
    1c6e:	ba f0       	brmi	.+46     	; 0x1c9e <__addsf3x+0x98>
    1c70:	91 50       	subi	r25, 0x01	; 1
    1c72:	a1 f0       	breq	.+40     	; 0x1c9c <__addsf3x+0x96>
    1c74:	ff 0f       	add	r31, r31
    1c76:	bb 1f       	adc	r27, r27
    1c78:	66 1f       	adc	r22, r22
    1c7a:	77 1f       	adc	r23, r23
    1c7c:	88 1f       	adc	r24, r24
    1c7e:	c2 f7       	brpl	.-16     	; 0x1c70 <__addsf3x+0x6a>
    1c80:	0e c0       	rjmp	.+28     	; 0x1c9e <__addsf3x+0x98>
    1c82:	ba 0f       	add	r27, r26
    1c84:	62 1f       	adc	r22, r18
    1c86:	73 1f       	adc	r23, r19
    1c88:	84 1f       	adc	r24, r20
    1c8a:	48 f4       	brcc	.+18     	; 0x1c9e <__addsf3x+0x98>
    1c8c:	87 95       	ror	r24
    1c8e:	77 95       	ror	r23
    1c90:	67 95       	ror	r22
    1c92:	b7 95       	ror	r27
    1c94:	f7 95       	ror	r31
    1c96:	9e 3f       	cpi	r25, 0xFE	; 254
    1c98:	08 f0       	brcs	.+2      	; 0x1c9c <__addsf3x+0x96>
    1c9a:	b3 cf       	rjmp	.-154    	; 0x1c02 <__addsf3+0x1e>
    1c9c:	93 95       	inc	r25
    1c9e:	88 0f       	add	r24, r24
    1ca0:	08 f0       	brcs	.+2      	; 0x1ca4 <__addsf3x+0x9e>
    1ca2:	99 27       	eor	r25, r25
    1ca4:	ee 0f       	add	r30, r30
    1ca6:	97 95       	ror	r25
    1ca8:	87 95       	ror	r24
    1caa:	08 95       	ret

00001cac <__divsf3>:
    1cac:	0c d0       	rcall	.+24     	; 0x1cc6 <__divsf3x>
    1cae:	e6 c0       	rjmp	.+460    	; 0x1e7c <__fp_round>
    1cb0:	de d0       	rcall	.+444    	; 0x1e6e <__fp_pscB>
    1cb2:	40 f0       	brcs	.+16     	; 0x1cc4 <__divsf3+0x18>
    1cb4:	d5 d0       	rcall	.+426    	; 0x1e60 <__fp_pscA>
    1cb6:	30 f0       	brcs	.+12     	; 0x1cc4 <__divsf3+0x18>
    1cb8:	21 f4       	brne	.+8      	; 0x1cc2 <__divsf3+0x16>
    1cba:	5f 3f       	cpi	r21, 0xFF	; 255
    1cbc:	19 f0       	breq	.+6      	; 0x1cc4 <__divsf3+0x18>
    1cbe:	c7 c0       	rjmp	.+398    	; 0x1e4e <__fp_inf>
    1cc0:	51 11       	cpse	r21, r1
    1cc2:	10 c1       	rjmp	.+544    	; 0x1ee4 <__fp_szero>
    1cc4:	ca c0       	rjmp	.+404    	; 0x1e5a <__fp_nan>

00001cc6 <__divsf3x>:
    1cc6:	eb d0       	rcall	.+470    	; 0x1e9e <__fp_split3>
    1cc8:	98 f3       	brcs	.-26     	; 0x1cb0 <__divsf3+0x4>

00001cca <__divsf3_pse>:
    1cca:	99 23       	and	r25, r25
    1ccc:	c9 f3       	breq	.-14     	; 0x1cc0 <__divsf3+0x14>
    1cce:	55 23       	and	r21, r21
    1cd0:	b1 f3       	breq	.-20     	; 0x1cbe <__divsf3+0x12>
    1cd2:	95 1b       	sub	r25, r21
    1cd4:	55 0b       	sbc	r21, r21
    1cd6:	bb 27       	eor	r27, r27
    1cd8:	aa 27       	eor	r26, r26
    1cda:	62 17       	cp	r22, r18
    1cdc:	73 07       	cpc	r23, r19
    1cde:	84 07       	cpc	r24, r20
    1ce0:	38 f0       	brcs	.+14     	; 0x1cf0 <__divsf3_pse+0x26>
    1ce2:	9f 5f       	subi	r25, 0xFF	; 255
    1ce4:	5f 4f       	sbci	r21, 0xFF	; 255
    1ce6:	22 0f       	add	r18, r18
    1ce8:	33 1f       	adc	r19, r19
    1cea:	44 1f       	adc	r20, r20
    1cec:	aa 1f       	adc	r26, r26
    1cee:	a9 f3       	breq	.-22     	; 0x1cda <__divsf3_pse+0x10>
    1cf0:	33 d0       	rcall	.+102    	; 0x1d58 <__divsf3_pse+0x8e>
    1cf2:	0e 2e       	mov	r0, r30
    1cf4:	3a f0       	brmi	.+14     	; 0x1d04 <__divsf3_pse+0x3a>
    1cf6:	e0 e8       	ldi	r30, 0x80	; 128
    1cf8:	30 d0       	rcall	.+96     	; 0x1d5a <__divsf3_pse+0x90>
    1cfa:	91 50       	subi	r25, 0x01	; 1
    1cfc:	50 40       	sbci	r21, 0x00	; 0
    1cfe:	e6 95       	lsr	r30
    1d00:	00 1c       	adc	r0, r0
    1d02:	ca f7       	brpl	.-14     	; 0x1cf6 <__divsf3_pse+0x2c>
    1d04:	29 d0       	rcall	.+82     	; 0x1d58 <__divsf3_pse+0x8e>
    1d06:	fe 2f       	mov	r31, r30
    1d08:	27 d0       	rcall	.+78     	; 0x1d58 <__divsf3_pse+0x8e>
    1d0a:	66 0f       	add	r22, r22
    1d0c:	77 1f       	adc	r23, r23
    1d0e:	88 1f       	adc	r24, r24
    1d10:	bb 1f       	adc	r27, r27
    1d12:	26 17       	cp	r18, r22
    1d14:	37 07       	cpc	r19, r23
    1d16:	48 07       	cpc	r20, r24
    1d18:	ab 07       	cpc	r26, r27
    1d1a:	b0 e8       	ldi	r27, 0x80	; 128
    1d1c:	09 f0       	breq	.+2      	; 0x1d20 <__divsf3_pse+0x56>
    1d1e:	bb 0b       	sbc	r27, r27
    1d20:	80 2d       	mov	r24, r0
    1d22:	bf 01       	movw	r22, r30
    1d24:	ff 27       	eor	r31, r31
    1d26:	93 58       	subi	r25, 0x83	; 131
    1d28:	5f 4f       	sbci	r21, 0xFF	; 255
    1d2a:	2a f0       	brmi	.+10     	; 0x1d36 <__divsf3_pse+0x6c>
    1d2c:	9e 3f       	cpi	r25, 0xFE	; 254
    1d2e:	51 05       	cpc	r21, r1
    1d30:	68 f0       	brcs	.+26     	; 0x1d4c <__divsf3_pse+0x82>
    1d32:	8d c0       	rjmp	.+282    	; 0x1e4e <__fp_inf>
    1d34:	d7 c0       	rjmp	.+430    	; 0x1ee4 <__fp_szero>
    1d36:	5f 3f       	cpi	r21, 0xFF	; 255
    1d38:	ec f3       	brlt	.-6      	; 0x1d34 <__divsf3_pse+0x6a>
    1d3a:	98 3e       	cpi	r25, 0xE8	; 232
    1d3c:	dc f3       	brlt	.-10     	; 0x1d34 <__divsf3_pse+0x6a>
    1d3e:	86 95       	lsr	r24
    1d40:	77 95       	ror	r23
    1d42:	67 95       	ror	r22
    1d44:	b7 95       	ror	r27
    1d46:	f7 95       	ror	r31
    1d48:	9f 5f       	subi	r25, 0xFF	; 255
    1d4a:	c9 f7       	brne	.-14     	; 0x1d3e <__divsf3_pse+0x74>
    1d4c:	88 0f       	add	r24, r24
    1d4e:	91 1d       	adc	r25, r1
    1d50:	96 95       	lsr	r25
    1d52:	87 95       	ror	r24
    1d54:	97 f9       	bld	r25, 7
    1d56:	08 95       	ret
    1d58:	e1 e0       	ldi	r30, 0x01	; 1
    1d5a:	66 0f       	add	r22, r22
    1d5c:	77 1f       	adc	r23, r23
    1d5e:	88 1f       	adc	r24, r24
    1d60:	bb 1f       	adc	r27, r27
    1d62:	62 17       	cp	r22, r18
    1d64:	73 07       	cpc	r23, r19
    1d66:	84 07       	cpc	r24, r20
    1d68:	ba 07       	cpc	r27, r26
    1d6a:	20 f0       	brcs	.+8      	; 0x1d74 <__divsf3_pse+0xaa>
    1d6c:	62 1b       	sub	r22, r18
    1d6e:	73 0b       	sbc	r23, r19
    1d70:	84 0b       	sbc	r24, r20
    1d72:	ba 0b       	sbc	r27, r26
    1d74:	ee 1f       	adc	r30, r30
    1d76:	88 f7       	brcc	.-30     	; 0x1d5a <__divsf3_pse+0x90>
    1d78:	e0 95       	com	r30
    1d7a:	08 95       	ret

00001d7c <__fixunssfsi>:
    1d7c:	98 d0       	rcall	.+304    	; 0x1eae <__fp_splitA>
    1d7e:	88 f0       	brcs	.+34     	; 0x1da2 <__fixunssfsi+0x26>
    1d80:	9f 57       	subi	r25, 0x7F	; 127
    1d82:	90 f0       	brcs	.+36     	; 0x1da8 <__fixunssfsi+0x2c>
    1d84:	b9 2f       	mov	r27, r25
    1d86:	99 27       	eor	r25, r25
    1d88:	b7 51       	subi	r27, 0x17	; 23
    1d8a:	a0 f0       	brcs	.+40     	; 0x1db4 <__fixunssfsi+0x38>
    1d8c:	d1 f0       	breq	.+52     	; 0x1dc2 <__fixunssfsi+0x46>
    1d8e:	66 0f       	add	r22, r22
    1d90:	77 1f       	adc	r23, r23
    1d92:	88 1f       	adc	r24, r24
    1d94:	99 1f       	adc	r25, r25
    1d96:	1a f0       	brmi	.+6      	; 0x1d9e <__fixunssfsi+0x22>
    1d98:	ba 95       	dec	r27
    1d9a:	c9 f7       	brne	.-14     	; 0x1d8e <__fixunssfsi+0x12>
    1d9c:	12 c0       	rjmp	.+36     	; 0x1dc2 <__fixunssfsi+0x46>
    1d9e:	b1 30       	cpi	r27, 0x01	; 1
    1da0:	81 f0       	breq	.+32     	; 0x1dc2 <__fixunssfsi+0x46>
    1da2:	9f d0       	rcall	.+318    	; 0x1ee2 <__fp_zero>
    1da4:	b1 e0       	ldi	r27, 0x01	; 1
    1da6:	08 95       	ret
    1da8:	9c c0       	rjmp	.+312    	; 0x1ee2 <__fp_zero>
    1daa:	67 2f       	mov	r22, r23
    1dac:	78 2f       	mov	r23, r24
    1dae:	88 27       	eor	r24, r24
    1db0:	b8 5f       	subi	r27, 0xF8	; 248
    1db2:	39 f0       	breq	.+14     	; 0x1dc2 <__fixunssfsi+0x46>
    1db4:	b9 3f       	cpi	r27, 0xF9	; 249
    1db6:	cc f3       	brlt	.-14     	; 0x1daa <__fixunssfsi+0x2e>
    1db8:	86 95       	lsr	r24
    1dba:	77 95       	ror	r23
    1dbc:	67 95       	ror	r22
    1dbe:	b3 95       	inc	r27
    1dc0:	d9 f7       	brne	.-10     	; 0x1db8 <__fixunssfsi+0x3c>
    1dc2:	3e f4       	brtc	.+14     	; 0x1dd2 <__fixunssfsi+0x56>
    1dc4:	90 95       	com	r25
    1dc6:	80 95       	com	r24
    1dc8:	70 95       	com	r23
    1dca:	61 95       	neg	r22
    1dcc:	7f 4f       	sbci	r23, 0xFF	; 255
    1dce:	8f 4f       	sbci	r24, 0xFF	; 255
    1dd0:	9f 4f       	sbci	r25, 0xFF	; 255
    1dd2:	08 95       	ret

00001dd4 <__floatunsisf>:
    1dd4:	e8 94       	clt
    1dd6:	09 c0       	rjmp	.+18     	; 0x1dea <__floatsisf+0x12>

00001dd8 <__floatsisf>:
    1dd8:	97 fb       	bst	r25, 7
    1dda:	3e f4       	brtc	.+14     	; 0x1dea <__floatsisf+0x12>
    1ddc:	90 95       	com	r25
    1dde:	80 95       	com	r24
    1de0:	70 95       	com	r23
    1de2:	61 95       	neg	r22
    1de4:	7f 4f       	sbci	r23, 0xFF	; 255
    1de6:	8f 4f       	sbci	r24, 0xFF	; 255
    1de8:	9f 4f       	sbci	r25, 0xFF	; 255
    1dea:	99 23       	and	r25, r25
    1dec:	a9 f0       	breq	.+42     	; 0x1e18 <__floatsisf+0x40>
    1dee:	f9 2f       	mov	r31, r25
    1df0:	96 e9       	ldi	r25, 0x96	; 150
    1df2:	bb 27       	eor	r27, r27
    1df4:	93 95       	inc	r25
    1df6:	f6 95       	lsr	r31
    1df8:	87 95       	ror	r24
    1dfa:	77 95       	ror	r23
    1dfc:	67 95       	ror	r22
    1dfe:	b7 95       	ror	r27
    1e00:	f1 11       	cpse	r31, r1
    1e02:	f8 cf       	rjmp	.-16     	; 0x1df4 <__floatsisf+0x1c>
    1e04:	fa f4       	brpl	.+62     	; 0x1e44 <__floatsisf+0x6c>
    1e06:	bb 0f       	add	r27, r27
    1e08:	11 f4       	brne	.+4      	; 0x1e0e <__floatsisf+0x36>
    1e0a:	60 ff       	sbrs	r22, 0
    1e0c:	1b c0       	rjmp	.+54     	; 0x1e44 <__floatsisf+0x6c>
    1e0e:	6f 5f       	subi	r22, 0xFF	; 255
    1e10:	7f 4f       	sbci	r23, 0xFF	; 255
    1e12:	8f 4f       	sbci	r24, 0xFF	; 255
    1e14:	9f 4f       	sbci	r25, 0xFF	; 255
    1e16:	16 c0       	rjmp	.+44     	; 0x1e44 <__floatsisf+0x6c>
    1e18:	88 23       	and	r24, r24
    1e1a:	11 f0       	breq	.+4      	; 0x1e20 <__floatsisf+0x48>
    1e1c:	96 e9       	ldi	r25, 0x96	; 150
    1e1e:	11 c0       	rjmp	.+34     	; 0x1e42 <__floatsisf+0x6a>
    1e20:	77 23       	and	r23, r23
    1e22:	21 f0       	breq	.+8      	; 0x1e2c <__floatsisf+0x54>
    1e24:	9e e8       	ldi	r25, 0x8E	; 142
    1e26:	87 2f       	mov	r24, r23
    1e28:	76 2f       	mov	r23, r22
    1e2a:	05 c0       	rjmp	.+10     	; 0x1e36 <__floatsisf+0x5e>
    1e2c:	66 23       	and	r22, r22
    1e2e:	71 f0       	breq	.+28     	; 0x1e4c <__floatsisf+0x74>
    1e30:	96 e8       	ldi	r25, 0x86	; 134
    1e32:	86 2f       	mov	r24, r22
    1e34:	70 e0       	ldi	r23, 0x00	; 0
    1e36:	60 e0       	ldi	r22, 0x00	; 0
    1e38:	2a f0       	brmi	.+10     	; 0x1e44 <__floatsisf+0x6c>
    1e3a:	9a 95       	dec	r25
    1e3c:	66 0f       	add	r22, r22
    1e3e:	77 1f       	adc	r23, r23
    1e40:	88 1f       	adc	r24, r24
    1e42:	da f7       	brpl	.-10     	; 0x1e3a <__floatsisf+0x62>
    1e44:	88 0f       	add	r24, r24
    1e46:	96 95       	lsr	r25
    1e48:	87 95       	ror	r24
    1e4a:	97 f9       	bld	r25, 7
    1e4c:	08 95       	ret

00001e4e <__fp_inf>:
    1e4e:	97 f9       	bld	r25, 7
    1e50:	9f 67       	ori	r25, 0x7F	; 127
    1e52:	80 e8       	ldi	r24, 0x80	; 128
    1e54:	70 e0       	ldi	r23, 0x00	; 0
    1e56:	60 e0       	ldi	r22, 0x00	; 0
    1e58:	08 95       	ret

00001e5a <__fp_nan>:
    1e5a:	9f ef       	ldi	r25, 0xFF	; 255
    1e5c:	80 ec       	ldi	r24, 0xC0	; 192
    1e5e:	08 95       	ret

00001e60 <__fp_pscA>:
    1e60:	00 24       	eor	r0, r0
    1e62:	0a 94       	dec	r0
    1e64:	16 16       	cp	r1, r22
    1e66:	17 06       	cpc	r1, r23
    1e68:	18 06       	cpc	r1, r24
    1e6a:	09 06       	cpc	r0, r25
    1e6c:	08 95       	ret

00001e6e <__fp_pscB>:
    1e6e:	00 24       	eor	r0, r0
    1e70:	0a 94       	dec	r0
    1e72:	12 16       	cp	r1, r18
    1e74:	13 06       	cpc	r1, r19
    1e76:	14 06       	cpc	r1, r20
    1e78:	05 06       	cpc	r0, r21
    1e7a:	08 95       	ret

00001e7c <__fp_round>:
    1e7c:	09 2e       	mov	r0, r25
    1e7e:	03 94       	inc	r0
    1e80:	00 0c       	add	r0, r0
    1e82:	11 f4       	brne	.+4      	; 0x1e88 <__fp_round+0xc>
    1e84:	88 23       	and	r24, r24
    1e86:	52 f0       	brmi	.+20     	; 0x1e9c <__fp_round+0x20>
    1e88:	bb 0f       	add	r27, r27
    1e8a:	40 f4       	brcc	.+16     	; 0x1e9c <__fp_round+0x20>
    1e8c:	bf 2b       	or	r27, r31
    1e8e:	11 f4       	brne	.+4      	; 0x1e94 <__fp_round+0x18>
    1e90:	60 ff       	sbrs	r22, 0
    1e92:	04 c0       	rjmp	.+8      	; 0x1e9c <__fp_round+0x20>
    1e94:	6f 5f       	subi	r22, 0xFF	; 255
    1e96:	7f 4f       	sbci	r23, 0xFF	; 255
    1e98:	8f 4f       	sbci	r24, 0xFF	; 255
    1e9a:	9f 4f       	sbci	r25, 0xFF	; 255
    1e9c:	08 95       	ret

00001e9e <__fp_split3>:
    1e9e:	57 fd       	sbrc	r21, 7
    1ea0:	90 58       	subi	r25, 0x80	; 128
    1ea2:	44 0f       	add	r20, r20
    1ea4:	55 1f       	adc	r21, r21
    1ea6:	59 f0       	breq	.+22     	; 0x1ebe <__fp_splitA+0x10>
    1ea8:	5f 3f       	cpi	r21, 0xFF	; 255
    1eaa:	71 f0       	breq	.+28     	; 0x1ec8 <__fp_splitA+0x1a>
    1eac:	47 95       	ror	r20

00001eae <__fp_splitA>:
    1eae:	88 0f       	add	r24, r24
    1eb0:	97 fb       	bst	r25, 7
    1eb2:	99 1f       	adc	r25, r25
    1eb4:	61 f0       	breq	.+24     	; 0x1ece <__fp_splitA+0x20>
    1eb6:	9f 3f       	cpi	r25, 0xFF	; 255
    1eb8:	79 f0       	breq	.+30     	; 0x1ed8 <__fp_splitA+0x2a>
    1eba:	87 95       	ror	r24
    1ebc:	08 95       	ret
    1ebe:	12 16       	cp	r1, r18
    1ec0:	13 06       	cpc	r1, r19
    1ec2:	14 06       	cpc	r1, r20
    1ec4:	55 1f       	adc	r21, r21
    1ec6:	f2 cf       	rjmp	.-28     	; 0x1eac <__fp_split3+0xe>
    1ec8:	46 95       	lsr	r20
    1eca:	f1 df       	rcall	.-30     	; 0x1eae <__fp_splitA>
    1ecc:	08 c0       	rjmp	.+16     	; 0x1ede <__fp_splitA+0x30>
    1ece:	16 16       	cp	r1, r22
    1ed0:	17 06       	cpc	r1, r23
    1ed2:	18 06       	cpc	r1, r24
    1ed4:	99 1f       	adc	r25, r25
    1ed6:	f1 cf       	rjmp	.-30     	; 0x1eba <__fp_splitA+0xc>
    1ed8:	86 95       	lsr	r24
    1eda:	71 05       	cpc	r23, r1
    1edc:	61 05       	cpc	r22, r1
    1ede:	08 94       	sec
    1ee0:	08 95       	ret

00001ee2 <__fp_zero>:
    1ee2:	e8 94       	clt

00001ee4 <__fp_szero>:
    1ee4:	bb 27       	eor	r27, r27
    1ee6:	66 27       	eor	r22, r22
    1ee8:	77 27       	eor	r23, r23
    1eea:	cb 01       	movw	r24, r22
    1eec:	97 f9       	bld	r25, 7
    1eee:	08 95       	ret

00001ef0 <__divmodhi4>:
    1ef0:	97 fb       	bst	r25, 7
    1ef2:	09 2e       	mov	r0, r25
    1ef4:	07 26       	eor	r0, r23
    1ef6:	0a d0       	rcall	.+20     	; 0x1f0c <__divmodhi4_neg1>
    1ef8:	77 fd       	sbrc	r23, 7
    1efa:	04 d0       	rcall	.+8      	; 0x1f04 <__divmodhi4_neg2>
    1efc:	0c d0       	rcall	.+24     	; 0x1f16 <__udivmodhi4>
    1efe:	06 d0       	rcall	.+12     	; 0x1f0c <__divmodhi4_neg1>
    1f00:	00 20       	and	r0, r0
    1f02:	1a f4       	brpl	.+6      	; 0x1f0a <__divmodhi4_exit>

00001f04 <__divmodhi4_neg2>:
    1f04:	70 95       	com	r23
    1f06:	61 95       	neg	r22
    1f08:	7f 4f       	sbci	r23, 0xFF	; 255

00001f0a <__divmodhi4_exit>:
    1f0a:	08 95       	ret

00001f0c <__divmodhi4_neg1>:
    1f0c:	f6 f7       	brtc	.-4      	; 0x1f0a <__divmodhi4_exit>
    1f0e:	90 95       	com	r25
    1f10:	81 95       	neg	r24
    1f12:	9f 4f       	sbci	r25, 0xFF	; 255
    1f14:	08 95       	ret

00001f16 <__udivmodhi4>:
    1f16:	aa 1b       	sub	r26, r26
    1f18:	bb 1b       	sub	r27, r27
    1f1a:	51 e1       	ldi	r21, 0x11	; 17
    1f1c:	07 c0       	rjmp	.+14     	; 0x1f2c <__udivmodhi4_ep>

00001f1e <__udivmodhi4_loop>:
    1f1e:	aa 1f       	adc	r26, r26
    1f20:	bb 1f       	adc	r27, r27
    1f22:	a6 17       	cp	r26, r22
    1f24:	b7 07       	cpc	r27, r23
    1f26:	10 f0       	brcs	.+4      	; 0x1f2c <__udivmodhi4_ep>
    1f28:	a6 1b       	sub	r26, r22
    1f2a:	b7 0b       	sbc	r27, r23

00001f2c <__udivmodhi4_ep>:
    1f2c:	88 1f       	adc	r24, r24
    1f2e:	99 1f       	adc	r25, r25
    1f30:	5a 95       	dec	r21
    1f32:	a9 f7       	brne	.-22     	; 0x1f1e <__udivmodhi4_loop>
    1f34:	80 95       	com	r24
    1f36:	90 95       	com	r25
    1f38:	bc 01       	movw	r22, r24
    1f3a:	cd 01       	movw	r24, r26
    1f3c:	08 95       	ret

00001f3e <_exit>:
    1f3e:	f8 94       	cli

00001f40 <__stop_program>:
    1f40:	ff cf       	rjmp	.-2      	; 0x1f40 <__stop_program>
