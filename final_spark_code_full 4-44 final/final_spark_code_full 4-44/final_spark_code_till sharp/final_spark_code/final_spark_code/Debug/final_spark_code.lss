
final_spark_code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001d9e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000a  00800060  00001d9e  00001e32  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000a9  0080006a  0080006a  00001e3c  2**0
                  ALLOC
  3 .stab         00001be4  00000000  00000000  00001e3c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000583  00000000  00000000  00003a20  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00003fa8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002aa5  00000000  00000000  00004068  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000479  00000000  00000000  00006b0d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000c6d  00000000  00000000  00006f86  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000854  00000000  00000000  00007bf4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000902  00000000  00000000  00008448  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000217d  00000000  00000000  00008d4a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000150  00000000  00000000  0000aec7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 cd 02 	jmp	0x59a	; 0x59a <__vector_1>
       8:	0c 94 f2 02 	jmp	0x5e4	; 0x5e4 <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 9e 07 	jmp	0xf3c	; 0xf3c <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 46 09 	jmp	0x128c	; 0x128c <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e9       	ldi	r30, 0x9E	; 158
      68:	fd e1       	ldi	r31, 0x1D	; 29
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 36       	cpi	r26, 0x6A	; 106
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	aa e6       	ldi	r26, 0x6A	; 106
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 31       	cpi	r26, 0x13	; 19
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 a9 0c 	call	0x1952	; 0x1952 <main>
      8a:	0c 94 cd 0e 	jmp	0x1d9a	; 0x1d9a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <do_task>:
		green_side[i]=0;
	}
}
void do_task()
{	
	if(task==1)//red
      92:	80 91 72 00 	lds	r24, 0x0072
      96:	81 30       	cpi	r24, 0x01	; 1
      98:	f1 f4       	brne	.+60     	; 0xd6 <do_task+0x44>
	{	
		red_nodes[r]=path1.path[t];
      9a:	90 91 64 00 	lds	r25, 0x0064
      9e:	80 91 73 00 	lds	r24, 0x0073
      a2:	e8 ec       	ldi	r30, 0xC8	; 200
      a4:	f0 e0       	ldi	r31, 0x00	; 0
      a6:	e8 0f       	add	r30, r24
      a8:	f1 1d       	adc	r31, r1
      aa:	80 81       	ld	r24, Z
      ac:	e3 ef       	ldi	r30, 0xF3	; 243
      ae:	f0 e0       	ldi	r31, 0x00	; 0
      b0:	e9 0f       	add	r30, r25
      b2:	f1 1d       	adc	r31, r1
      b4:	80 83       	st	Z, r24
		red_side[rs]=side;
      b6:	80 91 63 00 	lds	r24, 0x0063
      ba:	20 91 71 00 	lds	r18, 0x0071
      be:	ef ef       	ldi	r30, 0xFF	; 255
      c0:	f0 e0       	ldi	r31, 0x00	; 0
      c2:	e8 0f       	add	r30, r24
      c4:	f1 1d       	adc	r31, r1
      c6:	20 83       	st	Z, r18
		r++;
      c8:	9f 5f       	subi	r25, 0xFF	; 255
      ca:	90 93 64 00 	sts	0x0064, r25
		rs++;
      ce:	8f 5f       	subi	r24, 0xFF	; 255
      d0:	80 93 63 00 	sts	0x0063, r24
      d4:	1f c0       	rjmp	.+62     	; 0x114 <do_task+0x82>
		
	}
	else if(task==2)//green
      d6:	82 30       	cpi	r24, 0x02	; 2
      d8:	e9 f4       	brne	.+58     	; 0x114 <do_task+0x82>
	{
		green_nodes[gn]=path1.path[t];
      da:	90 91 62 00 	lds	r25, 0x0062
      de:	80 91 73 00 	lds	r24, 0x0073
      e2:	e8 ec       	ldi	r30, 0xC8	; 200
      e4:	f0 e0       	ldi	r31, 0x00	; 0
      e6:	e8 0f       	add	r30, r24
      e8:	f1 1d       	adc	r31, r1
      ea:	80 81       	ld	r24, Z
      ec:	e2 e8       	ldi	r30, 0x82	; 130
      ee:	f0 e0       	ldi	r31, 0x00	; 0
      f0:	e9 0f       	add	r30, r25
      f2:	f1 1d       	adc	r31, r1
      f4:	80 83       	st	Z, r24
		green_side[gs]=side;
      f6:	80 91 61 00 	lds	r24, 0x0061
      fa:	20 91 71 00 	lds	r18, 0x0071
      fe:	e0 ea       	ldi	r30, 0xA0	; 160
     100:	f0 e0       	ldi	r31, 0x00	; 0
     102:	e8 0f       	add	r30, r24
     104:	f1 1d       	adc	r31, r1
     106:	20 83       	st	Z, r18
		gn++;
     108:	9f 5f       	subi	r25, 0xFF	; 255
     10a:	90 93 62 00 	sts	0x0062, r25
		gs++;
     10e:	8f 5f       	subi	r24, 0xFF	; 255
     110:	80 93 61 00 	sts	0x0061, r24
		
	}
	if(task==3)
     114:	80 91 72 00 	lds	r24, 0x0072
     118:	83 30       	cpi	r24, 0x03	; 3
     11a:	01 f5       	brne	.+64     	; 0x15c <do_task+0xca>
     11c:	87 e9       	ldi	r24, 0x97	; 151
     11e:	90 e0       	ldi	r25, 0x00	; 0
	{
		for(int i=0;i<=150;i++)   //back
		{
			PORTB=PORTB|0x20;//0010 0000 pb5
     120:	c5 9a       	sbi	0x18, 5	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     122:	e9 e9       	ldi	r30, 0x99	; 153
     124:	f3 e0       	ldi	r31, 0x03	; 3
     126:	31 97       	sbiw	r30, 0x01	; 1
     128:	f1 f7       	brne	.-4      	; 0x126 <do_task+0x94>
     12a:	00 c0       	rjmp	.+0      	; 0x12c <do_task+0x9a>
			_delay_ms(0.5);
			PORTB=PORTB & 0xDF;//1101 1111
     12c:	c5 98       	cbi	0x18, 5	; 24
     12e:	e6 e6       	ldi	r30, 0x66	; 102
     130:	fc e8       	ldi	r31, 0x8C	; 140
     132:	31 97       	sbiw	r30, 0x01	; 1
     134:	f1 f7       	brne	.-4      	; 0x132 <do_task+0xa0>
     136:	00 00       	nop
     138:	01 97       	sbiw	r24, 0x01	; 1
		gs++;
		
	}
	if(task==3)
	{
		for(int i=0;i<=150;i++)   //back
     13a:	91 f7       	brne	.-28     	; 0x120 <do_task+0x8e>
     13c:	87 e9       	ldi	r24, 0x97	; 151
     13e:	90 e0       	ldi	r25, 0x00	; 0
		}


		for(int i=0;i<=150;i++)  //front
		{
			PORTB=PORTB|0x20;//0010 0000 pb5
     140:	c5 9a       	sbi	0x18, 5	; 24
     142:	ee e1       	ldi	r30, 0x1E	; 30
     144:	f6 e0       	ldi	r31, 0x06	; 6
     146:	31 97       	sbiw	r30, 0x01	; 1
     148:	f1 f7       	brne	.-4      	; 0x146 <do_task+0xb4>
     14a:	00 c0       	rjmp	.+0      	; 0x14c <do_task+0xba>
			_delay_ms(0.85);
			PORTB=PORTB & 0xDF;//1101 1111
     14c:	c5 98       	cbi	0x18, 5	; 24
     14e:	e1 ee       	ldi	r30, 0xE1	; 225
     150:	f9 e8       	ldi	r31, 0x89	; 137
     152:	31 97       	sbiw	r30, 0x01	; 1
     154:	f1 f7       	brne	.-4      	; 0x152 <do_task+0xc0>
     156:	00 00       	nop
     158:	01 97       	sbiw	r24, 0x01	; 1
			_delay_ms(19.5);
			
		}


		for(int i=0;i<=150;i++)  //front
     15a:	91 f7       	brne	.-28     	; 0x140 <do_task+0xae>
	}
	if(red_side[0]==1 && red_side[1]==1)
	{
		buzzer_beep();
	}*/
	task=0;
     15c:	10 92 72 00 	sts	0x0072, r1
	side=0;
     160:	10 92 71 00 	sts	0x0071, r1
	PORTC=PORTC& 0x8F;//1000 1111
     164:	85 b3       	in	r24, 0x15	; 21
     166:	8f 78       	andi	r24, 0x8F	; 143
     168:	85 bb       	out	0x15, r24	; 21
	//buzzer_beep();
}
     16a:	08 95       	ret

0000016c <buzzer_pin_config>:
#include <util/delay.h>

//Function to initialize Buzzer 
void buzzer_pin_config (void)
{
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     16c:	a3 9a       	sbi	0x14, 3	; 20
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     16e:	ab 98       	cbi	0x15, 3	; 21
}
     170:	08 95       	ret

00000172 <port_init_buzzer>:

void port_init_buzzer (void)
{
 buzzer_pin_config();
     172:	0e 94 b6 00 	call	0x16c	; 0x16c <buzzer_pin_config>
}
     176:	08 95       	ret

00000178 <buzzer_on>:

void buzzer_on (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     178:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore | 0x08;
     17a:	88 60       	ori	r24, 0x08	; 8
 PORTC = port_restore;
     17c:	85 bb       	out	0x15, r24	; 21
}
     17e:	08 95       	ret

00000180 <buzzer_off>:

void buzzer_off (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     180:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore & 0xF7;
     182:	87 7f       	andi	r24, 0xF7	; 247
 PORTC = port_restore;
     184:	85 bb       	out	0x15, r24	; 21
}
     186:	08 95       	ret

00000188 <buzzer_beep>:
void buzzer_beep()
{
	buzzer_on();
     188:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
     18c:	8f ef       	ldi	r24, 0xFF	; 255
     18e:	9f e7       	ldi	r25, 0x7F	; 127
     190:	a4 e0       	ldi	r26, 0x04	; 4
     192:	81 50       	subi	r24, 0x01	; 1
     194:	90 40       	sbci	r25, 0x00	; 0
     196:	a0 40       	sbci	r26, 0x00	; 0
     198:	e1 f7       	brne	.-8      	; 0x192 <buzzer_beep+0xa>
     19a:	00 c0       	rjmp	.+0      	; 0x19c <buzzer_beep+0x14>
     19c:	00 00       	nop
	_delay_ms(200);
	buzzer_off();
     19e:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
     1a2:	8f ef       	ldi	r24, 0xFF	; 255
     1a4:	9f e7       	ldi	r25, 0x7F	; 127
     1a6:	a4 e0       	ldi	r26, 0x04	; 4
     1a8:	81 50       	subi	r24, 0x01	; 1
     1aa:	90 40       	sbci	r25, 0x00	; 0
     1ac:	a0 40       	sbci	r26, 0x00	; 0
     1ae:	e1 f7       	brne	.-8      	; 0x1a8 <buzzer_beep+0x20>
     1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <buzzer_beep+0x2a>
     1b2:	00 00       	nop
	_delay_ms(200);
}
     1b4:	08 95       	ret

000001b6 <init_devices_buzzer>:
void init_devices_buzzer (void)
{
 cli(); 			//Clears the global interrupts
     1b6:	f8 94       	cli
 port_init_buzzer();
     1b8:	0e 94 b9 00 	call	0x172	; 0x172 <port_init_buzzer>
 sei(); 			//Enables the global interrupts
     1bc:	78 94       	sei
}
     1be:	08 95       	ret

000001c0 <main_function7>:




struct Path_Array main_function7(unsigned char start, unsigned char finish)
{
     1c0:	cf 92       	push	r12
     1c2:	df 92       	push	r13
     1c4:	ef 92       	push	r14
     1c6:	ff 92       	push	r15
     1c8:	0f 93       	push	r16
     1ca:	1f 93       	push	r17
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	cd b7       	in	r28, 0x3d	; 61
     1d2:	de b7       	in	r29, 0x3e	; 62
     1d4:	2f 97       	sbiw	r28, 0x0f	; 15
     1d6:	0f b6       	in	r0, 0x3f	; 63
     1d8:	f8 94       	cli
     1da:	de bf       	out	0x3e, r29	; 62
     1dc:	0f be       	out	0x3f, r0	; 63
     1de:	cd bf       	out	0x3d, r28	; 61
     1e0:	08 2f       	mov	r16, r24
     1e2:	f9 2e       	mov	r15, r25
     1e4:	26 2f       	mov	r18, r22
	struct Path_Array path;
unsigned char friend; 
signed char k =(((start-1)/7)-((finish-1)/7));
     1e6:	c4 2e       	mov	r12, r20
     1e8:	dd 24       	eor	r13, r13
     1ea:	86 2f       	mov	r24, r22
     1ec:	90 e0       	ldi	r25, 0x00	; 0
     1ee:	01 97       	sbiw	r24, 0x01	; 1
     1f0:	e7 e0       	ldi	r30, 0x07	; 7
     1f2:	f0 e0       	ldi	r31, 0x00	; 0
     1f4:	bf 01       	movw	r22, r30
     1f6:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__divmodhi4>
     1fa:	36 2f       	mov	r19, r22
     1fc:	c6 01       	movw	r24, r12
     1fe:	01 97       	sbiw	r24, 0x01	; 1
     200:	bf 01       	movw	r22, r30
     202:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__divmodhi4>
     206:	36 1b       	sub	r19, r22
     208:	53 2f       	mov	r21, r19
if(k>0)
     20a:	13 16       	cp	r1, r19
     20c:	3c f4       	brge	.+14     	; 0x21c <main_function7+0x5c>
{
	friend=((k*7)+finish);
     20e:	13 2f       	mov	r17, r19
     210:	11 0f       	add	r17, r17
     212:	11 0f       	add	r17, r17
     214:	11 0f       	add	r17, r17
     216:	13 1b       	sub	r17, r19
     218:	14 0f       	add	r17, r20
     21a:	06 c0       	rjmp	.+12     	; 0x228 <main_function7+0x68>
}
else
{
	friend=(finish-(k*(-1))*7);
     21c:	13 2f       	mov	r17, r19
     21e:	11 0f       	add	r17, r17
     220:	11 0f       	add	r17, r17
     222:	11 0f       	add	r17, r17
     224:	13 1b       	sub	r17, r19
     226:	14 0f       	add	r17, r20
}
signed char l=0;
unsigned char m=0;
 unsigned char st =start;
l=(friend - start);
     228:	31 2f       	mov	r19, r17
     22a:	32 1b       	sub	r19, r18
     22c:	e3 2e       	mov	r14, r19

if(l>0)
     22e:	13 16       	cp	r1, r19
     230:	0c f0       	brlt	.+2      	; 0x234 <main_function7+0x74>
     232:	ad c0       	rjmp	.+346    	; 0x38e <main_function7+0x1ce>
{
	for(unsigned char i = 0;i<=l;i++)
     234:	e3 2f       	mov	r30, r19
     236:	ff 27       	eor	r31, r31
     238:	e7 fd       	sbrc	r30, 7
     23a:	f0 95       	com	r31
     23c:	ff 23       	and	r31, r31
     23e:	9c f0       	brlt	.+38     	; 0x266 <main_function7+0xa6>
     240:	80 e0       	ldi	r24, 0x00	; 0
     242:	90 e0       	ldi	r25, 0x00	; 0
     244:	60 e0       	ldi	r22, 0x00	; 0
	{path.path[i]=st;
     246:	a1 e0       	ldi	r26, 0x01	; 1
     248:	b0 e0       	ldi	r27, 0x00	; 0
     24a:	ac 0f       	add	r26, r28
     24c:	bd 1f       	adc	r27, r29
     24e:	8a 0f       	add	r24, r26
     250:	9b 1f       	adc	r25, r27
     252:	76 2f       	mov	r23, r22
     254:	72 0f       	add	r23, r18
     256:	dc 01       	movw	r26, r24
     258:	7c 93       	st	X, r23
 unsigned char st =start;
l=(friend - start);

if(l>0)
{
	for(unsigned char i = 0;i<=l;i++)
     25a:	6f 5f       	subi	r22, 0xFF	; 255
     25c:	86 2f       	mov	r24, r22
     25e:	90 e0       	ldi	r25, 0x00	; 0
     260:	e8 17       	cp	r30, r24
     262:	f9 07       	cpc	r31, r25
     264:	84 f7       	brge	.-32     	; 0x246 <main_function7+0x86>
	{path.path[i]=st;
	st++;
	}
	if(k>0)	
     266:	15 16       	cp	r1, r21
     268:	0c f0       	brlt	.+2      	; 0x26c <main_function7+0xac>
     26a:	47 c0       	rjmp	.+142    	; 0x2fa <main_function7+0x13a>
	{   
		if(friend > finish)
     26c:	41 17       	cp	r20, r17
     26e:	18 f5       	brcc	.+70     	; 0x2b6 <main_function7+0xf6>
		{
			m=((friend-finish)/7);
     270:	81 2f       	mov	r24, r17
     272:	90 e0       	ldi	r25, 0x00	; 0
     274:	8c 19       	sub	r24, r12
     276:	9d 09       	sbc	r25, r13
     278:	67 e0       	ldi	r22, 0x07	; 7
     27a:	70 e0       	ldi	r23, 0x00	; 0
     27c:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     280:	66 23       	and	r22, r22
     282:	09 f4       	brne	.+2      	; 0x286 <main_function7+0xc6>
     284:	34 c1       	rjmp	.+616    	; 0x4ee <__stack+0x8f>
     286:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     288:	ec 0f       	add	r30, r28
     28a:	fd 1f       	adc	r31, r29
     28c:	32 96       	adiw	r30, 0x02	; 2
     28e:	83 2f       	mov	r24, r19
     290:	99 27       	eor	r25, r25
     292:	87 fd       	sbrc	r24, 7
     294:	90 95       	com	r25
     296:	23 e0       	ldi	r18, 0x03	; 3
     298:	30 e0       	ldi	r19, 0x00	; 0
     29a:	2c 0f       	add	r18, r28
     29c:	3d 1f       	adc	r19, r29
     29e:	82 0f       	add	r24, r18
     2a0:	93 1f       	adc	r25, r19
     2a2:	26 2f       	mov	r18, r22
     2a4:	21 50       	subi	r18, 0x01	; 1
     2a6:	82 0f       	add	r24, r18
     2a8:	91 1d       	adc	r25, r1
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     2aa:	11 93       	st	Z+, r17
     2ac:	17 50       	subi	r17, 0x07	; 7
	if(k>0)	
	{   
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     2ae:	e8 17       	cp	r30, r24
     2b0:	f9 07       	cpc	r31, r25
     2b2:	d9 f7       	brne	.-10     	; 0x2aa <main_function7+0xea>
     2b4:	1c c1       	rjmp	.+568    	; 0x4ee <__stack+0x8f>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     2b6:	c6 01       	movw	r24, r12
     2b8:	81 1b       	sub	r24, r17
     2ba:	91 09       	sbc	r25, r1
     2bc:	67 e0       	ldi	r22, 0x07	; 7
     2be:	70 e0       	ldi	r23, 0x00	; 0
     2c0:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     2c4:	66 23       	and	r22, r22
     2c6:	09 f4       	brne	.+2      	; 0x2ca <main_function7+0x10a>
     2c8:	12 c1       	rjmp	.+548    	; 0x4ee <__stack+0x8f>
     2ca:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     2cc:	ec 0f       	add	r30, r28
     2ce:	fd 1f       	adc	r31, r29
     2d0:	32 96       	adiw	r30, 0x02	; 2
     2d2:	83 2f       	mov	r24, r19
     2d4:	99 27       	eor	r25, r25
     2d6:	87 fd       	sbrc	r24, 7
     2d8:	90 95       	com	r25
     2da:	a3 e0       	ldi	r26, 0x03	; 3
     2dc:	b0 e0       	ldi	r27, 0x00	; 0
     2de:	ac 0f       	add	r26, r28
     2e0:	bd 1f       	adc	r27, r29
     2e2:	8a 0f       	add	r24, r26
     2e4:	9b 1f       	adc	r25, r27
     2e6:	26 2f       	mov	r18, r22
     2e8:	21 50       	subi	r18, 0x01	; 1
     2ea:	82 0f       	add	r24, r18
     2ec:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     2ee:	11 93       	st	Z+, r17
     2f0:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     2f2:	e8 17       	cp	r30, r24
     2f4:	f9 07       	cpc	r31, r25
     2f6:	d9 f7       	brne	.-10     	; 0x2ee <main_function7+0x12e>
     2f8:	fa c0       	rjmp	.+500    	; 0x4ee <__stack+0x8f>
				path.path[l+i+1]=friend+((7*i)+7);
			}
		}
		
	}
	else if(k<0)
     2fa:	55 23       	and	r21, r21
     2fc:	0c f0       	brlt	.+2      	; 0x300 <main_function7+0x140>
     2fe:	f4 c0       	rjmp	.+488    	; 0x4e8 <__stack+0x89>
	{ if(friend > finish)
     300:	41 17       	cp	r20, r17
     302:	18 f5       	brcc	.+70     	; 0x34a <main_function7+0x18a>
		{	
			m=((friend-finish)/7);
     304:	81 2f       	mov	r24, r17
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	8c 19       	sub	r24, r12
     30a:	9d 09       	sbc	r25, r13
     30c:	67 e0       	ldi	r22, 0x07	; 7
     30e:	70 e0       	ldi	r23, 0x00	; 0
     310:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     314:	66 23       	and	r22, r22
     316:	09 f4       	brne	.+2      	; 0x31a <main_function7+0x15a>
     318:	ea c0       	rjmp	.+468    	; 0x4ee <__stack+0x8f>
     31a:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     31c:	ec 0f       	add	r30, r28
     31e:	fd 1f       	adc	r31, r29
     320:	32 96       	adiw	r30, 0x02	; 2
     322:	83 2f       	mov	r24, r19
     324:	99 27       	eor	r25, r25
     326:	87 fd       	sbrc	r24, 7
     328:	90 95       	com	r25
     32a:	23 e0       	ldi	r18, 0x03	; 3
     32c:	30 e0       	ldi	r19, 0x00	; 0
     32e:	2c 0f       	add	r18, r28
     330:	3d 1f       	adc	r19, r29
     332:	82 0f       	add	r24, r18
     334:	93 1f       	adc	r25, r19
     336:	26 2f       	mov	r18, r22
     338:	21 50       	subi	r18, 0x01	; 1
     33a:	82 0f       	add	r24, r18
     33c:	91 1d       	adc	r25, r1
	{ if(friend > finish)
		{	
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     33e:	11 93       	st	Z+, r17
     340:	17 50       	subi	r17, 0x07	; 7
	}
	else if(k<0)
	{ if(friend > finish)
		{	
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     342:	e8 17       	cp	r30, r24
     344:	f9 07       	cpc	r31, r25
     346:	d9 f7       	brne	.-10     	; 0x33e <main_function7+0x17e>
     348:	d2 c0       	rjmp	.+420    	; 0x4ee <__stack+0x8f>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     34a:	c6 01       	movw	r24, r12
     34c:	81 1b       	sub	r24, r17
     34e:	91 09       	sbc	r25, r1
     350:	67 e0       	ldi	r22, 0x07	; 7
     352:	70 e0       	ldi	r23, 0x00	; 0
     354:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     358:	66 23       	and	r22, r22
     35a:	09 f4       	brne	.+2      	; 0x35e <main_function7+0x19e>
     35c:	c8 c0       	rjmp	.+400    	; 0x4ee <__stack+0x8f>
     35e:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     360:	ec 0f       	add	r30, r28
     362:	fd 1f       	adc	r31, r29
     364:	32 96       	adiw	r30, 0x02	; 2
     366:	83 2f       	mov	r24, r19
     368:	99 27       	eor	r25, r25
     36a:	87 fd       	sbrc	r24, 7
     36c:	90 95       	com	r25
     36e:	a3 e0       	ldi	r26, 0x03	; 3
     370:	b0 e0       	ldi	r27, 0x00	; 0
     372:	ac 0f       	add	r26, r28
     374:	bd 1f       	adc	r27, r29
     376:	8a 0f       	add	r24, r26
     378:	9b 1f       	adc	r25, r27
     37a:	26 2f       	mov	r18, r22
     37c:	21 50       	subi	r18, 0x01	; 1
     37e:	82 0f       	add	r24, r18
     380:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     382:	11 93       	st	Z+, r17
     384:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     386:	e8 17       	cp	r30, r24
     388:	f9 07       	cpc	r31, r25
     38a:	d9 f7       	brne	.-10     	; 0x382 <main_function7+0x1c2>
     38c:	b0 c0       	rjmp	.+352    	; 0x4ee <__stack+0x8f>
		
	}
	
}
else
{ l=(l*(-1));
     38e:	e3 2e       	mov	r14, r19
     390:	e1 94       	neg	r14
	for(unsigned char i = 0;i<=(l);i++)
     392:	ee 2d       	mov	r30, r14
     394:	ff 27       	eor	r31, r31
     396:	e7 fd       	sbrc	r30, 7
     398:	f0 95       	com	r31
     39a:	ff 23       	and	r31, r31
     39c:	9c f0       	brlt	.+38     	; 0x3c4 <main_function7+0x204>
     39e:	80 e0       	ldi	r24, 0x00	; 0
     3a0:	90 e0       	ldi	r25, 0x00	; 0
     3a2:	30 e0       	ldi	r19, 0x00	; 0
	{path.path[i]=st;
     3a4:	61 e0       	ldi	r22, 0x01	; 1
     3a6:	70 e0       	ldi	r23, 0x00	; 0
     3a8:	6c 0f       	add	r22, r28
     3aa:	7d 1f       	adc	r23, r29
     3ac:	86 0f       	add	r24, r22
     3ae:	97 1f       	adc	r25, r23
     3b0:	62 2f       	mov	r22, r18
     3b2:	63 1b       	sub	r22, r19
     3b4:	dc 01       	movw	r26, r24
     3b6:	6c 93       	st	X, r22
	}
	
}
else
{ l=(l*(-1));
	for(unsigned char i = 0;i<=(l);i++)
     3b8:	3f 5f       	subi	r19, 0xFF	; 255
     3ba:	83 2f       	mov	r24, r19
     3bc:	90 e0       	ldi	r25, 0x00	; 0
     3be:	e8 17       	cp	r30, r24
     3c0:	f9 07       	cpc	r31, r25
     3c2:	84 f7       	brge	.-32     	; 0x3a4 <main_function7+0x1e4>
	{path.path[i]=st;
		st--;
	}
	if(k>0)
     3c4:	15 16       	cp	r1, r21
     3c6:	0c f0       	brlt	.+2      	; 0x3ca <main_function7+0x20a>
     3c8:	47 c0       	rjmp	.+142    	; 0x458 <main_function7+0x298>
	{  
		if(friend > finish)
     3ca:	41 17       	cp	r20, r17
     3cc:	18 f5       	brcc	.+70     	; 0x414 <main_function7+0x254>
		{
			m=((friend-finish)/7);
     3ce:	81 2f       	mov	r24, r17
     3d0:	90 e0       	ldi	r25, 0x00	; 0
     3d2:	8c 19       	sub	r24, r12
     3d4:	9d 09       	sbc	r25, r13
     3d6:	67 e0       	ldi	r22, 0x07	; 7
     3d8:	70 e0       	ldi	r23, 0x00	; 0
     3da:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     3de:	66 23       	and	r22, r22
     3e0:	09 f4       	brne	.+2      	; 0x3e4 <main_function7+0x224>
     3e2:	85 c0       	rjmp	.+266    	; 0x4ee <__stack+0x8f>
     3e4:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     3e6:	ec 0f       	add	r30, r28
     3e8:	fd 1f       	adc	r31, r29
     3ea:	32 96       	adiw	r30, 0x02	; 2
     3ec:	8e 2d       	mov	r24, r14
     3ee:	99 27       	eor	r25, r25
     3f0:	87 fd       	sbrc	r24, 7
     3f2:	90 95       	com	r25
     3f4:	23 e0       	ldi	r18, 0x03	; 3
     3f6:	30 e0       	ldi	r19, 0x00	; 0
     3f8:	2c 0f       	add	r18, r28
     3fa:	3d 1f       	adc	r19, r29
     3fc:	82 0f       	add	r24, r18
     3fe:	93 1f       	adc	r25, r19
     400:	26 2f       	mov	r18, r22
     402:	21 50       	subi	r18, 0x01	; 1
     404:	82 0f       	add	r24, r18
     406:	91 1d       	adc	r25, r1
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     408:	11 93       	st	Z+, r17
     40a:	17 50       	subi	r17, 0x07	; 7
	if(k>0)
	{  
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     40c:	e8 17       	cp	r30, r24
     40e:	f9 07       	cpc	r31, r25
     410:	d9 f7       	brne	.-10     	; 0x408 <main_function7+0x248>
     412:	6d c0       	rjmp	.+218    	; 0x4ee <__stack+0x8f>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     414:	c6 01       	movw	r24, r12
     416:	81 1b       	sub	r24, r17
     418:	91 09       	sbc	r25, r1
     41a:	67 e0       	ldi	r22, 0x07	; 7
     41c:	70 e0       	ldi	r23, 0x00	; 0
     41e:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     422:	66 23       	and	r22, r22
     424:	09 f4       	brne	.+2      	; 0x428 <main_function7+0x268>
     426:	63 c0       	rjmp	.+198    	; 0x4ee <__stack+0x8f>
     428:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     42a:	ec 0f       	add	r30, r28
     42c:	fd 1f       	adc	r31, r29
     42e:	32 96       	adiw	r30, 0x02	; 2
     430:	8e 2d       	mov	r24, r14
     432:	99 27       	eor	r25, r25
     434:	87 fd       	sbrc	r24, 7
     436:	90 95       	com	r25
     438:	a3 e0       	ldi	r26, 0x03	; 3
     43a:	b0 e0       	ldi	r27, 0x00	; 0
     43c:	ac 0f       	add	r26, r28
     43e:	bd 1f       	adc	r27, r29
     440:	8a 0f       	add	r24, r26
     442:	9b 1f       	adc	r25, r27
     444:	26 2f       	mov	r18, r22
     446:	21 50       	subi	r18, 0x01	; 1
     448:	82 0f       	add	r24, r18
     44a:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     44c:	11 93       	st	Z+, r17
     44e:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     450:	e8 17       	cp	r30, r24
     452:	f9 07       	cpc	r31, r25
     454:	d9 f7       	brne	.-10     	; 0x44c <main_function7+0x28c>
     456:	4b c0       	rjmp	.+150    	; 0x4ee <__stack+0x8f>
			{
				path.path[l+i+1]=friend+((7*i)+7);
			}
		}
	}
	else  if(k<0)
     458:	55 23       	and	r21, r21
     45a:	0c f0       	brlt	.+2      	; 0x45e <main_function7+0x29e>
     45c:	47 c0       	rjmp	.+142    	; 0x4ec <__stack+0x8d>
	{
		if(friend > finish)
     45e:	41 17       	cp	r20, r17
     460:	10 f5       	brcc	.+68     	; 0x4a6 <__stack+0x47>
		{
			m=((friend-finish)/7);
     462:	81 2f       	mov	r24, r17
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	8c 19       	sub	r24, r12
     468:	9d 09       	sbc	r25, r13
     46a:	67 e0       	ldi	r22, 0x07	; 7
     46c:	70 e0       	ldi	r23, 0x00	; 0
     46e:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     472:	66 23       	and	r22, r22
     474:	e1 f1       	breq	.+120    	; 0x4ee <__stack+0x8f>
     476:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     478:	ec 0f       	add	r30, r28
     47a:	fd 1f       	adc	r31, r29
     47c:	32 96       	adiw	r30, 0x02	; 2
     47e:	8e 2d       	mov	r24, r14
     480:	99 27       	eor	r25, r25
     482:	87 fd       	sbrc	r24, 7
     484:	90 95       	com	r25
     486:	23 e0       	ldi	r18, 0x03	; 3
     488:	30 e0       	ldi	r19, 0x00	; 0
     48a:	2c 0f       	add	r18, r28
     48c:	3d 1f       	adc	r19, r29
     48e:	82 0f       	add	r24, r18
     490:	93 1f       	adc	r25, r19
     492:	26 2f       	mov	r18, r22
     494:	21 50       	subi	r18, 0x01	; 1
     496:	82 0f       	add	r24, r18
     498:	91 1d       	adc	r25, r1
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     49a:	11 93       	st	Z+, r17
     49c:	17 50       	subi	r17, 0x07	; 7
	else  if(k<0)
	{
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     49e:	e8 17       	cp	r30, r24
     4a0:	f9 07       	cpc	r31, r25
     4a2:	d9 f7       	brne	.-10     	; 0x49a <__stack+0x3b>
     4a4:	24 c0       	rjmp	.+72     	; 0x4ee <__stack+0x8f>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     4a6:	c6 01       	movw	r24, r12
     4a8:	81 1b       	sub	r24, r17
     4aa:	91 09       	sbc	r25, r1
     4ac:	67 e0       	ldi	r22, 0x07	; 7
     4ae:	70 e0       	ldi	r23, 0x00	; 0
     4b0:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     4b4:	66 23       	and	r22, r22
     4b6:	d9 f0       	breq	.+54     	; 0x4ee <__stack+0x8f>
     4b8:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     4ba:	ec 0f       	add	r30, r28
     4bc:	fd 1f       	adc	r31, r29
     4be:	32 96       	adiw	r30, 0x02	; 2
     4c0:	8e 2d       	mov	r24, r14
     4c2:	99 27       	eor	r25, r25
     4c4:	87 fd       	sbrc	r24, 7
     4c6:	90 95       	com	r25
     4c8:	a3 e0       	ldi	r26, 0x03	; 3
     4ca:	b0 e0       	ldi	r27, 0x00	; 0
     4cc:	ac 0f       	add	r26, r28
     4ce:	bd 1f       	adc	r27, r29
     4d0:	8a 0f       	add	r24, r26
     4d2:	9b 1f       	adc	r25, r27
     4d4:	26 2f       	mov	r18, r22
     4d6:	21 50       	subi	r18, 0x01	; 1
     4d8:	82 0f       	add	r24, r18
     4da:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     4dc:	11 93       	st	Z+, r17
     4de:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     4e0:	e8 17       	cp	r30, r24
     4e2:	f9 07       	cpc	r31, r25
     4e4:	d9 f7       	brne	.-10     	; 0x4dc <__stack+0x7d>
     4e6:	03 c0       	rjmp	.+6      	; 0x4ee <__stack+0x8f>
else
{
	friend=(finish-(k*(-1))*7);
}
signed char l=0;
unsigned char m=0;
     4e8:	60 e0       	ldi	r22, 0x00	; 0
     4ea:	01 c0       	rjmp	.+2      	; 0x4ee <__stack+0x8f>
     4ec:	60 e0       	ldi	r22, 0x00	; 0
		}
		
	}
	
}
 max = l+m;
     4ee:	6e 0d       	add	r22, r14
     4f0:	60 93 80 00 	sts	0x0080, r22
 for(unsigned char i=(l+m+1);i<15;i++)
     4f4:	6f 5f       	subi	r22, 0xFF	; 255
     4f6:	6f 30       	cpi	r22, 0x0F	; 15
     4f8:	50 f4       	brcc	.+20     	; 0x50e <__stack+0xaf>
 {
	 path.path[i]=0;
     4fa:	e1 e0       	ldi	r30, 0x01	; 1
     4fc:	f0 e0       	ldi	r31, 0x00	; 0
     4fe:	ec 0f       	add	r30, r28
     500:	fd 1f       	adc	r31, r29
     502:	e6 0f       	add	r30, r22
     504:	f1 1d       	adc	r31, r1
     506:	10 82       	st	Z, r1
		
	}
	
}
 max = l+m;
 for(unsigned char i=(l+m+1);i<15;i++)
     508:	6f 5f       	subi	r22, 0xFF	; 255
     50a:	6f 30       	cpi	r22, 0x0F	; 15
     50c:	b1 f7       	brne	.-20     	; 0x4fa <__stack+0x9b>
 {
	 path.path[i]=0;
 }

	
	return path;
     50e:	e0 2f       	mov	r30, r16
     510:	ff 2d       	mov	r31, r15
     512:	de 01       	movw	r26, r28
     514:	11 96       	adiw	r26, 0x01	; 1
     516:	8f e0       	ldi	r24, 0x0F	; 15
     518:	0d 90       	ld	r0, X+
     51a:	01 92       	st	Z+, r0
     51c:	81 50       	subi	r24, 0x01	; 1
     51e:	e1 f7       	brne	.-8      	; 0x518 <__stack+0xb9>
}
     520:	80 2f       	mov	r24, r16
     522:	9f 2d       	mov	r25, r15
     524:	2f 96       	adiw	r28, 0x0f	; 15
     526:	0f b6       	in	r0, 0x3f	; 63
     528:	f8 94       	cli
     52a:	de bf       	out	0x3e, r29	; 62
     52c:	0f be       	out	0x3f, r0	; 63
     52e:	cd bf       	out	0x3d, r28	; 61
     530:	df 91       	pop	r29
     532:	cf 91       	pop	r28
     534:	1f 91       	pop	r17
     536:	0f 91       	pop	r16
     538:	ff 90       	pop	r15
     53a:	ef 90       	pop	r14
     53c:	df 90       	pop	r13
     53e:	cf 90       	pop	r12
     540:	08 95       	ret

00000542 <motion_pin_config_pos>:
volatile unsigned int Degrees; //to accept angle in degrees for turning

//Function to configure ports to enable robot's motion
void motion_pin_config_pos (void) 
{
 DDRB = DDRB | 0x0F;   //set direction of the PORTB3 to PORTB0 pins as output
     542:	87 b3       	in	r24, 0x17	; 23
     544:	8f 60       	ori	r24, 0x0F	; 15
     546:	87 bb       	out	0x17, r24	; 23
 PORTB = PORTB & 0xF0; // set initial value of the PORTB3 to PORTB0 pins to logic 0
     548:	88 b3       	in	r24, 0x18	; 24
     54a:	80 7f       	andi	r24, 0xF0	; 240
     54c:	88 bb       	out	0x18, r24	; 24
 DDRD = DDRD | 0x30;   //Setting PD4 and PD5 pins as output for PWM generation
     54e:	81 b3       	in	r24, 0x11	; 17
     550:	80 63       	ori	r24, 0x30	; 48
     552:	81 bb       	out	0x11, r24	; 17
 PORTD = PORTD | 0x30; //PD4 and PD5 pins are for velocity control using PWM
     554:	82 b3       	in	r24, 0x12	; 18
     556:	80 63       	ori	r24, 0x30	; 48
     558:	82 bb       	out	0x12, r24	; 18
}
     55a:	08 95       	ret

0000055c <left_encoder_pin_config>:

//Function to configure INT1 (PORTD 3) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xF7;  //Set the direction of the PORTD 3 pin as input
     55c:	8b 98       	cbi	0x11, 3	; 17
 PORTD = PORTD | 0x08; //Enable internal pull-up for PORTD 3 pin
     55e:	93 9a       	sbi	0x12, 3	; 18
}
     560:	08 95       	ret

00000562 <right_encoder_pin_config>:

//Function to configure INT0 (PORTD 2) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xFB;  //Set the direction of the PORTD 2 pin as input
     562:	8a 98       	cbi	0x11, 2	; 17
 PORTD = PORTD | 0x04; //Enable internal pull-up for PORTD 2 pin
     564:	92 9a       	sbi	0x12, 2	; 18
}
     566:	08 95       	ret

00000568 <port_init_pos>:

//Function to initialize ports
void port_init_pos()
{
 motion_pin_config_pos();          //robot motion pins config
     568:	0e 94 a1 02 	call	0x542	; 0x542 <motion_pin_config_pos>
 left_encoder_pin_config();    //left encoder pin config
     56c:	0e 94 ae 02 	call	0x55c	; 0x55c <left_encoder_pin_config>
 right_encoder_pin_config();   //right encoder pin config	
     570:	0e 94 b1 02 	call	0x562	; 0x562 <right_encoder_pin_config>
}
     574:	08 95       	ret

00000576 <left_position_encoder_interrupt_init>:

void left_position_encoder_interrupt_init (void) //Interrupt 1 enable
{
 cli(); //Clears the global interrupt
     576:	f8 94       	cli
 MCUCR = MCUCR | 0x08; // INT1 is set to trigger with falling edge
     578:	85 b7       	in	r24, 0x35	; 53
     57a:	88 60       	ori	r24, 0x08	; 8
     57c:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x80;   // Enable Interrupt INT1 for left position encoder
     57e:	8b b7       	in	r24, 0x3b	; 59
     580:	80 68       	ori	r24, 0x80	; 128
     582:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     584:	78 94       	sei
}
     586:	08 95       	ret

00000588 <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 0 enable
{
 cli(); //Clears the global interrupt
     588:	f8 94       	cli
 MCUCR = MCUCR | 0x02; // INT0 is set to trigger with falling edge
     58a:	85 b7       	in	r24, 0x35	; 53
     58c:	82 60       	ori	r24, 0x02	; 2
     58e:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x40;   // Enable Interrupt INT5 for right position encoder
     590:	8b b7       	in	r24, 0x3b	; 59
     592:	80 64       	ori	r24, 0x40	; 64
     594:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     596:	78 94       	sei
}
     598:	08 95       	ret

0000059a <__vector_1>:

//ISR for right position encoder
ISR(INT0_vect)  
{
     59a:	1f 92       	push	r1
     59c:	0f 92       	push	r0
     59e:	0f b6       	in	r0, 0x3f	; 63
     5a0:	0f 92       	push	r0
     5a2:	11 24       	eor	r1, r1
     5a4:	8f 93       	push	r24
     5a6:	9f 93       	push	r25
     5a8:	af 93       	push	r26
     5aa:	bf 93       	push	r27
 ShaftCountRight++;  //increment right shaft position count
     5ac:	80 91 78 00 	lds	r24, 0x0078
     5b0:	90 91 79 00 	lds	r25, 0x0079
     5b4:	a0 91 7a 00 	lds	r26, 0x007A
     5b8:	b0 91 7b 00 	lds	r27, 0x007B
     5bc:	01 96       	adiw	r24, 0x01	; 1
     5be:	a1 1d       	adc	r26, r1
     5c0:	b1 1d       	adc	r27, r1
     5c2:	80 93 78 00 	sts	0x0078, r24
     5c6:	90 93 79 00 	sts	0x0079, r25
     5ca:	a0 93 7a 00 	sts	0x007A, r26
     5ce:	b0 93 7b 00 	sts	0x007B, r27
}
     5d2:	bf 91       	pop	r27
     5d4:	af 91       	pop	r26
     5d6:	9f 91       	pop	r25
     5d8:	8f 91       	pop	r24
     5da:	0f 90       	pop	r0
     5dc:	0f be       	out	0x3f, r0	; 63
     5de:	0f 90       	pop	r0
     5e0:	1f 90       	pop	r1
     5e2:	18 95       	reti

000005e4 <__vector_2>:

//ISR for left position encoder
ISR(INT1_vect)
{
     5e4:	1f 92       	push	r1
     5e6:	0f 92       	push	r0
     5e8:	0f b6       	in	r0, 0x3f	; 63
     5ea:	0f 92       	push	r0
     5ec:	11 24       	eor	r1, r1
     5ee:	8f 93       	push	r24
     5f0:	9f 93       	push	r25
     5f2:	af 93       	push	r26
     5f4:	bf 93       	push	r27
 ShaftCountLeft++;  //increment left shaft position count
     5f6:	80 91 7c 00 	lds	r24, 0x007C
     5fa:	90 91 7d 00 	lds	r25, 0x007D
     5fe:	a0 91 7e 00 	lds	r26, 0x007E
     602:	b0 91 7f 00 	lds	r27, 0x007F
     606:	01 96       	adiw	r24, 0x01	; 1
     608:	a1 1d       	adc	r26, r1
     60a:	b1 1d       	adc	r27, r1
     60c:	80 93 7c 00 	sts	0x007C, r24
     610:	90 93 7d 00 	sts	0x007D, r25
     614:	a0 93 7e 00 	sts	0x007E, r26
     618:	b0 93 7f 00 	sts	0x007F, r27
}
     61c:	bf 91       	pop	r27
     61e:	af 91       	pop	r26
     620:	9f 91       	pop	r25
     622:	8f 91       	pop	r24
     624:	0f 90       	pop	r0
     626:	0f be       	out	0x3f, r0	; 63
     628:	0f 90       	pop	r0
     62a:	1f 90       	pop	r1
     62c:	18 95       	reti

0000062e <motion_set_pos>:
void motion_set_pos (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortBRestore = PORTB; 		// reading the PORT original status
     62e:	98 b3       	in	r25, 0x18	; 24
 PortBRestore &= 0xF0; 		// making lower direction nibbel to 0
     630:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set_pos (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
     632:	8f 70       	andi	r24, 0x0F	; 15
 PortBRestore = PORTB; 		// reading the PORT original status
 PortBRestore &= 0xF0; 		// making lower direction nibbel to 0
 PortBRestore |= Direction; // adding lower nibbel for forward command and restoring the PORTB status
     634:	98 2b       	or	r25, r24
 PORTB = PortBRestore; 		// executing the command
     636:	98 bb       	out	0x18, r25	; 24
}
     638:	08 95       	ret

0000063a <forward_pos>:

void forward_pos (void) //both wheels forward
{
  motion_set_pos(0x06);
     63a:	86 e0       	ldi	r24, 0x06	; 6
     63c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     640:	08 95       	ret

00000642 <back_pos>:

void back_pos (void) //both wheels backward
{
  motion_set_pos(0x09);
     642:	89 e0       	ldi	r24, 0x09	; 9
     644:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     648:	08 95       	ret

0000064a <left_pos>:

void left_pos (void) //Left wheel backward, Right wheel forward
{
  motion_set_pos(0x05);
     64a:	85 e0       	ldi	r24, 0x05	; 5
     64c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     650:	08 95       	ret

00000652 <right_pos>:

void right_pos (void) //Left wheel forward, Right wheel backward
{
  motion_set_pos(0x0A);
     652:	8a e0       	ldi	r24, 0x0A	; 10
     654:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     658:	08 95       	ret

0000065a <soft_left_pos>:

void soft_left_pos (void) //Left wheel stationary, Right wheel forward
{
 motion_set_pos(0x04);
     65a:	84 e0       	ldi	r24, 0x04	; 4
     65c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     660:	08 95       	ret

00000662 <soft_right_pos>:

void soft_right_pos (void) //Left wheel forward, Right wheel is stationary
{
 motion_set_pos(0x02);
     662:	82 e0       	ldi	r24, 0x02	; 2
     664:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     668:	08 95       	ret

0000066a <soft_left_2_pos>:

void soft_left_2_pos (void) //Left wheel backward, right wheel stationary
{
 motion_set_pos(0x01);
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     670:	08 95       	ret

00000672 <soft_right_2_pos>:

void soft_right_2_pos (void) //Left wheel stationary, Right wheel backward
{
 motion_set_pos(0x08);
     672:	88 e0       	ldi	r24, 0x08	; 8
     674:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     678:	08 95       	ret

0000067a <stop_pos>:

void stop_pos (void)
{
  motion_set_pos(0x00);
     67a:	80 e0       	ldi	r24, 0x00	; 0
     67c:	0e 94 17 03 	call	0x62e	; 0x62e <motion_set_pos>
}
     680:	08 95       	ret

00000682 <angle_rotate>:


//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     682:	0f 93       	push	r16
     684:	1f 93       	push	r17
     686:	cf 93       	push	r28
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = (float) Degrees/ 12.85; // division by resolution to get shaft count 
     688:	bc 01       	movw	r22, r24
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	90 e0       	ldi	r25, 0x00	; 0
     68e:	0e 94 18 0e 	call	0x1c30	; 0x1c30 <__floatunsisf>
     692:	2a e9       	ldi	r18, 0x9A	; 154
     694:	39 e9       	ldi	r19, 0x99	; 153
     696:	4d e4       	ldi	r20, 0x4D	; 77
     698:	51 e4       	ldi	r21, 0x41	; 65
     69a:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <__divsf3>
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     69e:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <__fixunssfsi>
     6a2:	dc 01       	movw	r26, r24
     6a4:	cb 01       	movw	r24, r22
     6a6:	a0 e0       	ldi	r26, 0x00	; 0
     6a8:	b0 e0       	ldi	r27, 0x00	; 0
 ShaftCountRight = 0; 
     6aa:	10 92 78 00 	sts	0x0078, r1
     6ae:	10 92 79 00 	sts	0x0079, r1
     6b2:	10 92 7a 00 	sts	0x007A, r1
     6b6:	10 92 7b 00 	sts	0x007B, r1
 ShaftCountLeft = 0; 
     6ba:	10 92 7c 00 	sts	0x007C, r1
     6be:	10 92 7d 00 	sts	0x007D, r1
     6c2:	10 92 7e 00 	sts	0x007E, r1
     6c6:	10 92 7f 00 	sts	0x007F, r1

 while (1)
 {
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     6ca:	f1 e0       	ldi	r31, 0x01	; 1
     6cc:	c0 e0       	ldi	r28, 0x00	; 0
     6ce:	40 91 78 00 	lds	r20, 0x0078
     6d2:	50 91 79 00 	lds	r21, 0x0079
     6d6:	60 91 7a 00 	lds	r22, 0x007A
     6da:	70 91 7b 00 	lds	r23, 0x007B
     6de:	00 91 7c 00 	lds	r16, 0x007C
     6e2:	10 91 7d 00 	lds	r17, 0x007D
     6e6:	20 91 7e 00 	lds	r18, 0x007E
     6ea:	30 91 7f 00 	lds	r19, 0x007F
     6ee:	ef 2f       	mov	r30, r31
     6f0:	48 17       	cp	r20, r24
     6f2:	59 07       	cpc	r21, r25
     6f4:	6a 07       	cpc	r22, r26
     6f6:	7b 07       	cpc	r23, r27
     6f8:	08 f4       	brcc	.+2      	; 0x6fc <angle_rotate+0x7a>
     6fa:	ec 2f       	mov	r30, r28
     6fc:	ee 23       	and	r30, r30
     6fe:	49 f4       	brne	.+18     	; 0x712 <angle_rotate+0x90>
     700:	4f 2f       	mov	r20, r31
     702:	08 17       	cp	r16, r24
     704:	19 07       	cpc	r17, r25
     706:	2a 07       	cpc	r18, r26
     708:	3b 07       	cpc	r19, r27
     70a:	08 f4       	brcc	.+2      	; 0x70e <angle_rotate+0x8c>
     70c:	4c 2f       	mov	r20, r28
     70e:	44 23       	and	r20, r20
     710:	f1 f2       	breq	.-68     	; 0x6ce <angle_rotate+0x4c>
  break;
 }
 stop_pos(); //Stop robot
     712:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
}
     716:	cf 91       	pop	r28
     718:	1f 91       	pop	r17
     71a:	0f 91       	pop	r16
     71c:	08 95       	ret

0000071e <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = DistanceInMM / 12.92; // division by resolution to get shaft count
     71e:	bc 01       	movw	r22, r24
     720:	80 e0       	ldi	r24, 0x00	; 0
     722:	90 e0       	ldi	r25, 0x00	; 0
     724:	0e 94 18 0e 	call	0x1c30	; 0x1c30 <__floatunsisf>
     728:	22 e5       	ldi	r18, 0x52	; 82
     72a:	38 eb       	ldi	r19, 0xB8	; 184
     72c:	4e e4       	ldi	r20, 0x4E	; 78
     72e:	51 e4       	ldi	r21, 0x41	; 65
     730:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <__divsf3>
 ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     734:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <__fixunssfsi>
     738:	46 2f       	mov	r20, r22
     73a:	57 2f       	mov	r21, r23
     73c:	68 2f       	mov	r22, r24
     73e:	79 2f       	mov	r23, r25
  
 ShaftCountRight = 0;
     740:	10 92 78 00 	sts	0x0078, r1
     744:	10 92 79 00 	sts	0x0079, r1
     748:	10 92 7a 00 	sts	0x007A, r1
     74c:	10 92 7b 00 	sts	0x007B, r1
 while(1)
 {
  if(ShaftCountRight > ReqdShaftCountInt)
     750:	80 91 78 00 	lds	r24, 0x0078
     754:	90 91 79 00 	lds	r25, 0x0079
     758:	a0 91 7a 00 	lds	r26, 0x007A
     75c:	b0 91 7b 00 	lds	r27, 0x007B
     760:	48 17       	cp	r20, r24
     762:	59 07       	cpc	r21, r25
     764:	6a 07       	cpc	r22, r26
     766:	7b 07       	cpc	r23, r27
     768:	98 f7       	brcc	.-26     	; 0x750 <linear_distance_mm+0x32>
  {
  	break;
  }
 } 
 stop_pos(); //Stop robot
     76a:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
}
     76e:	08 95       	ret

00000770 <forward_mm>:

void forward_mm(unsigned int DistanceInMM)
{
     770:	cf 93       	push	r28
     772:	df 93       	push	r29
     774:	ec 01       	movw	r28, r24
 forward_pos();
     776:	0e 94 1d 03 	call	0x63a	; 0x63a <forward_pos>
 linear_distance_mm(DistanceInMM);
     77a:	ce 01       	movw	r24, r28
     77c:	0e 94 8f 03 	call	0x71e	; 0x71e <linear_distance_mm>
}
     780:	df 91       	pop	r29
     782:	cf 91       	pop	r28
     784:	08 95       	ret

00000786 <back_mm>:

void back_mm(unsigned int DistanceInMM)
{
     786:	cf 93       	push	r28
     788:	df 93       	push	r29
     78a:	ec 01       	movw	r28, r24
 back_pos();
     78c:	0e 94 21 03 	call	0x642	; 0x642 <back_pos>
 linear_distance_mm(DistanceInMM);
     790:	ce 01       	movw	r24, r28
     792:	0e 94 8f 03 	call	0x71e	; 0x71e <linear_distance_mm>
}
     796:	df 91       	pop	r29
     798:	cf 91       	pop	r28
     79a:	08 95       	ret

0000079c <left_degrees>:

void left_degrees(unsigned int Degrees) 
{
     79c:	cf 93       	push	r28
     79e:	df 93       	push	r29
     7a0:	ec 01       	movw	r28, r24
// 28 pulses for 360 degrees rotation 12.92 degrees per count
 left_pos(); //Turn left
     7a2:	0e 94 25 03 	call	0x64a	; 0x64a <left_pos>
 angle_rotate(Degrees);
     7a6:	ce 01       	movw	r24, r28
     7a8:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     7ac:	df 91       	pop	r29
     7ae:	cf 91       	pop	r28
     7b0:	08 95       	ret

000007b2 <right_degrees>:



void right_degrees(unsigned int Degrees)
{
     7b2:	cf 93       	push	r28
     7b4:	df 93       	push	r29
     7b6:	ec 01       	movw	r28, r24
// 28 pulses for 360 degrees rotation 12.92 degrees per count
 right_pos(); //Turn right
     7b8:	0e 94 29 03 	call	0x652	; 0x652 <right_pos>
 angle_rotate(Degrees);
     7bc:	ce 01       	movw	r24, r28
     7be:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     7c2:	df 91       	pop	r29
     7c4:	cf 91       	pop	r28
     7c6:	08 95       	ret

000007c8 <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)
{
     7c8:	cf 93       	push	r28
     7ca:	df 93       	push	r29
     7cc:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_left_pos(); //Turn soft left
     7ce:	0e 94 2d 03 	call	0x65a	; 0x65a <soft_left_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     7d2:	ce 01       	movw	r24, r28
     7d4:	88 0f       	add	r24, r24
     7d6:	99 1f       	adc	r25, r25
     7d8:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     7dc:	df 91       	pop	r29
     7de:	cf 91       	pop	r28
     7e0:	08 95       	ret

000007e2 <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
     7e2:	cf 93       	push	r28
     7e4:	df 93       	push	r29
     7e6:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_right_pos();  //Turn soft right
     7e8:	0e 94 31 03 	call	0x662	; 0x662 <soft_right_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     7ec:	ce 01       	movw	r24, r28
     7ee:	88 0f       	add	r24, r24
     7f0:	99 1f       	adc	r25, r25
     7f2:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     7f6:	df 91       	pop	r29
     7f8:	cf 91       	pop	r28
     7fa:	08 95       	ret

000007fc <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
     7fc:	cf 93       	push	r28
     7fe:	df 93       	push	r29
     800:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_left_2_pos(); //Turn reverse soft left
     802:	0e 94 35 03 	call	0x66a	; 0x66a <soft_left_2_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     806:	ce 01       	movw	r24, r28
     808:	88 0f       	add	r24, r24
     80a:	99 1f       	adc	r25, r25
     80c:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     810:	df 91       	pop	r29
     812:	cf 91       	pop	r28
     814:	08 95       	ret

00000816 <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
     816:	cf 93       	push	r28
     818:	df 93       	push	r29
     81a:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_right_2_pos();  //Turn reverse soft right
     81c:	0e 94 39 03 	call	0x672	; 0x672 <soft_right_2_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     820:	ce 01       	movw	r24, r28
     822:	88 0f       	add	r24, r24
     824:	99 1f       	adc	r25, r25
     826:	0e 94 41 03 	call	0x682	; 0x682 <angle_rotate>
}
     82a:	df 91       	pop	r29
     82c:	cf 91       	pop	r28
     82e:	08 95       	ret

00000830 <init_devices_pos>:

//Function to initialize all the devices
void init_devices_pos()
{
 cli(); //Clears the global interrupt
     830:	f8 94       	cli
 port_init_pos();  //Initializes all the ports
     832:	0e 94 b4 02 	call	0x568	; 0x568 <port_init_pos>
 left_position_encoder_interrupt_init();
     836:	0e 94 bb 02 	call	0x576	; 0x576 <left_position_encoder_interrupt_init>
 right_position_encoder_interrupt_init();
     83a:	0e 94 c4 02 	call	0x588	; 0x588 <right_position_encoder_interrupt_init>
 sei();   // Enables the global interrupt 
     83e:	78 94       	sei
}
     840:	08 95       	ret

00000842 <servo1_pin_config>:
#include <util/delay.h>

//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
	DDRD  = DDRD | 0x80;  //making PORTB 5 pin output
     842:	8f 9a       	sbi	0x11, 7	; 17
	PORTD = PORTD | 0x80; //setting PORTB 5 pin to logic 1
     844:	97 9a       	sbi	0x12, 7	; 18
}
     846:	08 95       	ret

00000848 <port_init_servo>:
void port_init_servo(void)
{
	servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
     848:	0e 94 21 04 	call	0x842	; 0x842 <servo1_pin_config>
	
}
     84c:	08 95       	ret

0000084e <timer2_init>:
void timer2_init(void)
{
 TCCR2= 0x00; //stop
     84e:	15 bc       	out	0x25, r1	; 37
 TCNT2 = 0xFE;
     850:	8e ef       	ldi	r24, 0xFE	; 254
     852:	84 bd       	out	0x24, r24	; 36
 OCR2 = 0x8F;
     854:	8f e8       	ldi	r24, 0x8F	; 143
     856:	83 bd       	out	0x23, r24	; 35
 TCCR2= (1<< COM21)|(1<<WGM20)|(1<<WGM21);
     858:	88 e6       	ldi	r24, 0x68	; 104
     85a:	85 bd       	out	0x25, r24	; 37
 //OCR2 = 0x8F;	//Output compare Register high value for servo 1
 
 
 
 
 TCCR2|= (1<<CS22)|(1<<CS20);
     85c:	85 b5       	in	r24, 0x25	; 37
     85e:	85 60       	ori	r24, 0x05	; 5
     860:	85 bd       	out	0x25, r24	; 37
 
}
     862:	08 95       	ret

00000864 <init_devices_servo>:
void init_devices_servo(void)
{
	cli(); //disable all interrupts
     864:	f8 94       	cli
	port_init_servo();
     866:	0e 94 24 04 	call	0x848	; 0x848 <port_init_servo>
	timer2_init();
     86a:	0e 94 27 04 	call	0x84e	; 0x84e <timer2_init>
	sei(); //re-enable interrupts
     86e:	78 94       	sei
}
     870:	08 95       	ret

00000872 <servo_1>:

void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
     872:	68 2f       	mov	r22, r24
     874:	70 e0       	ldi	r23, 0x00	; 0
     876:	80 e0       	ldi	r24, 0x00	; 0
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	0e 94 18 0e 	call	0x1c30	; 0x1c30 <__floatunsisf>
     87e:	2b e7       	ldi	r18, 0x7B	; 123
     880:	34 e1       	ldi	r19, 0x14	; 20
     882:	4e ee       	ldi	r20, 0xEE	; 238
     884:	5f e3       	ldi	r21, 0x3F	; 63
     886:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <__divsf3>
     88a:	20 e0       	ldi	r18, 0x00	; 0
     88c:	30 e0       	ldi	r19, 0x00	; 0
     88e:	4c e0       	ldi	r20, 0x0C	; 12
     890:	52 e4       	ldi	r21, 0x42	; 66
     892:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <__addsf3>
	
	//OCR1AH = 0x00;
	OCR2 = (unsigned char) PositionPanServo;
     896:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <__fixunssfsi>
     89a:	63 bd       	out	0x23, r22	; 35
}
     89c:	08 95       	ret

0000089e <servo_1_free>:
void servo_1_free (void) //makes servo 1 free rotating
{
	//OCR1AH = 0x03;
	OCR2 = 0x8F; //Servo 1 off
     89e:	8f e8       	ldi	r24, 0x8F	; 143
     8a0:	83 bd       	out	0x23, r24	; 35
}
     8a2:	08 95       	ret

000008a4 <adc_pin_config_sharp>:
}*/

//ADC pin configuration
void adc_pin_config_sharp (void)
{
 DDRA = 0x00;  //set PORTF direction as input
     8a4:	1a ba       	out	0x1a, r1	; 26
 PORTA = 0x00; //set PORTF pins floating
     8a6:	1b ba       	out	0x1b, r1	; 27
}
     8a8:	08 95       	ret

000008aa <ultrsonic_trigger_config>:

void ultrsonic_trigger_config(void)
{
 DDRD = DDRD | 0x40;   //all the LCD pin's direction set as output
     8aa:	8e 9a       	sbi	0x11, 6	; 17
 PORTD = PORTD & 0x00; // all the LCD pins are set to logic 0 except PORTC 7
     8ac:	82 b3       	in	r24, 0x12	; 18
     8ae:	12 ba       	out	0x12, r1	; 18
}
     8b0:	08 95       	ret

000008b2 <port_init_sharp>:

//Function to Initialize PORTs
void port_init_sharp()
{
 //lcd_port_config();
 adc_pin_config_sharp();		
     8b2:	0e 94 52 04 	call	0x8a4	; 0x8a4 <adc_pin_config_sharp>
 ultrsonic_trigger_config();
     8b6:	0e 94 55 04 	call	0x8aa	; 0x8aa <ultrsonic_trigger_config>
}
     8ba:	08 95       	ret

000008bc <adc_init_sharp>:

//Function to Initialize ADC
void adc_init_sharp()
{
 ADCSRA = 0x00;
     8bc:	16 b8       	out	0x06, r1	; 6
 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     8be:	80 e2       	ldi	r24, 0x20	; 32
     8c0:	87 b9       	out	0x07, r24	; 7
 ACSR = 0x80;
     8c2:	80 e8       	ldi	r24, 0x80	; 128
     8c4:	88 b9       	out	0x08, r24	; 8
 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     8c6:	86 e8       	ldi	r24, 0x86	; 134
     8c8:	86 b9       	out	0x06, r24	; 6
}
     8ca:	08 95       	ret

000008cc <ADC_Conversion_sharp>:

//This Function accepts the Channel Number and returns the corresponding Analog Value 
unsigned char ADC_Conversion_sharp(unsigned char Ch)
{
 unsigned char a;
 Ch = Ch & 0x07;  			
     8cc:	87 70       	andi	r24, 0x07	; 7
 ADMUX= 0x20| Ch;	   		
     8ce:	80 62       	ori	r24, 0x20	; 32
     8d0:	87 b9       	out	0x07, r24	; 7
 ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     8d2:	36 9a       	sbi	0x06, 6	; 6
 while((ADCSRA&0x10)==0);	    //Wait for ADC conversion to complete
     8d4:	34 9b       	sbis	0x06, 4	; 6
     8d6:	fe cf       	rjmp	.-4      	; 0x8d4 <ADC_Conversion_sharp+0x8>
 a=ADCH;
     8d8:	85 b1       	in	r24, 0x05	; 5
 ADCSRA = ADCSRA|0x10;          //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     8da:	34 9a       	sbi	0x06, 4	; 6
 return a;
}
     8dc:	08 95       	ret

000008de <ultrasonic_trigger>:

// Ultrasonic sensor are connected in chaining mode. This function rise a 
// trigger pulse of >20usec to command ringing.     
void ultrasonic_trigger(void)                 
{
 PORTD = PORTD | 0x40;  // make high the Trigger input for Ultrasonic sensor
     8de:	96 9a       	sbi	0x12, 6	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     8e0:	8b e7       	ldi	r24, 0x7B	; 123
     8e2:	8a 95       	dec	r24
     8e4:	f1 f7       	brne	.-4      	; 0x8e2 <ultrasonic_trigger+0x4>
 _delay_us(50);         // Wait for >20usec
 PORTD = PORTD & 0xBF;  // make low the Trigger input for Ultrasonic sensor
     8e6:	96 98       	cbi	0x12, 6	; 18
}
     8e8:	08 95       	ret

000008ea <init_devices_sharp>:

void init_devices_sharp (void)
{
 cli();           //Clears the global interrupts
     8ea:	f8 94       	cli
 port_init_sharp();
     8ec:	0e 94 59 04 	call	0x8b2	; 0x8b2 <port_init_sharp>
 adc_init_sharp();
     8f0:	0e 94 5e 04 	call	0x8bc	; 0x8bc <adc_init_sharp>
 sei();           //Enables the global interrupts
     8f4:	78 94       	sei
}
     8f6:	08 95       	ret

000008f8 <servo100>:
volatile unsigned char mark=2;
volatile unsigned char b=0;//blue bot
volatile unsigned char bs=0;
volatile unsigned char next=0;
void servo100()
{
     8f8:	cf 93       	push	r28
     8fa:	cf e5       	ldi	r28, 0x5F	; 95
	for(int i=95;i<=180;i=i+3)
	{
		init_devices_sharp();
     8fc:	0e 94 75 04 	call	0x8ea	; 0x8ea <init_devices_sharp>
		//			lcd_set_4bit();
		//			lcd_init();
		for (int i=0;i<2;i++)
		{
			Center_ultrasonic_Sensor = ADC_Conversion_sharp(1) * 2;
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	0e 94 66 04 	call	0x8cc	; 0x8cc <ADC_Conversion_sharp>
     906:	88 0f       	add	r24, r24
     908:	80 93 d8 00 	sts	0x00D8, r24
     90c:	81 e0       	ldi	r24, 0x01	; 1
     90e:	0e 94 66 04 	call	0x8cc	; 0x8cc <ADC_Conversion_sharp>
     912:	88 0f       	add	r24, r24
     914:	80 93 d8 00 	sts	0x00D8, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     918:	8f ef       	ldi	r24, 0xFF	; 255
     91a:	9f e3       	ldi	r25, 0x3F	; 63
     91c:	a2 e0       	ldi	r26, 0x02	; 2
     91e:	81 50       	subi	r24, 0x01	; 1
     920:	90 40       	sbci	r25, 0x00	; 0
     922:	a0 40       	sbci	r26, 0x00	; 0
     924:	e1 f7       	brne	.-8      	; 0x91e <servo100+0x26>
     926:	00 c0       	rjmp	.+0      	; 0x928 <servo100+0x30>
     928:	00 00       	nop
			//lcd_print(2,12,Center_ultrasonic_Sensor,3);       // In Inches
			
		}
		_delay_ms(100);
		
		init_devices_servo();
     92a:	0e 94 32 04 	call	0x864	; 0x864 <init_devices_servo>
		servo_1(i);
     92e:	8c 2f       	mov	r24, r28
     930:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     934:	af ef       	ldi	r26, 0xFF	; 255
     936:	b7 e4       	ldi	r27, 0x47	; 71
     938:	11 97       	sbiw	r26, 0x01	; 1
     93a:	f1 f7       	brne	.-4      	; 0x938 <servo100+0x40>
     93c:	00 c0       	rjmp	.+0      	; 0x93e <servo100+0x46>
     93e:	00 00       	nop
		_delay_ms(10);
		
		
		if(Center_ultrasonic_Sensor>200 )
     940:	80 91 d8 00 	lds	r24, 0x00D8
     944:	89 3c       	cpi	r24, 0xC9	; 201
     946:	30 f1       	brcs	.+76     	; 0x994 <servo100+0x9c>
		{
			servo_1(i);
     948:	8c 2f       	mov	r24, r28
     94a:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     94e:	8f ef       	ldi	r24, 0xFF	; 255
     950:	9f e7       	ldi	r25, 0x7F	; 127
     952:	a6 e1       	ldi	r26, 0x16	; 22
     954:	81 50       	subi	r24, 0x01	; 1
     956:	90 40       	sbci	r25, 0x00	; 0
     958:	a0 40       	sbci	r26, 0x00	; 0
     95a:	e1 f7       	brne	.-8      	; 0x954 <servo100+0x5c>
     95c:	00 c0       	rjmp	.+0      	; 0x95e <servo100+0x66>
     95e:	00 00       	nop
			_delay_ms(1000);
			//buzzer_beep();
			side=100;
     960:	84 e6       	ldi	r24, 0x64	; 100
     962:	80 93 71 00 	sts	0x0071, r24
			color_sensor_work();
     966:	0e 94 82 08 	call	0x1104	; 0x1104 <color_sensor_work>
     96a:	8f ef       	ldi	r24, 0xFF	; 255
     96c:	9f e3       	ldi	r25, 0x3F	; 63
     96e:	a2 e0       	ldi	r26, 0x02	; 2
     970:	81 50       	subi	r24, 0x01	; 1
     972:	90 40       	sbci	r25, 0x00	; 0
     974:	a0 40       	sbci	r26, 0x00	; 0
     976:	e1 f7       	brne	.-8      	; 0x970 <servo100+0x78>
     978:	00 c0       	rjmp	.+0      	; 0x97a <servo100+0x82>
     97a:	00 00       	nop
			
			_delay_ms(100);
			do_task();
     97c:	0e 94 49 00 	call	0x92	; 0x92 <do_task>
     980:	8f ef       	ldi	r24, 0xFF	; 255
     982:	9f e3       	ldi	r25, 0x3F	; 63
     984:	ab e0       	ldi	r26, 0x0B	; 11
     986:	81 50       	subi	r24, 0x01	; 1
     988:	90 40       	sbci	r25, 0x00	; 0
     98a:	a0 40       	sbci	r26, 0x00	; 0
     98c:	e1 f7       	brne	.-8      	; 0x986 <servo100+0x8e>
     98e:	00 c0       	rjmp	.+0      	; 0x990 <servo100+0x98>
     990:	00 00       	nop
     992:	04 c0       	rjmp	.+8      	; 0x99c <servo100+0xa4>
     994:	cd 5f       	subi	r28, 0xFD	; 253
volatile unsigned char b=0;//blue bot
volatile unsigned char bs=0;
volatile unsigned char next=0;
void servo100()
{
	for(int i=95;i<=180;i=i+3)
     996:	c6 3b       	cpi	r28, 0xB6	; 182
     998:	09 f0       	breq	.+2      	; 0x99c <servo100+0xa4>
     99a:	b0 cf       	rjmp	.-160    	; 0x8fc <servo100+0x4>
			
			
		}
		
	}
	servo_1(95);
     99c:	8f e5       	ldi	r24, 0x5F	; 95
     99e:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     9a2:	8f ef       	ldi	r24, 0xFF	; 255
     9a4:	9f e3       	ldi	r25, 0x3F	; 63
     9a6:	ab e0       	ldi	r26, 0x0B	; 11
     9a8:	81 50       	subi	r24, 0x01	; 1
     9aa:	90 40       	sbci	r25, 0x00	; 0
     9ac:	a0 40       	sbci	r26, 0x00	; 0
     9ae:	e1 f7       	brne	.-8      	; 0x9a8 <servo100+0xb0>
     9b0:	00 c0       	rjmp	.+0      	; 0x9b2 <servo100+0xba>
     9b2:	00 00       	nop
	_delay_ms(500);
	
}
     9b4:	cf 91       	pop	r28
     9b6:	08 95       	ret

000009b8 <servo101>:
void servo101()
{
     9b8:	cf 93       	push	r28
     9ba:	cf e5       	ldi	r28, 0x5F	; 95
	for(int i=95;i>=10;i=i-3)
	{
		init_devices_sharp();
     9bc:	0e 94 75 04 	call	0x8ea	; 0x8ea <init_devices_sharp>
		//			lcd_set_4bit();
		//			lcd_init();
		for (int i=0;i<2;i++)
		{
			Center_ultrasonic_Sensor = ADC_Conversion_sharp(1) * 2;
     9c0:	81 e0       	ldi	r24, 0x01	; 1
     9c2:	0e 94 66 04 	call	0x8cc	; 0x8cc <ADC_Conversion_sharp>
     9c6:	88 0f       	add	r24, r24
     9c8:	80 93 d8 00 	sts	0x00D8, r24
     9cc:	81 e0       	ldi	r24, 0x01	; 1
     9ce:	0e 94 66 04 	call	0x8cc	; 0x8cc <ADC_Conversion_sharp>
     9d2:	88 0f       	add	r24, r24
     9d4:	80 93 d8 00 	sts	0x00D8, r24
     9d8:	8f ef       	ldi	r24, 0xFF	; 255
     9da:	9f e3       	ldi	r25, 0x3F	; 63
     9dc:	a2 e0       	ldi	r26, 0x02	; 2
     9de:	81 50       	subi	r24, 0x01	; 1
     9e0:	90 40       	sbci	r25, 0x00	; 0
     9e2:	a0 40       	sbci	r26, 0x00	; 0
     9e4:	e1 f7       	brne	.-8      	; 0x9de <servo101+0x26>
     9e6:	00 c0       	rjmp	.+0      	; 0x9e8 <servo101+0x30>
     9e8:	00 00       	nop
			//lcd_print(2,12,Center_ultrasonic_Sensor,3);       // In Inches
			
		}
		_delay_ms(100);
		
		init_devices_servo();
     9ea:	0e 94 32 04 	call	0x864	; 0x864 <init_devices_servo>
		servo_1(i);
     9ee:	8c 2f       	mov	r24, r28
     9f0:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     9f4:	af ef       	ldi	r26, 0xFF	; 255
     9f6:	b7 e4       	ldi	r27, 0x47	; 71
     9f8:	11 97       	sbiw	r26, 0x01	; 1
     9fa:	f1 f7       	brne	.-4      	; 0x9f8 <servo101+0x40>
     9fc:	00 c0       	rjmp	.+0      	; 0x9fe <servo101+0x46>
     9fe:	00 00       	nop
		_delay_ms(10);
		
		
		if(Center_ultrasonic_Sensor>200 )
     a00:	80 91 d8 00 	lds	r24, 0x00D8
     a04:	89 3c       	cpi	r24, 0xC9	; 201
     a06:	28 f1       	brcs	.+74     	; 0xa52 <servo101+0x9a>
		{	servo_1_free();
     a08:	0e 94 4f 04 	call	0x89e	; 0x89e <servo_1_free>
     a0c:	8f ef       	ldi	r24, 0xFF	; 255
     a0e:	9f e7       	ldi	r25, 0x7F	; 127
     a10:	a6 e1       	ldi	r26, 0x16	; 22
     a12:	81 50       	subi	r24, 0x01	; 1
     a14:	90 40       	sbci	r25, 0x00	; 0
     a16:	a0 40       	sbci	r26, 0x00	; 0
     a18:	e1 f7       	brne	.-8      	; 0xa12 <servo101+0x5a>
     a1a:	00 c0       	rjmp	.+0      	; 0xa1c <servo101+0x64>
     a1c:	00 00       	nop
			_delay_ms(1000);
			//buzzer_beep();
			side=101;
     a1e:	85 e6       	ldi	r24, 0x65	; 101
     a20:	80 93 71 00 	sts	0x0071, r24
			color_sensor_work();
     a24:	0e 94 82 08 	call	0x1104	; 0x1104 <color_sensor_work>
     a28:	8f ef       	ldi	r24, 0xFF	; 255
     a2a:	9f e3       	ldi	r25, 0x3F	; 63
     a2c:	a2 e0       	ldi	r26, 0x02	; 2
     a2e:	81 50       	subi	r24, 0x01	; 1
     a30:	90 40       	sbci	r25, 0x00	; 0
     a32:	a0 40       	sbci	r26, 0x00	; 0
     a34:	e1 f7       	brne	.-8      	; 0xa2e <servo101+0x76>
     a36:	00 c0       	rjmp	.+0      	; 0xa38 <servo101+0x80>
     a38:	00 00       	nop
			
			_delay_ms(100);
			do_task();
     a3a:	0e 94 49 00 	call	0x92	; 0x92 <do_task>
     a3e:	8f ef       	ldi	r24, 0xFF	; 255
     a40:	9f e3       	ldi	r25, 0x3F	; 63
     a42:	ab e0       	ldi	r26, 0x0B	; 11
     a44:	81 50       	subi	r24, 0x01	; 1
     a46:	90 40       	sbci	r25, 0x00	; 0
     a48:	a0 40       	sbci	r26, 0x00	; 0
     a4a:	e1 f7       	brne	.-8      	; 0xa44 <servo101+0x8c>
     a4c:	00 c0       	rjmp	.+0      	; 0xa4e <servo101+0x96>
     a4e:	00 00       	nop
     a50:	04 c0       	rjmp	.+8      	; 0xa5a <servo101+0xa2>
     a52:	c3 50       	subi	r28, 0x03	; 3
	_delay_ms(500);
	
}
void servo101()
{
	for(int i=95;i>=10;i=i-3)
     a54:	c8 30       	cpi	r28, 0x08	; 8
     a56:	09 f0       	breq	.+2      	; 0xa5a <servo101+0xa2>
     a58:	b1 cf       	rjmp	.-158    	; 0x9bc <servo101+0x4>
			
			break;
		}
		
	}
	servo_1(95);
     a5a:	8f e5       	ldi	r24, 0x5F	; 95
     a5c:	0e 94 39 04 	call	0x872	; 0x872 <servo_1>
     a60:	8f ef       	ldi	r24, 0xFF	; 255
     a62:	9f e3       	ldi	r25, 0x3F	; 63
     a64:	a2 e0       	ldi	r26, 0x02	; 2
     a66:	81 50       	subi	r24, 0x01	; 1
     a68:	90 40       	sbci	r25, 0x00	; 0
     a6a:	a0 40       	sbci	r26, 0x00	; 0
     a6c:	e1 f7       	brne	.-8      	; 0xa66 <servo101+0xae>
     a6e:	00 c0       	rjmp	.+0      	; 0xa70 <servo101+0xb8>
     a70:	00 00       	nop
	_delay_ms(100);
}
     a72:	cf 91       	pop	r28
     a74:	08 95       	ret

00000a76 <lcd_port_config>:

//Function to configure LCD port
void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7;    //all the LCD pin's direction set as output
     a76:	84 b3       	in	r24, 0x14	; 20
     a78:	87 6f       	ori	r24, 0xF7	; 247
     a7a:	84 bb       	out	0x14, r24	; 20
 PORTC = PORTC & 0x80;  // all the LCD pins are set to logic 0 except PORTC 7
     a7c:	85 b3       	in	r24, 0x15	; 21
     a7e:	80 78       	andi	r24, 0x80	; 128
     a80:	85 bb       	out	0x15, r24	; 21
}
     a82:	08 95       	ret

00000a84 <adc_pin_config>:

//ADC pin configuration
void adc_pin_config (void)
{
 DDRA = 0x00;   //set PORTF direction as input
     a84:	1a ba       	out	0x1a, r1	; 26
 PORTA = 0x00;  //set PORTF pins floating
     a86:	1b ba       	out	0x1b, r1	; 27
}
     a88:	08 95       	ret

00000a8a <motion_pin_config>:

//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
 DDRB = DDRB | 0x0F;    //set direction of the PORTB3 to PORTB0 pins as output
     a8a:	87 b3       	in	r24, 0x17	; 23
     a8c:	8f 60       	ori	r24, 0x0F	; 15
     a8e:	87 bb       	out	0x17, r24	; 23
 PORTB = PORTB & 0xF0;  //set initial value of the PORTB3 to PORTB0 pins to logic 0
     a90:	88 b3       	in	r24, 0x18	; 24
     a92:	80 7f       	andi	r24, 0xF0	; 240
     a94:	88 bb       	out	0x18, r24	; 24
 DDRD = DDRD | 0x30;    //Setting PD5 and PD4 pins as output for PWM generation
     a96:	81 b3       	in	r24, 0x11	; 17
     a98:	80 63       	ori	r24, 0x30	; 48
     a9a:	81 bb       	out	0x11, r24	; 17
 PORTD = PORTD | 0x30;  //PD5 and PD4 pins are for velocity control using PWM
     a9c:	82 b3       	in	r24, 0x12	; 18
     a9e:	80 63       	ori	r24, 0x30	; 48
     aa0:	82 bb       	out	0x12, r24	; 18
}
     aa2:	08 95       	ret

00000aa4 <port_init>:

//Function to Initialize PORTS
void port_init()
{
 lcd_port_config();
     aa4:	0e 94 3b 05 	call	0xa76	; 0xa76 <lcd_port_config>
 adc_pin_config();		
     aa8:	0e 94 42 05 	call	0xa84	; 0xa84 <adc_pin_config>
 motion_pin_config();
     aac:	0e 94 45 05 	call	0xa8a	; 0xa8a <motion_pin_config>
}
     ab0:	08 95       	ret

00000ab2 <timer1_init>:
// WGM: 5) PWM 8bit fast, TOP=0x00FF
// desired value: 450Hz
// actual value: 450.000Hz (0.0%)
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     ab2:	1e bc       	out	0x2e, r1	; 46
 TCNT1H = 0xFF; //setup
     ab4:	8f ef       	ldi	r24, 0xFF	; 255
     ab6:	8d bd       	out	0x2d, r24	; 45
 TCNT1L = 0x01;
     ab8:	91 e0       	ldi	r25, 0x01	; 1
     aba:	9c bd       	out	0x2c, r25	; 44
 OCR1AH = 0x00;
     abc:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = 0xFF;
     abe:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     ac0:	19 bc       	out	0x29, r1	; 41
 OCR1BL = 0xFF;
     ac2:	88 bd       	out	0x28, r24	; 40
 ICR1H  = 0x00;
     ac4:	17 bc       	out	0x27, r1	; 39
 ICR1L  = 0xFF;
     ac6:	86 bd       	out	0x26, r24	; 38
 TCCR1A = 0xA1;
     ac8:	81 ea       	ldi	r24, 0xA1	; 161
     aca:	8f bd       	out	0x2f, r24	; 47
 TCCR1B = 0x0D; //start Timer
     acc:	8d e0       	ldi	r24, 0x0D	; 13
     ace:	8e bd       	out	0x2e, r24	; 46
}
     ad0:	08 95       	ret

00000ad2 <adc_init>:


//Function to Initialize ADC
void adc_init()
{
 ADCSRA = 0x00;
     ad2:	16 b8       	out	0x06, r1	; 6
 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     ad4:	80 e2       	ldi	r24, 0x20	; 32
     ad6:	87 b9       	out	0x07, r24	; 7
 ACSR = 0x80;
     ad8:	80 e8       	ldi	r24, 0x80	; 128
     ada:	88 b9       	out	0x08, r24	; 8
 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     adc:	86 e8       	ldi	r24, 0x86	; 134
     ade:	86 b9       	out	0x06, r24	; 6
}
     ae0:	08 95       	ret

00000ae2 <ADC_Conversion>:

//This Function accepts the Channel Number and returns the corresponding Analog Value 
unsigned char ADC_Conversion(unsigned char Ch)
{
 unsigned char a;
 Ch = Ch & 0x07;  			
     ae2:	87 70       	andi	r24, 0x07	; 7
 ADMUX= 0x20| Ch;	   		
     ae4:	80 62       	ori	r24, 0x20	; 32
     ae6:	87 b9       	out	0x07, r24	; 7
 ADCSRA = ADCSRA | 0x40;	//Set start conversion bit
     ae8:	36 9a       	sbi	0x06, 6	; 6
 while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     aea:	34 9b       	sbis	0x06, 4	; 6
     aec:	fe cf       	rjmp	.-4      	; 0xaea <ADC_Conversion+0x8>
 a=ADCH;
     aee:	85 b1       	in	r24, 0x05	; 5
 ADCSRA = ADCSRA|0x10;      //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     af0:	34 9a       	sbi	0x06, 4	; 6
 return a;
}
     af2:	08 95       	ret

00000af4 <print_sensor>:

// This Function prints the Analog Value Of Corresponding Channel No. at required Row
// and Coloumn Location. 
void print_sensor(char row, char coloumn,unsigned char channel)
{
     af4:	84 2f       	mov	r24, r20
 ADC_Value = ADC_Conversion(channel);
     af6:	0e 94 71 05 	call	0xae2	; 0xae2 <ADC_Conversion>
     afa:	80 93 d7 00 	sts	0x00D7, r24
// lcd_print(row, coloumn, ADC_Value, 3);
}
     afe:	08 95       	ret

00000b00 <motion_set>:
void motion_set (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 			// removing upper nibbel as it is not needed
 PortBRestore = PORTB; 			// reading the PORTB's original status
     b00:	98 b3       	in	r25, 0x18	; 24
 PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
     b02:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 			// removing upper nibbel as it is not needed
     b04:	8f 70       	andi	r24, 0x0F	; 15
 PortBRestore = PORTB; 			// reading the PORTB's original status
 PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
 PortBRestore |= Direction; 	// adding lower nibbel for direction command and restoring the PORTB status
     b06:	98 2b       	or	r25, r24
 PORTB = PortBRestore; 			// setting the command to the port
     b08:	98 bb       	out	0x18, r25	; 24
}
     b0a:	08 95       	ret

00000b0c <forward>:

void forward (void) //both wheels forward
{
  motion_set(0x06);
     b0c:	86 e0       	ldi	r24, 0x06	; 6
     b0e:	0e 94 80 05 	call	0xb00	; 0xb00 <motion_set>
}
     b12:	08 95       	ret

00000b14 <back>:

void back (void) //hard stop
{
  motion_set(0x09);
     b14:	89 e0       	ldi	r24, 0x09	; 9
     b16:	0e 94 80 05 	call	0xb00	; 0xb00 <motion_set>
}
     b1a:	08 95       	ret

00000b1c <left>:
void left (void) //hard stop
{
	motion_set(0x05);
     b1c:	85 e0       	ldi	r24, 0x05	; 5
     b1e:	0e 94 80 05 	call	0xb00	; 0xb00 <motion_set>
}
     b22:	08 95       	ret

00000b24 <right>:
void right (void) //hard stop
{
	motion_set(0x0A);
     b24:	8a e0       	ldi	r24, 0x0A	; 10
     b26:	0e 94 80 05 	call	0xb00	; 0xb00 <motion_set>
}
     b2a:	08 95       	ret

00000b2c <hard_stop>:
void hard_stop (void) //hard stop
{
	motion_set(0x00);
     b2c:	80 e0       	ldi	r24, 0x00	; 0
     b2e:	0e 94 80 05 	call	0xb00	; 0xb00 <motion_set>
}
     b32:	08 95       	ret

00000b34 <s_L>:
void s_L (void) //hard stop
{
	motion_set(0x04);
     b34:	84 e0       	ldi	r24, 0x04	; 4
     b36:	0e 94 80 05 	call	0xb00	; 0xb00 <motion_set>
}
     b3a:	08 95       	ret

00000b3c <S_R>:
void S_R (void) //hard stop
{
	motion_set(0x02);
     b3c:	82 e0       	ldi	r24, 0x02	; 2
     b3e:	0e 94 80 05 	call	0xb00	; 0xb00 <motion_set>
}
     b42:	08 95       	ret

00000b44 <S_STOP>:
void S_STOP (void) //hard stop
{
	motion_set(0x0F);
     b44:	8f e0       	ldi	r24, 0x0F	; 15
     b46:	0e 94 80 05 	call	0xb00	; 0xb00 <motion_set>
}
     b4a:	08 95       	ret

00000b4c <velocity>:


//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
 OCR1AH = 0x00;
     b4c:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = left_motor; 
     b4e:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     b50:	19 bc       	out	0x29, r1	; 41
 OCR1BL = right_motor;
     b52:	68 bd       	out	0x28, r22	; 40
}
     b54:	08 95       	ret

00000b56 <success>:
	}
}


void success(int x)
{
     b56:	0f 93       	push	r16
     b58:	1f 93       	push	r17
     b5a:	cf 93       	push	r28
     b5c:	df 93       	push	r29
     b5e:	ec 01       	movw	r28, r24
	unsigned char Left_white_line = 0;
	unsigned char Center_white_line = 0;
	unsigned char Right_white_line = 0;

	switch (x)
     b60:	82 30       	cpi	r24, 0x02	; 2
     b62:	91 05       	cpc	r25, r1
     b64:	b1 f0       	breq	.+44     	; 0xb92 <success+0x3c>
     b66:	83 30       	cpi	r24, 0x03	; 3
     b68:	91 05       	cpc	r25, r1
     b6a:	19 f1       	breq	.+70     	; 0xbb2 <success+0x5c>
     b6c:	81 30       	cpi	r24, 0x01	; 1
     b6e:	91 05       	cpc	r25, r1
     b70:	79 f5       	brne	.+94     	; 0xbd0 <success+0x7a>
	{
		case 1:
		
		velocity(VELOCITY_MAX,VELOCITY_MAX);      // Run robot at max velocity
     b72:	8c e3       	ldi	r24, 0x3C	; 60
     b74:	6c e3       	ldi	r22, 0x3C	; 60
     b76:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
		forward();
     b7a:	0e 94 86 05 	call	0xb0c	; 0xb0c <forward>
     b7e:	8f ef       	ldi	r24, 0xFF	; 255
     b80:	9f e3       	ldi	r25, 0x3F	; 63
     b82:	a2 e0       	ldi	r26, 0x02	; 2
     b84:	81 50       	subi	r24, 0x01	; 1
     b86:	90 40       	sbci	r25, 0x00	; 0
     b88:	a0 40       	sbci	r26, 0x00	; 0
     b8a:	e1 f7       	brne	.-8      	; 0xb84 <success+0x2e>
     b8c:	00 c0       	rjmp	.+0      	; 0xb8e <success+0x38>
     b8e:	00 00       	nop
     b90:	1f c0       	rjmp	.+62     	; 0xbd0 <success+0x7a>
		_delay_ms(100);
		break;
		case 2:
		velocity(VELOCITY_MAX,VELOCITY_MIN);      // Run robot left wheel at max velocity and right wheel
     b92:	8c e3       	ldi	r24, 0x3C	; 60
     b94:	64 e1       	ldi	r22, 0x14	; 20
     b96:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
		S_R();
     b9a:	0e 94 9e 05 	call	0xb3c	; 0xb3c <S_R>
     b9e:	8f ef       	ldi	r24, 0xFF	; 255
     ba0:	9f e9       	ldi	r25, 0x9F	; 159
     ba2:	a7 e1       	ldi	r26, 0x17	; 23
     ba4:	81 50       	subi	r24, 0x01	; 1
     ba6:	90 40       	sbci	r25, 0x00	; 0
     ba8:	a0 40       	sbci	r26, 0x00	; 0
     baa:	e1 f7       	brne	.-8      	; 0xba4 <success+0x4e>
     bac:	00 c0       	rjmp	.+0      	; 0xbae <success+0x58>
     bae:	00 00       	nop
     bb0:	0f c0       	rjmp	.+30     	; 0xbd0 <success+0x7a>
		_delay_ms(1050);
		
		break;
		case 3:
		velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel 
     bb2:	84 e1       	ldi	r24, 0x14	; 20
     bb4:	6c e3       	ldi	r22, 0x3C	; 60
     bb6:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
		s_L();
     bba:	0e 94 9a 05 	call	0xb34	; 0xb34 <s_L>
     bbe:	8f ef       	ldi	r24, 0xFF	; 255
     bc0:	9f e9       	ldi	r25, 0x9F	; 159
     bc2:	a7 e1       	ldi	r26, 0x17	; 23
     bc4:	81 50       	subi	r24, 0x01	; 1
     bc6:	90 40       	sbci	r25, 0x00	; 0
     bc8:	a0 40       	sbci	r26, 0x00	; 0
     bca:	e1 f7       	brne	.-8      	; 0xbc4 <success+0x6e>
     bcc:	00 c0       	rjmp	.+0      	; 0xbce <success+0x78>
     bce:	00 00       	nop
	}
	
	while(1)
	{
		
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     bd0:	83 e0       	ldi	r24, 0x03	; 3
     bd2:	0e 94 71 05 	call	0xae2	; 0xae2 <ADC_Conversion>
     bd6:	08 2f       	mov	r16, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     bd8:	82 e0       	ldi	r24, 0x02	; 2
     bda:	0e 94 71 05 	call	0xae2	; 0xae2 <ADC_Conversion>
     bde:	18 2f       	mov	r17, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
     be0:	81 e0       	ldi	r24, 0x01	; 1
     be2:	0e 94 71 05 	call	0xae2	; 0xae2 <ADC_Conversion>

//		print_sensor(1,1,3);	//Prints value of White Line Sensor1
		//print_sensor(1,5,2);	//Prints Value of White Line Sensor2
	//	print_sensor(1,9,1);	//Prints Value of White Line Sensor3

		if(Center_white_line<0x19 && Left_white_line<0x19 && Right_white_line<0x19)
     be6:	19 31       	cpi	r17, 0x19	; 25
     be8:	f0 f5       	brcc	.+124    	; 0xc66 <success+0x110>
     bea:	09 31       	cpi	r16, 0x19	; 25
     bec:	08 f0       	brcs	.+2      	; 0xbf0 <success+0x9a>
     bee:	4d c0       	rjmp	.+154    	; 0xc8a <success+0x134>
     bf0:	89 31       	cpi	r24, 0x19	; 25
     bf2:	d8 f5       	brcc	.+118    	; 0xc6a <success+0x114>
		{
			switch (x)
     bf4:	c2 30       	cpi	r28, 0x02	; 2
     bf6:	d1 05       	cpc	r29, r1
     bf8:	b1 f0       	breq	.+44     	; 0xc26 <success+0xd0>
     bfa:	c3 30       	cpi	r28, 0x03	; 3
     bfc:	d1 05       	cpc	r29, r1
     bfe:	19 f1       	breq	.+70     	; 0xc46 <success+0xf0>
     c00:	c1 30       	cpi	r28, 0x01	; 1
     c02:	d1 05       	cpc	r29, r1
     c04:	29 f7       	brne	.-54     	; 0xbd0 <success+0x7a>
			{
				case 1:
				
				velocity(VELOCITY_MAX,VELOCITY_MAX);      // Run robot at max velocity
     c06:	8c e3       	ldi	r24, 0x3C	; 60
     c08:	6c e3       	ldi	r22, 0x3C	; 60
     c0a:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
				forward();
     c0e:	0e 94 86 05 	call	0xb0c	; 0xb0c <forward>
     c12:	8f ef       	ldi	r24, 0xFF	; 255
     c14:	9f e3       	ldi	r25, 0x3F	; 63
     c16:	a2 e0       	ldi	r26, 0x02	; 2
     c18:	81 50       	subi	r24, 0x01	; 1
     c1a:	90 40       	sbci	r25, 0x00	; 0
     c1c:	a0 40       	sbci	r26, 0x00	; 0
     c1e:	e1 f7       	brne	.-8      	; 0xc18 <success+0xc2>
     c20:	00 c0       	rjmp	.+0      	; 0xc22 <success+0xcc>
     c22:	00 00       	nop
     c24:	d5 cf       	rjmp	.-86     	; 0xbd0 <success+0x7a>
				_delay_ms(100);
				break;
				case 2:
				velocity(VELOCITY_MAX,VELOCITY_MIN);      // Run robot left wheel at max velocity and right wheel
     c26:	8c e3       	ldi	r24, 0x3C	; 60
     c28:	64 e1       	ldi	r22, 0x14	; 20
     c2a:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
				S_R();
     c2e:	0e 94 9e 05 	call	0xb3c	; 0xb3c <S_R>
     c32:	8f ef       	ldi	r24, 0xFF	; 255
     c34:	9f e3       	ldi	r25, 0x3F	; 63
     c36:	a2 e0       	ldi	r26, 0x02	; 2
     c38:	81 50       	subi	r24, 0x01	; 1
     c3a:	90 40       	sbci	r25, 0x00	; 0
     c3c:	a0 40       	sbci	r26, 0x00	; 0
     c3e:	e1 f7       	brne	.-8      	; 0xc38 <success+0xe2>
     c40:	00 c0       	rjmp	.+0      	; 0xc42 <success+0xec>
     c42:	00 00       	nop
     c44:	c5 cf       	rjmp	.-118    	; 0xbd0 <success+0x7a>
				_delay_ms(100);
				
				break;
				case 3:
				velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel
     c46:	84 e1       	ldi	r24, 0x14	; 20
     c48:	6c e3       	ldi	r22, 0x3C	; 60
     c4a:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
				s_L();
     c4e:	0e 94 9a 05 	call	0xb34	; 0xb34 <s_L>
     c52:	8f ef       	ldi	r24, 0xFF	; 255
     c54:	9f e3       	ldi	r25, 0x3F	; 63
     c56:	a2 e0       	ldi	r26, 0x02	; 2
     c58:	81 50       	subi	r24, 0x01	; 1
     c5a:	90 40       	sbci	r25, 0x00	; 0
     c5c:	a0 40       	sbci	r26, 0x00	; 0
     c5e:	e1 f7       	brne	.-8      	; 0xc58 <success+0x102>
     c60:	00 c0       	rjmp	.+0      	; 0xc62 <success+0x10c>
     c62:	00 00       	nop
     c64:	b5 cf       	rjmp	.-150    	; 0xbd0 <success+0x7a>
		}


		

		else if((Left_white_line<0x19)) //&& (flag==0))
     c66:	09 31       	cpi	r16, 0x19	; 25
     c68:	80 f4       	brcc	.+32     	; 0xc8a <success+0x134>
		{
			//flag=1;
			forward();
     c6a:	0e 94 86 05 	call	0xb0c	; 0xb0c <forward>
			velocity(130,30);
     c6e:	82 e8       	ldi	r24, 0x82	; 130
     c70:	6e e1       	ldi	r22, 0x1E	; 30
     c72:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
     c76:	8f ef       	ldi	r24, 0xFF	; 255
     c78:	9f eb       	ldi	r25, 0xBF	; 191
     c7a:	a6 e0       	ldi	r26, 0x06	; 6
     c7c:	81 50       	subi	r24, 0x01	; 1
     c7e:	90 40       	sbci	r25, 0x00	; 0
     c80:	a0 40       	sbci	r26, 0x00	; 0
     c82:	e1 f7       	brne	.-8      	; 0xc7c <success+0x126>
     c84:	00 c0       	rjmp	.+0      	; 0xc86 <success+0x130>
     c86:	00 00       	nop
     c88:	24 c0       	rjmp	.+72     	; 0xcd2 <success+0x17c>
			_delay_ms(300);
			break;
		}

		else if((Right_white_line<0x19))// && (flag==0))
     c8a:	89 31       	cpi	r24, 0x19	; 25
     c8c:	80 f4       	brcc	.+32     	; 0xcae <success+0x158>
		{
			//	flag=1;
			
			forward();
     c8e:	0e 94 86 05 	call	0xb0c	; 0xb0c <forward>
			velocity(30,130);
     c92:	8e e1       	ldi	r24, 0x1E	; 30
     c94:	62 e8       	ldi	r22, 0x82	; 130
     c96:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
     c9a:	8f ef       	ldi	r24, 0xFF	; 255
     c9c:	9f eb       	ldi	r25, 0xBF	; 191
     c9e:	a6 e0       	ldi	r26, 0x06	; 6
     ca0:	81 50       	subi	r24, 0x01	; 1
     ca2:	90 40       	sbci	r25, 0x00	; 0
     ca4:	a0 40       	sbci	r26, 0x00	; 0
     ca6:	e1 f7       	brne	.-8      	; 0xca0 <success+0x14a>
     ca8:	00 c0       	rjmp	.+0      	; 0xcaa <success+0x154>
     caa:	00 00       	nop
     cac:	12 c0       	rjmp	.+36     	; 0xcd2 <success+0x17c>
			_delay_ms(300);
			break;
		}
		else if(Center_white_line>0x19)
     cae:	1a 31       	cpi	r17, 0x1A	; 26
     cb0:	08 f4       	brcc	.+2      	; 0xcb4 <success+0x15e>
     cb2:	8e cf       	rjmp	.-228    	; 0xbd0 <success+0x7a>
		{
			//flag=1;
			forward();
     cb4:	0e 94 86 05 	call	0xb0c	; 0xb0c <forward>
			velocity(135,135);
     cb8:	87 e8       	ldi	r24, 0x87	; 135
     cba:	67 e8       	ldi	r22, 0x87	; 135
     cbc:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
     cc0:	8f ef       	ldi	r24, 0xFF	; 255
     cc2:	9f eb       	ldi	r25, 0xBF	; 191
     cc4:	a6 e0       	ldi	r26, 0x06	; 6
     cc6:	81 50       	subi	r24, 0x01	; 1
     cc8:	90 40       	sbci	r25, 0x00	; 0
     cca:	a0 40       	sbci	r26, 0x00	; 0
     ccc:	e1 f7       	brne	.-8      	; 0xcc6 <success+0x170>
     cce:	00 c0       	rjmp	.+0      	; 0xcd0 <success+0x17a>
     cd0:	00 00       	nop
		
		

	}
	
     cd2:	df 91       	pop	r29
     cd4:	cf 91       	pop	r28
     cd6:	1f 91       	pop	r17
     cd8:	0f 91       	pop	r16
     cda:	08 95       	ret

00000cdc <init_devices>:

void init_devices (void)
{
 cli();          //Clears the global interrupts
     cdc:	f8 94       	cli
 port_init();
     cde:	0e 94 52 05 	call	0xaa4	; 0xaa4 <port_init>
 timer1_init();
     ce2:	0e 94 59 05 	call	0xab2	; 0xab2 <timer1_init>
 adc_init();
     ce6:	0e 94 69 05 	call	0xad2	; 0xad2 <adc_init>
 sei();          //Enables the global interrupts
     cea:	78 94       	sei
}
     cec:	08 95       	ret

00000cee <line_follower>:

//Main Function
int line_follower(void)
{
     cee:	cf 93       	push	r28
     cf0:	df 93       	push	r29
 //unsigned char flag ;

 init_devices();
     cf2:	0e 94 6e 06 	call	0xcdc	; 0xcdc <init_devices>

//  lcd_set_4bit();
//  lcd_init();

 velocity(VELOCITY_MAX,VELOCITY_MAX);    // Set the speed to max velocity
     cf6:	8c e3       	ldi	r24, 0x3C	; 60
     cf8:	6c e3       	ldi	r22, 0x3C	; 60
     cfa:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
//  lcd_print (2,1,VELOCITY_MAX,3);
//  lcd_print (2,5,VELOCITY_MAX,3);
//  //forward();                              // start to move froward

 
	Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     cfe:	83 e0       	ldi	r24, 0x03	; 3
     d00:	0e 94 71 05 	call	0xae2	; 0xae2 <ADC_Conversion>
     d04:	80 93 77 00 	sts	0x0077, r24
	Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
     d08:	84 e0       	ldi	r24, 0x04	; 4
     d0a:	0e 94 71 05 	call	0xae2	; 0xae2 <ADC_Conversion>
     d0e:	80 93 76 00 	sts	0x0076, r24
	Right_white_line = ADC_Conversion(5);	//Getting data of Right WL Sensor
     d12:	85 e0       	ldi	r24, 0x05	; 5
     d14:	0e 94 71 05 	call	0xae2	; 0xae2 <ADC_Conversion>
     d18:	80 93 75 00 	sts	0x0075, r24
// 	//ter
// 	print_sensor(1,9,5);		//Prints value of White Line Sensor Right

	//flag=0;

	if(Center_white_line<THRESHOLDL && Left_white_line<THRESHOLDL && Right_white_line<THRESHOLDL)               // Is middle Whiteline is within threshold limit
     d1c:	90 91 76 00 	lds	r25, 0x0076
     d20:	9a 30       	cpi	r25, 0x0A	; 10
     d22:	68 f4       	brcc	.+26     	; 0xd3e <line_follower+0x50>
     d24:	20 91 77 00 	lds	r18, 0x0077
     d28:	2a 30       	cpi	r18, 0x0A	; 10
     d2a:	48 f4       	brcc	.+18     	; 0xd3e <line_follower+0x50>
     d2c:	8a 30       	cpi	r24, 0x0A	; 10
     d2e:	38 f4       	brcc	.+14     	; 0xd3e <line_follower+0x50>
	{                                             
		//flag=1;                                                                                                  //c0,l0,r0  
		velocity(VELOCITY_MIN,VELOCITY_MIN);      // Run robot at max velocity 
     d30:	84 e1       	ldi	r24, 0x14	; 20
     d32:	64 e1       	ldi	r22, 0x14	; 20
     d34:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
		back();
     d38:	0e 94 8a 05 	call	0xb14	; 0xb14 <back>
     d3c:	e9 c0       	rjmp	.+466    	; 0xf10 <line_follower+0x222>
		
// 		lcd_print (2,1,VELOCITY_MAX,3);
// 		lcd_print (2,5,VELOCITY_MAX,3);
	}
	else if(Center_white_line>THRESHOLDH && Left_white_line<THRESHOLDL && Right_white_line<THRESHOLDL)               // Is middle Whiteline is within threshold limit
     d3e:	97 34       	cpi	r25, 0x47	; 71
     d40:	68 f0       	brcs	.+26     	; 0xd5c <line_follower+0x6e>
     d42:	20 91 77 00 	lds	r18, 0x0077
     d46:	2a 30       	cpi	r18, 0x0A	; 10
     d48:	48 f4       	brcc	.+18     	; 0xd5c <line_follower+0x6e>
     d4a:	8a 30       	cpi	r24, 0x0A	; 10
     d4c:	38 f4       	brcc	.+14     	; 0xd5c <line_follower+0x6e>
	{
		//flag=1;                                                                                                 //c1,l0,r0
		velocity(VELOCITY_MAX,VELOCITY_MAX);      // Run robot at max velocity
     d4e:	8c e3       	ldi	r24, 0x3C	; 60
     d50:	6c e3       	ldi	r22, 0x3C	; 60
     d52:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
		forward();
     d56:	0e 94 86 05 	call	0xb0c	; 0xb0c <forward>
     d5a:	da c0       	rjmp	.+436    	; 0xf10 <line_follower+0x222>
// 		lcd_print (2,5,VELOCITY_MAX,3);
	}


	
	else if(Center_white_line<THRESHOLDL && Left_white_line<THRESHOLDL && Right_white_line>THRESHOLDH)  // Is left Whiteline is not within threshold limit
     d5c:	9a 30       	cpi	r25, 0x0A	; 10
     d5e:	68 f4       	brcc	.+26     	; 0xd7a <line_follower+0x8c>
     d60:	20 91 77 00 	lds	r18, 0x0077
     d64:	2a 30       	cpi	r18, 0x0A	; 10
     d66:	48 f4       	brcc	.+18     	; 0xd7a <line_follower+0x8c>
     d68:	87 34       	cpi	r24, 0x47	; 71
     d6a:	38 f0       	brcs	.+14     	; 0xd7a <line_follower+0x8c>
	{                                             
	    //	flag=1;                                                                                                     //c0,l0,r1
		velocity(VELOCITY_MAX,VELOCITY_MIN);      // Run robot left wheel at max velocity and right wheel 
     d6c:	8c e3       	ldi	r24, 0x3C	; 60
     d6e:	64 e1       	ldi	r22, 0x14	; 20
     d70:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
		right();
     d74:	0e 94 92 05 	call	0xb24	; 0xb24 <right>
     d78:	cb c0       	rjmp	.+406    	; 0xf10 <line_follower+0x222>
// 		lcd_print (2,1,VELOCITY_MAX,3);           // at min velocity
// 		lcd_print (2,5,VELOCITY_MIN,3);
	}
	
	else if(Center_white_line>THRESHOLDH && Left_white_line<THRESHOLDL && Right_white_line>THRESHOLDH)  // Is left Whiteline is not within threshold limit
     d7a:	97 34       	cpi	r25, 0x47	; 71
     d7c:	68 f0       	brcs	.+26     	; 0xd98 <line_follower+0xaa>
     d7e:	20 91 77 00 	lds	r18, 0x0077
     d82:	2a 30       	cpi	r18, 0x0A	; 10
     d84:	48 f4       	brcc	.+18     	; 0xd98 <line_follower+0xaa>
     d86:	87 34       	cpi	r24, 0x47	; 71
     d88:	38 f0       	brcs	.+14     	; 0xd98 <line_follower+0xaa>
	{                                                                                                                  //c1,l0,r1                 
		//	flag=1;
		velocity(VELOCITY_MAX,VELOCITY_MIN);      // Run robot left wheel at max velocity and right wheel
     d8a:	8c e3       	ldi	r24, 0x3C	; 60
     d8c:	64 e1       	ldi	r22, 0x14	; 20
     d8e:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
		S_R();
     d92:	0e 94 9e 05 	call	0xb3c	; 0xb3c <S_R>
     d96:	bc c0       	rjmp	.+376    	; 0xf10 <line_follower+0x222>
// 		lcd_print (2,1,VELOCITY_MAX,3);           // at min velocity
// 		lcd_print (2,5,VELOCITY_MIN,3);
	}

	
	else if(Center_white_line<THRESHOLDL && Left_white_line>THRESHOLDH && Right_white_line<THRESHOLDL ) // Is right Whiteline is not within threshold limit
     d98:	9a 30       	cpi	r25, 0x0A	; 10
     d9a:	68 f4       	brcc	.+26     	; 0xdb6 <line_follower+0xc8>
     d9c:	20 91 77 00 	lds	r18, 0x0077
     da0:	27 34       	cpi	r18, 0x47	; 71
     da2:	48 f0       	brcs	.+18     	; 0xdb6 <line_follower+0xc8>
     da4:	8a 30       	cpi	r24, 0x0A	; 10
     da6:	38 f4       	brcc	.+14     	; 0xdb6 <line_follower+0xc8>
	{
		//flag=1;                                                                                                 //c0,l1,r0
		velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel 
     da8:	84 e1       	ldi	r24, 0x14	; 20
     daa:	6c e3       	ldi	r22, 0x3C	; 60
     dac:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
		s_L();
     db0:	0e 94 9a 05 	call	0xb34	; 0xb34 <s_L>
     db4:	ad c0       	rjmp	.+346    	; 0xf10 <line_follower+0x222>
// 		lcd_print (2,1,VELOCITY_MIN,3);           // at min velocity
// 		lcd_print (2,5,VELOCITY_MAX,3);
	}
	else if(Center_white_line>THRESHOLDH && Left_white_line>THRESHOLDH && Right_white_line<THRESHOLDL ) // Is right Whiteline is not within threshold limit
     db6:	97 34       	cpi	r25, 0x47	; 71
     db8:	08 f4       	brcc	.+2      	; 0xdbc <line_follower+0xce>
     dba:	aa c0       	rjmp	.+340    	; 0xf10 <line_follower+0x222>
     dbc:	90 91 77 00 	lds	r25, 0x0077
     dc0:	97 34       	cpi	r25, 0x47	; 71
     dc2:	08 f4       	brcc	.+2      	; 0xdc6 <line_follower+0xd8>
     dc4:	a5 c0       	rjmp	.+330    	; 0xf10 <line_follower+0x222>
     dc6:	8a 30       	cpi	r24, 0x0A	; 10
     dc8:	08 f0       	brcs	.+2      	; 0xdcc <line_follower+0xde>
     dca:	a7 c0       	rjmp	.+334    	; 0xf1a <line_follower+0x22c>
	{                                                                                                             //c1,l1,r0
		//flag=1; 
		velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel
     dcc:	84 e1       	ldi	r24, 0x14	; 20
     dce:	6c e3       	ldi	r22, 0x3C	; 60
     dd0:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
		left();
     dd4:	0e 94 8e 05 	call	0xb1c	; 0xb1c <left>
     dd8:	9b c0       	rjmp	.+310    	; 0xf10 <line_follower+0x222>
                
	else if(Center_white_line>THRESHOLDH && Left_white_line>THRESHOLDH && Right_white_line>THRESHOLDH)
	                                // if all Whiteline sensor are not within threshold limit                      //c1,l1,r1   
	{                       
		//flag=1;
		buzzer_beep();
     dda:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_beep>
		velocity(VELOCITY_LOW,VELOCITY_LOW);      // stop the robot
     dde:	80 e0       	ldi	r24, 0x00	; 0
     de0:	60 e0       	ldi	r22, 0x00	; 0
     de2:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
		hard_stop();
     de6:	0e 94 96 05 	call	0xb2c	; 0xb2c <hard_stop>
// 		lcd_print (2,1,VELOCITY_LOW,3);
// 		lcd_print (2,5,VELOCITY_LOW,3);
if(stage==2)
     dea:	80 91 65 00 	lds	r24, 0x0065
     dee:	82 30       	cpi	r24, 0x02	; 2
     df0:	21 f4       	brne	.+8      	; 0xdfa <line_follower+0x10c>
{
	servo100();
     df2:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <servo100>
	servo101();
     df6:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <servo101>
	
}

if(stage==3)
     dfa:	80 91 65 00 	lds	r24, 0x0065
     dfe:	83 30       	cpi	r24, 0x03	; 3
     e00:	09 f0       	breq	.+2      	; 0xe04 <line_follower+0x116>
     e02:	82 c0       	rjmp	.+260    	; 0xf08 <line_follower+0x21a>
{	unsigned char count=0;
	unsigned char i;
	if(path1.path[t]==2 )
     e04:	80 91 73 00 	lds	r24, 0x0073
     e08:	e8 ec       	ldi	r30, 0xC8	; 200
     e0a:	f0 e0       	ldi	r31, 0x00	; 0
     e0c:	e8 0f       	add	r30, r24
     e0e:	f1 1d       	adc	r31, r1
     e10:	80 81       	ld	r24, Z
     e12:	82 30       	cpi	r24, 0x02	; 2
     e14:	a9 f4       	brne	.+42     	; 0xe40 <line_follower+0x152>
	{
		init_devices_pos();
     e16:	0e 94 18 04 	call	0x830	; 0x830 <init_devices_pos>
		left_degrees(100);
     e1a:	84 e6       	ldi	r24, 0x64	; 100
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	0e 94 ce 03 	call	0x79c	; 0x79c <left_degrees>
		stop_pos();
     e22:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
     e26:	8f ef       	ldi	r24, 0xFF	; 255
     e28:	9f e3       	ldi	r25, 0x3F	; 63
     e2a:	ab e0       	ldi	r26, 0x0B	; 11
     e2c:	81 50       	subi	r24, 0x01	; 1
     e2e:	90 40       	sbci	r25, 0x00	; 0
     e30:	a0 40       	sbci	r26, 0x00	; 0
     e32:	e1 f7       	brne	.-8      	; 0xe2c <line_follower+0x13e>
     e34:	00 c0       	rjmp	.+0      	; 0xe36 <line_follower+0x148>
     e36:	00 00       	nop
		_delay_ms(500);
		dir=3;
     e38:	83 e0       	ldi	r24, 0x03	; 3
     e3a:	80 93 66 00 	sts	0x0066, r24
     e3e:	16 c0       	rjmp	.+44     	; 0xe6c <line_follower+0x17e>
		
	}
	else if(path1.path[t]==48 )
     e40:	80 33       	cpi	r24, 0x30	; 48
     e42:	a1 f4       	brne	.+40     	; 0xe6c <line_follower+0x17e>
	{
		init_devices_pos();
     e44:	0e 94 18 04 	call	0x830	; 0x830 <init_devices_pos>
		left_degrees(100);
     e48:	84 e6       	ldi	r24, 0x64	; 100
     e4a:	90 e0       	ldi	r25, 0x00	; 0
     e4c:	0e 94 ce 03 	call	0x79c	; 0x79c <left_degrees>
		stop_pos();
     e50:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
     e54:	8f ef       	ldi	r24, 0xFF	; 255
     e56:	9f e3       	ldi	r25, 0x3F	; 63
     e58:	ab e0       	ldi	r26, 0x0B	; 11
     e5a:	81 50       	subi	r24, 0x01	; 1
     e5c:	90 40       	sbci	r25, 0x00	; 0
     e5e:	a0 40       	sbci	r26, 0x00	; 0
     e60:	e1 f7       	brne	.-8      	; 0xe5a <line_follower+0x16c>
     e62:	00 c0       	rjmp	.+0      	; 0xe64 <line_follower+0x176>
     e64:	00 00       	nop
		_delay_ms(500);
		dir=1;
     e66:	81 e0       	ldi	r24, 0x01	; 1
     e68:	80 93 66 00 	sts	0x0066, r24
		
	}
	
	for ( i=0;i<b;i++)
     e6c:	80 91 70 00 	lds	r24, 0x0070
     e70:	88 23       	and	r24, r24
     e72:	09 f4       	brne	.+2      	; 0xe76 <line_follower+0x188>
     e74:	50 c0       	rjmp	.+160    	; 0xf16 <line_follower+0x228>
	{
		
		if(path1.path[t]==blue_nodes[i])
     e76:	80 91 73 00 	lds	r24, 0x0073
     e7a:	e8 ec       	ldi	r30, 0xC8	; 200
     e7c:	f0 e0       	ldi	r31, 0x00	; 0
     e7e:	e8 0f       	add	r30, r24
     e80:	f1 1d       	adc	r31, r1
     e82:	50 81       	ld	r21, Z
     e84:	80 91 8e 00 	lds	r24, 0x008E
     e88:	58 17       	cp	r21, r24
     e8a:	69 f0       	breq	.+26     	; 0xea6 <line_follower+0x1b8>
		_delay_ms(500);
		dir=1;
		
	}
	
	for ( i=0;i<b;i++)
     e8c:	c0 e0       	ldi	r28, 0x00	; 0
	{
		
		if(path1.path[t]==blue_nodes[i])
     e8e:	2e e8       	ldi	r18, 0x8E	; 142
     e90:	30 e0       	ldi	r19, 0x00	; 0
     e92:	1b c0       	rjmp	.+54     	; 0xeca <line_follower+0x1dc>
     e94:	8c 2f       	mov	r24, r28
     e96:	90 e0       	ldi	r25, 0x00	; 0
     e98:	f9 01       	movw	r30, r18
     e9a:	e8 0f       	add	r30, r24
     e9c:	f9 1f       	adc	r31, r25
     e9e:	40 81       	ld	r20, Z
     ea0:	54 17       	cp	r21, r20
     ea2:	99 f4       	brne	.+38     	; 0xeca <line_follower+0x1dc>
     ea4:	03 c0       	rjmp	.+6      	; 0xeac <line_follower+0x1be>
     ea6:	80 e0       	ldi	r24, 0x00	; 0
     ea8:	90 e0       	ldi	r25, 0x00	; 0
		_delay_ms(500);
		dir=1;
		
	}
	
	for ( i=0;i<b;i++)
     eaa:	c0 e0       	ldi	r28, 0x00	; 0
	{
		
		if(path1.path[t]==blue_nodes[i])
		{
			if (path1.path[t]==blue_nodes[i+1])
     eac:	81 57       	subi	r24, 0x71	; 113
     eae:	9f 4f       	sbci	r25, 0xFF	; 255
     eb0:	dc 01       	movw	r26, r24
     eb2:	8c 91       	ld	r24, X
	servo101();
	
}

if(stage==3)
{	unsigned char count=0;
     eb4:	d1 e0       	ldi	r29, 0x01	; 1
     eb6:	58 13       	cpse	r21, r24
     eb8:	d0 e0       	ldi	r29, 0x00	; 0
			}
			count++;
			break;
		}
	}
	if (count>0)
     eba:	df 5f       	subi	r29, 0xFF	; 255
	{buzzer_beep();
     ebc:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_beep>
		buzzer_beep();
     ec0:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_beep>
		
	}
	if(count==1)
     ec4:	d1 30       	cpi	r29, 0x01	; 1
     ec6:	41 f0       	breq	.+16     	; 0xed8 <line_follower+0x1ea>
     ec8:	19 c0       	rjmp	.+50     	; 0xefc <line_follower+0x20e>
		_delay_ms(500);
		dir=1;
		
	}
	
	for ( i=0;i<b;i++)
     eca:	cf 5f       	subi	r28, 0xFF	; 255
     ecc:	80 91 70 00 	lds	r24, 0x0070
     ed0:	c8 17       	cp	r28, r24
     ed2:	00 f3       	brcs	.-64     	; 0xe94 <line_follower+0x1a6>
     ed4:	d0 e0       	ldi	r29, 0x00	; 0
     ed6:	12 c0       	rjmp	.+36     	; 0xefc <line_follower+0x20e>
		buzzer_beep();
		
	}
	if(count==1)
	{
		if(blue_side[i]==100)
     ed8:	d0 e0       	ldi	r29, 0x00	; 0
     eda:	fe 01       	movw	r30, r28
     edc:	e4 55       	subi	r30, 0x54	; 84
     ede:	ff 4f       	sbci	r31, 0xFF	; 255
     ee0:	80 81       	ld	r24, Z
     ee2:	84 36       	cpi	r24, 0x64	; 100
     ee4:	19 f4       	brne	.+6      	; 0xeec <line_follower+0x1fe>
		{
			servo100();
     ee6:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <servo100>
     eea:	0e c0       	rjmp	.+28     	; 0xf08 <line_follower+0x21a>
		}
		else if(blue_side[i]==101)
     eec:	c4 55       	subi	r28, 0x54	; 84
     eee:	df 4f       	sbci	r29, 0xFF	; 255
     ef0:	88 81       	ld	r24, Y
     ef2:	85 36       	cpi	r24, 0x65	; 101
     ef4:	49 f4       	brne	.+18     	; 0xf08 <line_follower+0x21a>
		{
			servo101();
     ef6:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <servo101>
     efa:	06 c0       	rjmp	.+12     	; 0xf08 <line_follower+0x21a>
		}
		
	}
	if(count==2)
     efc:	d2 30       	cpi	r29, 0x02	; 2
     efe:	21 f4       	brne	.+8      	; 0xf08 <line_follower+0x21a>
	{
		servo100();
     f00:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <servo100>
		servo101();
     f04:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <servo101>
	}
	count=0;
}

init_devices();
     f08:	0e 94 6e 06 	call	0xcdc	; 0xcdc <init_devices>
direction();
     f0c:	0e 94 04 0a 	call	0x1408	; 0x1408 <direction>
	}

 
}
     f10:	df 91       	pop	r29
     f12:	cf 91       	pop	r28
     f14:	08 95       	ret
		_delay_ms(500);
		dir=1;
		
	}
	
	for ( i=0;i<b;i++)
     f16:	d0 e0       	ldi	r29, 0x00	; 0
     f18:	f1 cf       	rjmp	.-30     	; 0xefc <line_follower+0x20e>
		left();
// 		lcd_print (2,1,VELOCITY_MIN,3);           // at min velocity
// 		lcd_print (2,5,VELOCITY_MAX,3);
	}
                
	else if(Center_white_line>THRESHOLDH && Left_white_line>THRESHOLDH && Right_white_line>THRESHOLDH)
     f1a:	87 34       	cpi	r24, 0x47	; 71
     f1c:	c8 f3       	brcs	.-14     	; 0xf10 <line_follower+0x222>
     f1e:	5d cf       	rjmp	.-326    	; 0xdda <line_follower+0xec>

00000f20 <color_sensor_pin_config>:
Blue_led pc6
*/

void color_sensor_pin_config(void)
{
	DDRD  = DDRD & 0xBF;  //Set the direction of the PORTD 6 pin as input 1011 1111
     f20:	8e 98       	cbi	0x11, 6	; 17
	PORTD = PORTD | 0x40; //pullup pd6 0100 0000
     f22:	96 9a       	sbi	0x12, 6	; 18
}
     f24:	08 95       	ret

00000f26 <port_init_color>:
void port_init_color(void)
{
	
	color_sensor_pin_config();//color sensor pin configuration
     f26:	0e 94 90 07 	call	0xf20	; 0xf20 <color_sensor_pin_config>
}
     f2a:	08 95       	ret

00000f2c <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
     f2c:	f8 94       	cli
	//EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
	TCCR1A=0;
     f2e:	1f bc       	out	0x2f, r1	; 47
	TCCR1B=0x81;//falling edge,noise cancel, no prescale
     f30:	81 e8       	ldi	r24, 0x81	; 129
     f32:	8e bd       	out	0x2e, r24	; 46
	TIMSK=(1<<TICIE1);//ip capt and  NO overflow interrupt
     f34:	80 e2       	ldi	r24, 0x20	; 32
     f36:	89 bf       	out	0x39, r24	; 57
	//EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
	sei(); // Enables the global interrupt
     f38:	78 94       	sei
}
     f3a:	08 95       	ret

00000f3c <__vector_5>:
ISR(TIMER1_CAPT_vect)
{
     f3c:	1f 92       	push	r1
     f3e:	0f 92       	push	r0
     f40:	0f b6       	in	r0, 0x3f	; 63
     f42:	0f 92       	push	r0
     f44:	11 24       	eor	r1, r1
     f46:	8f 93       	push	r24
     f48:	9f 93       	push	r25
     f4a:	af 93       	push	r26
     f4c:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     f4e:	80 91 6a 00 	lds	r24, 0x006A
     f52:	90 91 6b 00 	lds	r25, 0x006B
     f56:	a0 91 6c 00 	lds	r26, 0x006C
     f5a:	b0 91 6d 00 	lds	r27, 0x006D
     f5e:	01 96       	adiw	r24, 0x01	; 1
     f60:	a1 1d       	adc	r26, r1
     f62:	b1 1d       	adc	r27, r1
     f64:	80 93 6a 00 	sts	0x006A, r24
     f68:	90 93 6b 00 	sts	0x006B, r25
     f6c:	a0 93 6c 00 	sts	0x006C, r26
     f70:	b0 93 6d 00 	sts	0x006D, r27
}
     f74:	bf 91       	pop	r27
     f76:	af 91       	pop	r26
     f78:	9f 91       	pop	r25
     f7a:	8f 91       	pop	r24
     f7c:	0f 90       	pop	r0
     f7e:	0f be       	out	0x3f, r0	; 63
     f80:	0f 90       	pop	r0
     f82:	1f 90       	pop	r1
     f84:	18 95       	reti

00000f86 <init_devices_color>:
void init_devices_color(void)
{
	cli(); //Clears the global interrupt
     f86:	f8 94       	cli
	port_init_color();  //Initializes all the ports
     f88:	0e 94 93 07 	call	0xf26	; 0xf26 <port_init_color>
	color_sensor_pin_interrupt_init();
     f8c:	0e 94 96 07 	call	0xf2c	; 0xf2c <color_sensor_pin_interrupt_init>
	sei();   // Enables the global interrupt
     f90:	78 94       	sei
}
     f92:	08 95       	ret

00000f94 <filter_red>:
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	/*PORTC= PORTC & 0xFE; //set S2 low
	PORTC = PORTC & 0xF7; //set S37F lowpd2*/
	PORTC= PORTC & 0xFB; //set S2 low 1111 1011
     f94:	aa 98       	cbi	0x15, 2	; 21
	PORTC = PORTC & 0x7F; //set S37F lowpd2 0111 1111
     f96:	af 98       	cbi	0x15, 7	; 21
}
     f98:	08 95       	ret

00000f9a <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	
	PORTC = PORTC | 0x04; //set S2 High 0000 0100
     f9a:	aa 9a       	sbi	0x15, 2	; 21
	PORTC = PORTC | 0x80; //set S3 High 1000 0000
     f9c:	af 9a       	sbi	0x15, 7	; 21
}
     f9e:	08 95       	ret

00000fa0 <filter_blue>:
void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	/*PORTD = PORTD & 0xF7; //set S2 low
	PORTD = PORTD | 0x04; //set S3 High*/
	PORTC= PORTC & 0xFB; //set S2 low 1111 1011
     fa0:	aa 98       	cbi	0x15, 2	; 21
	PORTC = PORTC | 0x80; //set S3 High 1000 0000
     fa2:	af 9a       	sbi	0x15, 7	; 21
}
     fa4:	08 95       	ret

00000fa6 <filter_clear>:
void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	/*PORTD = PORTD | 0x08; //set S2 High
	PORTD = PORTD & 0xFB; //set S3 Low*/
	PORTC = PORTC | 0x04;  //set S2 High 0000 0100
     fa6:	aa 9a       	sbi	0x15, 2	; 21
	PORTC = PORTC & 0x7F; //set S3 Low 0111 1111
     fa8:	af 98       	cbi	0x15, 7	; 21
}
     faa:	08 95       	ret

00000fac <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xFE;
	PORTC = PORTC | 0x01; //set S0 high 0000 0001
     fac:	a8 9a       	sbi	0x15, 0	; 21
	PORTC = PORTC & 0xFD; //set S1 low 1111 1101
     fae:	a9 98       	cbi	0x15, 1	; 21
	//PORTD = PORTD | 0x02; //set S1 high 
}
     fb0:	08 95       	ret

00000fb2 <red_read>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
     fb2:	0e 94 ca 07 	call	0xf94	; 0xf94 <filter_red>
	pulse=0; //reset the count to 0
     fb6:	10 92 6a 00 	sts	0x006A, r1
     fba:	10 92 6b 00 	sts	0x006B, r1
     fbe:	10 92 6c 00 	sts	0x006C, r1
     fc2:	10 92 6d 00 	sts	0x006D, r1
     fc6:	8f ef       	ldi	r24, 0xFF	; 255
     fc8:	9f e3       	ldi	r25, 0x3F	; 63
     fca:	a2 e0       	ldi	r26, 0x02	; 2
     fcc:	81 50       	subi	r24, 0x01	; 1
     fce:	90 40       	sbci	r25, 0x00	; 0
     fd0:	a0 40       	sbci	r26, 0x00	; 0
     fd2:	e1 f7       	brne	.-8      	; 0xfcc <red_read+0x1a>
     fd4:	00 c0       	rjmp	.+0      	; 0xfd6 <red_read+0x24>
     fd6:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
     fd8:	80 91 6a 00 	lds	r24, 0x006A
     fdc:	90 91 6b 00 	lds	r25, 0x006B
     fe0:	a0 91 6c 00 	lds	r26, 0x006C
     fe4:	b0 91 6d 00 	lds	r27, 0x006D
     fe8:	80 93 c4 00 	sts	0x00C4, r24
     fec:	90 93 c5 00 	sts	0x00C5, r25
     ff0:	a0 93 c6 00 	sts	0x00C6, r26
     ff4:	b0 93 c7 00 	sts	0x00C7, r27
	lcd_string("Red Pulses"); // Display "Red Pulses" on LCD
	lcd_print(2,1,red,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD
	*/
}
     ff8:	08 95       	ret

00000ffa <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
     ffa:	0e 94 cd 07 	call	0xf9a	; 0xf9a <filter_green>
	pulse=0; //reset the count to 0
     ffe:	10 92 6a 00 	sts	0x006A, r1
    1002:	10 92 6b 00 	sts	0x006B, r1
    1006:	10 92 6c 00 	sts	0x006C, r1
    100a:	10 92 6d 00 	sts	0x006D, r1
    100e:	8f ef       	ldi	r24, 0xFF	; 255
    1010:	9f e3       	ldi	r25, 0x3F	; 63
    1012:	a2 e0       	ldi	r26, 0x02	; 2
    1014:	81 50       	subi	r24, 0x01	; 1
    1016:	90 40       	sbci	r25, 0x00	; 0
    1018:	a0 40       	sbci	r26, 0x00	; 0
    101a:	e1 f7       	brne	.-8      	; 0x1014 <green_read+0x1a>
    101c:	00 c0       	rjmp	.+0      	; 0x101e <green_read+0x24>
    101e:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
    1020:	80 91 6a 00 	lds	r24, 0x006A
    1024:	90 91 6b 00 	lds	r25, 0x006B
    1028:	a0 91 6c 00 	lds	r26, 0x006C
    102c:	b0 91 6d 00 	lds	r27, 0x006D
    1030:	80 93 c0 00 	sts	0x00C0, r24
    1034:	90 93 c1 00 	sts	0x00C1, r25
    1038:	a0 93 c2 00 	sts	0x00C2, r26
    103c:	b0 93 c3 00 	sts	0x00C3, r27
	lcd_string("Green Pulses"); // Display "Green Pulses" on LCD
	lcd_print(2,1,green,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD

*/}
    1040:	08 95       	ret

00001042 <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
    1042:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <filter_blue>
	pulse=0; //reset the count to 0
    1046:	10 92 6a 00 	sts	0x006A, r1
    104a:	10 92 6b 00 	sts	0x006B, r1
    104e:	10 92 6c 00 	sts	0x006C, r1
    1052:	10 92 6d 00 	sts	0x006D, r1
    1056:	8f ef       	ldi	r24, 0xFF	; 255
    1058:	9f e3       	ldi	r25, 0x3F	; 63
    105a:	a2 e0       	ldi	r26, 0x02	; 2
    105c:	81 50       	subi	r24, 0x01	; 1
    105e:	90 40       	sbci	r25, 0x00	; 0
    1060:	a0 40       	sbci	r26, 0x00	; 0
    1062:	e1 f7       	brne	.-8      	; 0x105c <blue_read+0x1a>
    1064:	00 c0       	rjmp	.+0      	; 0x1066 <blue_read+0x24>
    1066:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
    1068:	80 91 6a 00 	lds	r24, 0x006A
    106c:	90 91 6b 00 	lds	r25, 0x006B
    1070:	a0 91 6c 00 	lds	r26, 0x006C
    1074:	b0 91 6d 00 	lds	r27, 0x006D
    1078:	80 93 9a 00 	sts	0x009A, r24
    107c:	90 93 9b 00 	sts	0x009B, r25
    1080:	a0 93 9c 00 	sts	0x009C, r26
    1084:	b0 93 9d 00 	sts	0x009D, r27
	lcd_string("Blue Pulses"); // Display "Blue Pulses" on LCD
	lcd_print(2,1,blue,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD
	*/
}
    1088:	08 95       	ret

0000108a <colour>:
void colour(unsigned long int red_pulse, unsigned long int green_pulse,unsigned long int blue_pulse)
{	
    108a:	8f 92       	push	r8
    108c:	9f 92       	push	r9
    108e:	af 92       	push	r10
    1090:	bf 92       	push	r11
    1092:	ef 92       	push	r14
    1094:	ff 92       	push	r15
    1096:	0f 93       	push	r16
    1098:	1f 93       	push	r17
    109a:	4b 01       	movw	r8, r22
    109c:	5c 01       	movw	r10, r24
    109e:	da 01       	movw	r26, r20
    10a0:	c9 01       	movw	r24, r18
    10a2:	b8 01       	movw	r22, r16
    10a4:	a7 01       	movw	r20, r14
	if(red_pulse>green_pulse && red_pulse>blue_pulse)
    10a6:	88 15       	cp	r24, r8
    10a8:	99 05       	cpc	r25, r9
    10aa:	aa 05       	cpc	r26, r10
    10ac:	bb 05       	cpc	r27, r11
    10ae:	68 f4       	brcc	.+26     	; 0x10ca <colour+0x40>
    10b0:	e8 14       	cp	r14, r8
    10b2:	f9 04       	cpc	r15, r9
    10b4:	0a 05       	cpc	r16, r10
    10b6:	1b 05       	cpc	r17, r11
    10b8:	40 f4       	brcc	.+16     	; 0x10ca <colour+0x40>
	{
		//red greatest
		PORTC=PORTC|(1<<PC4);
    10ba:	ac 9a       	sbi	0x15, 4	; 21
		PORTC=PORTC & 0x9F; //clear pc5 and pc6 1001 1111
    10bc:	85 b3       	in	r24, 0x15	; 21
    10be:	8f 79       	andi	r24, 0x9F	; 159
    10c0:	85 bb       	out	0x15, r24	; 21
		task=1;
    10c2:	81 e0       	ldi	r24, 0x01	; 1
    10c4:	80 93 72 00 	sts	0x0072, r24
    10c8:	14 c0       	rjmp	.+40     	; 0x10f2 <colour+0x68>
	}
	else if(green_pulse>blue_pulse)
    10ca:	48 17       	cp	r20, r24
    10cc:	59 07       	cpc	r21, r25
    10ce:	6a 07       	cpc	r22, r26
    10d0:	7b 07       	cpc	r23, r27
    10d2:	40 f4       	brcc	.+16     	; 0x10e4 <colour+0x5a>
	{
		//green greatest
		PORTC=PORTC|(1<<PC5);
    10d4:	ad 9a       	sbi	0x15, 5	; 21
		PORTC=PORTC & 0xAF; //clear pc4 and pc6 1010 1111
    10d6:	85 b3       	in	r24, 0x15	; 21
    10d8:	8f 7a       	andi	r24, 0xAF	; 175
    10da:	85 bb       	out	0x15, r24	; 21
		task=2;
    10dc:	82 e0       	ldi	r24, 0x02	; 2
    10de:	80 93 72 00 	sts	0x0072, r24
    10e2:	07 c0       	rjmp	.+14     	; 0x10f2 <colour+0x68>
		
	}
	else
	{
		//blue greatest
		PORTC=PORTC|(1<<PC6);
    10e4:	ae 9a       	sbi	0x15, 6	; 21
		PORTC=PORTC & 0xCF; //clear pc5 and pc4 1100 1111
    10e6:	85 b3       	in	r24, 0x15	; 21
    10e8:	8f 7c       	andi	r24, 0xCF	; 207
    10ea:	85 bb       	out	0x15, r24	; 21
		task=3;
    10ec:	83 e0       	ldi	r24, 0x03	; 3
    10ee:	80 93 72 00 	sts	0x0072, r24
	}
}
    10f2:	1f 91       	pop	r17
    10f4:	0f 91       	pop	r16
    10f6:	ff 90       	pop	r15
    10f8:	ef 90       	pop	r14
    10fa:	bf 90       	pop	r11
    10fc:	af 90       	pop	r10
    10fe:	9f 90       	pop	r9
    1100:	8f 90       	pop	r8
    1102:	08 95       	ret

00001104 <color_sensor_work>:


void color_sensor_work()
{	
    1104:	ef 92       	push	r14
    1106:	ff 92       	push	r15
    1108:	0f 93       	push	r16
    110a:	1f 93       	push	r17
    110c:	cf 93       	push	r28
    110e:	df 93       	push	r29
	
	init_devices_color();
    1110:	0e 94 c3 07 	call	0xf86	; 0xf86 <init_devices_color>
	DDRC = DDRC | 0xFF;//port c pins as output 
    1114:	84 b3       	in	r24, 0x14	; 20
    1116:	8f ef       	ldi	r24, 0xFF	; 255
    1118:	84 bb       	out	0x14, r24	; 20
	PORTC=0x00;
    111a:	15 ba       	out	0x15, r1	; 21
	color_sensor_scaling();
    111c:	0e 94 d6 07 	call	0xfac	; 0xfac <color_sensor_scaling>
	if(stage==2)
    1120:	80 91 65 00 	lds	r24, 0x0065
    1124:	82 30       	cpi	r24, 0x02	; 2
    1126:	71 f5       	brne	.+92     	; 0x1184 <color_sensor_work+0x80>
    1128:	c5 e0       	ldi	r28, 0x05	; 5
    112a:	d0 e0       	ldi	r29, 0x00	; 0
	{
		for (int i=0;i<5;i++)
		{
			red_read(); //display the pulse count when red filter is selected
    112c:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <red_read>
			//_delay_ms(500);
			green_read(); //display the pulse count when green filter is selected
    1130:	0e 94 fd 07 	call	0xffa	; 0xffa <green_read>
			//_delay_ms(500);
			blue_read(); //display the pulse count when blue filter is selected
    1134:	0e 94 21 08 	call	0x1042	; 0x1042 <blue_read>
			//_delay_ms(500);
			colour(red,green,blue);
    1138:	60 91 c4 00 	lds	r22, 0x00C4
    113c:	70 91 c5 00 	lds	r23, 0x00C5
    1140:	80 91 c6 00 	lds	r24, 0x00C6
    1144:	90 91 c7 00 	lds	r25, 0x00C7
    1148:	20 91 c0 00 	lds	r18, 0x00C0
    114c:	30 91 c1 00 	lds	r19, 0x00C1
    1150:	40 91 c2 00 	lds	r20, 0x00C2
    1154:	50 91 c3 00 	lds	r21, 0x00C3
    1158:	e0 90 9a 00 	lds	r14, 0x009A
    115c:	f0 90 9b 00 	lds	r15, 0x009B
    1160:	00 91 9c 00 	lds	r16, 0x009C
    1164:	10 91 9d 00 	lds	r17, 0x009D
    1168:	0e 94 45 08 	call	0x108a	; 0x108a <colour>
    116c:	8f ef       	ldi	r24, 0xFF	; 255
    116e:	9f e3       	ldi	r25, 0x3F	; 63
    1170:	ab e0       	ldi	r26, 0x0B	; 11
    1172:	81 50       	subi	r24, 0x01	; 1
    1174:	90 40       	sbci	r25, 0x00	; 0
    1176:	a0 40       	sbci	r26, 0x00	; 0
    1178:	e1 f7       	brne	.-8      	; 0x1172 <color_sensor_work+0x6e>
    117a:	00 c0       	rjmp	.+0      	; 0x117c <color_sensor_work+0x78>
    117c:	00 00       	nop
    117e:	21 97       	sbiw	r28, 0x01	; 1
	DDRC = DDRC | 0xFF;//port c pins as output 
	PORTC=0x00;
	color_sensor_scaling();
	if(stage==2)
	{
		for (int i=0;i<5;i++)
    1180:	a9 f6       	brne	.-86     	; 0x112c <color_sensor_work+0x28>
    1182:	10 c0       	rjmp	.+32     	; 0x11a4 <color_sensor_work+0xa0>
		}
		
	}
	else
	{	//blue
		PORTC=PORTC|(1<<PC6);
    1184:	ae 9a       	sbi	0x15, 6	; 21
		PORTC=PORTC & 0xCF; //clear pc5 and pc4 1100 1111
    1186:	85 b3       	in	r24, 0x15	; 21
    1188:	8f 7c       	andi	r24, 0xCF	; 207
    118a:	85 bb       	out	0x15, r24	; 21
		task=3;
    118c:	83 e0       	ldi	r24, 0x03	; 3
    118e:	80 93 72 00 	sts	0x0072, r24
    1192:	8f ef       	ldi	r24, 0xFF	; 255
    1194:	9f e3       	ldi	r25, 0x3F	; 63
    1196:	ab e0       	ldi	r26, 0x0B	; 11
    1198:	81 50       	subi	r24, 0x01	; 1
    119a:	90 40       	sbci	r25, 0x00	; 0
    119c:	a0 40       	sbci	r26, 0x00	; 0
    119e:	e1 f7       	brne	.-8      	; 0x1198 <color_sensor_work+0x94>
    11a0:	00 c0       	rjmp	.+0      	; 0x11a2 <color_sensor_work+0x9e>
    11a2:	00 00       	nop
		_delay_ms(500);
	}	
	
    11a4:	df 91       	pop	r29
    11a6:	cf 91       	pop	r28
    11a8:	1f 91       	pop	r17
    11aa:	0f 91       	pop	r16
    11ac:	ff 90       	pop	r15
    11ae:	ef 90       	pop	r14
    11b0:	08 95       	ret

000011b2 <buzzer_pin_config_zigbee>:
}
*/

void buzzer_pin_config_zigbee (void)
{
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as outpt
    11b2:	a3 9a       	sbi	0x14, 3	; 20
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
    11b4:	ab 98       	cbi	0x15, 3	; 21
}
    11b6:	08 95       	ret

000011b8 <port_init_zigbee>:

//Function to initialize ports
void port_init_zigbee()
{
 //motion_pin_config();
 buzzer_pin_config_zigbee();
    11b8:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <buzzer_pin_config_zigbee>
}
    11bc:	08 95       	ret

000011be <uart0_init_zigbee>:
// actual: baud rate:9600 (0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init_zigbee(void)
{
 UCSRB = 0x00; //disable while setting baud rate
    11be:	1a b8       	out	0x0a, r1	; 10
 UCSRA = 0x00;
    11c0:	1b b8       	out	0x0b, r1	; 11
 UCSRC = 0x86;
    11c2:	86 e8       	ldi	r24, 0x86	; 134
    11c4:	80 bd       	out	0x20, r24	; 32
 UBRRL = 0x2F; //set baud rate lo  //67 is for 16MHz 9600 baudrate
    11c6:	8f e2       	ldi	r24, 0x2F	; 47
    11c8:	89 b9       	out	0x09, r24	; 9
 UBRRH = 0x00; //set baud rate hi
    11ca:	10 bc       	out	0x20, r1	; 32
 UCSRB = 0x98; 
    11cc:	88 e9       	ldi	r24, 0x98	; 152
    11ce:	8a b9       	out	0x0a, r24	; 10
}
    11d0:	08 95       	ret

000011d2 <conversion>:
unsigned char conversion(unsigned char hex)
{	unsigned char node;	
	
	switch(hex)
    11d2:	8b 31       	cpi	r24, 0x1B	; 27
    11d4:	e9 f1       	breq	.+122    	; 0x1250 <conversion+0x7e>
    11d6:	8c 31       	cpi	r24, 0x1C	; 28
    11d8:	90 f4       	brcc	.+36     	; 0x11fe <conversion+0x2c>
    11da:	8d 30       	cpi	r24, 0x0D	; 13
    11dc:	e9 f1       	breq	.+122    	; 0x1258 <conversion+0x86>
    11de:	8e 30       	cpi	r24, 0x0E	; 14
    11e0:	38 f4       	brcc	.+14     	; 0x11f0 <conversion+0x1e>
    11e2:	86 30       	cpi	r24, 0x06	; 6
    11e4:	d9 f1       	breq	.+118    	; 0x125c <conversion+0x8a>
    11e6:	89 30       	cpi	r24, 0x09	; 9
    11e8:	09 f1       	breq	.+66     	; 0x122c <conversion+0x5a>
    11ea:	82 30       	cpi	r24, 0x02	; 2
    11ec:	f1 f5       	brne	.+124    	; 0x126a <conversion+0x98>
    11ee:	3c c0       	rjmp	.+120    	; 0x1268 <conversion+0x96>
    11f0:	84 31       	cpi	r24, 0x14	; 20
    11f2:	81 f1       	breq	.+96     	; 0x1254 <conversion+0x82>
    11f4:	87 31       	cpi	r24, 0x17	; 23
    11f6:	f1 f0       	breq	.+60     	; 0x1234 <conversion+0x62>
    11f8:	80 31       	cpi	r24, 0x10	; 16
    11fa:	b9 f5       	brne	.+110    	; 0x126a <conversion+0x98>
    11fc:	19 c0       	rjmp	.+50     	; 0x1230 <conversion+0x5e>
    11fe:	89 32       	cpi	r24, 0x29	; 41
    1200:	19 f1       	breq	.+70     	; 0x1248 <conversion+0x76>
    1202:	8a 32       	cpi	r24, 0x2A	; 42
    1204:	38 f4       	brcc	.+14     	; 0x1214 <conversion+0x42>
    1206:	82 32       	cpi	r24, 0x22	; 34
    1208:	09 f1       	breq	.+66     	; 0x124c <conversion+0x7a>
    120a:	85 32       	cpi	r24, 0x25	; 37
    120c:	b9 f0       	breq	.+46     	; 0x123c <conversion+0x6a>
    120e:	8e 31       	cpi	r24, 0x1E	; 30
    1210:	61 f5       	brne	.+88     	; 0x126a <conversion+0x98>
    1212:	12 c0       	rjmp	.+36     	; 0x1238 <conversion+0x66>
    1214:	80 33       	cpi	r24, 0x30	; 48
    1216:	b1 f0       	breq	.+44     	; 0x1244 <conversion+0x72>
    1218:	81 33       	cpi	r24, 0x31	; 49
    121a:	18 f4       	brcc	.+6      	; 0x1222 <conversion+0x50>
    121c:	8c 32       	cpi	r24, 0x2C	; 44
    121e:	29 f5       	brne	.+74     	; 0x126a <conversion+0x98>
    1220:	0f c0       	rjmp	.+30     	; 0x1240 <conversion+0x6e>
    1222:	84 36       	cpi	r24, 0x64	; 100
    1224:	e9 f0       	breq	.+58     	; 0x1260 <conversion+0x8e>
    1226:	85 36       	cpi	r24, 0x65	; 101
    1228:	01 f5       	brne	.+64     	; 0x126a <conversion+0x98>
    122a:	1c c0       	rjmp	.+56     	; 0x1264 <conversion+0x92>
	{
		case 0x02:
		node=2;
		break;
		case 0x09:
		node=9;
    122c:	99 e0       	ldi	r25, 0x09	; 9
		break;
    122e:	1d c0       	rjmp	.+58     	; 0x126a <conversion+0x98>
		case 0x10:
		node=16;
    1230:	90 e1       	ldi	r25, 0x10	; 16
		break;
    1232:	1b c0       	rjmp	.+54     	; 0x126a <conversion+0x98>
		case 0x17:
		node=23;
    1234:	97 e1       	ldi	r25, 0x17	; 23
		break;
    1236:	19 c0       	rjmp	.+50     	; 0x126a <conversion+0x98>
		case 0x1E:
		node=30;
    1238:	9e e1       	ldi	r25, 0x1E	; 30
		break;
    123a:	17 c0       	rjmp	.+46     	; 0x126a <conversion+0x98>
		case 0x25:
		node=37;
    123c:	95 e2       	ldi	r25, 0x25	; 37
		break;
    123e:	15 c0       	rjmp	.+42     	; 0x126a <conversion+0x98>
		case 0x2C:
		node=44;
    1240:	9c e2       	ldi	r25, 0x2C	; 44
		break;
    1242:	13 c0       	rjmp	.+38     	; 0x126a <conversion+0x98>
		
		case 0x30:
		node=48;
    1244:	90 e3       	ldi	r25, 0x30	; 48
		break;
    1246:	11 c0       	rjmp	.+34     	; 0x126a <conversion+0x98>
		case 0x29:
		node=41;
    1248:	99 e2       	ldi	r25, 0x29	; 41
		break;
    124a:	0f c0       	rjmp	.+30     	; 0x126a <conversion+0x98>
		case 0x22:
		node=34;
    124c:	92 e2       	ldi	r25, 0x22	; 34
		break;
    124e:	0d c0       	rjmp	.+26     	; 0x126a <conversion+0x98>
		case 0x1B:
		node=27;
    1250:	9b e1       	ldi	r25, 0x1B	; 27
		break;
    1252:	0b c0       	rjmp	.+22     	; 0x126a <conversion+0x98>
		case 0x14:
		node=20;
    1254:	94 e1       	ldi	r25, 0x14	; 20
		break;
    1256:	09 c0       	rjmp	.+18     	; 0x126a <conversion+0x98>
		case 0x0D:
		node=13;
    1258:	9d e0       	ldi	r25, 0x0D	; 13
		break;
    125a:	07 c0       	rjmp	.+14     	; 0x126a <conversion+0x98>
		case 0x06:
		node=6;
    125c:	96 e0       	ldi	r25, 0x06	; 6
		break;
    125e:	05 c0       	rjmp	.+10     	; 0x126a <conversion+0x98>
		
		case 0x64:
		node=100;
    1260:	94 e6       	ldi	r25, 0x64	; 100
		break;
    1262:	03 c0       	rjmp	.+6      	; 0x126a <conversion+0x98>
		case 0x65:
		node=101;
    1264:	95 e6       	ldi	r25, 0x65	; 101
		break;
    1266:	01 c0       	rjmp	.+2      	; 0x126a <conversion+0x98>
{	unsigned char node;	
	
	switch(hex)
	{
		case 0x02:
		node=2;
    1268:	92 e0       	ldi	r25, 0x02	; 2
		break;
			
	}
	
	return node;
}
    126a:	89 2f       	mov	r24, r25
    126c:	08 95       	ret

0000126e <buzzer_on_zigbee>:
}*/

void buzzer_on_zigbee (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
    126e:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore | 0x08;
    1270:	88 60       	ori	r24, 0x08	; 8
 PORTC = port_restore;
    1272:	85 bb       	out	0x15, r24	; 21
}
    1274:	08 95       	ret

00001276 <buzzer_off_zigbee>:

void buzzer_off_zigbee (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
    1276:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore & 0xF7;
    1278:	87 7f       	andi	r24, 0xF7	; 247
 PORTC = port_restore;
    127a:	85 bb       	out	0x15, r24	; 21
}
    127c:	08 95       	ret

0000127e <init_devices_zigbee>:

void init_devices_zigbee (void)
{
 cli();         //Clears the global interrupts
    127e:	f8 94       	cli
 port_init_zigbee();
    1280:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <port_init_zigbee>
 uart0_init_zigbee();
    1284:	0e 94 df 08 	call	0x11be	; 0x11be <uart0_init_zigbee>
 sei();         //Enables the global interrupts
    1288:	78 94       	sei
}
    128a:	08 95       	ret

0000128c <__vector_11>:

SIGNAL(SIG_UART_RECV) 
{	//init_devices_buzzer();
    128c:	1f 92       	push	r1
    128e:	0f 92       	push	r0
    1290:	0f b6       	in	r0, 0x3f	; 63
    1292:	0f 92       	push	r0
    1294:	11 24       	eor	r1, r1
    1296:	0f 93       	push	r16
    1298:	1f 93       	push	r17
    129a:	2f 93       	push	r18
    129c:	3f 93       	push	r19
    129e:	4f 93       	push	r20
    12a0:	5f 93       	push	r21
    12a2:	6f 93       	push	r22
    12a4:	7f 93       	push	r23
    12a6:	8f 93       	push	r24
    12a8:	9f 93       	push	r25
    12aa:	af 93       	push	r26
    12ac:	bf 93       	push	r27
    12ae:	cf 93       	push	r28
    12b0:	ef 93       	push	r30
    12b2:	ff 93       	push	r31
	
	          
 unsigned char k;
 k=UDR;         // Echo the received data plus 1
    12b4:	cc b1       	in	r28, 0x0c	; 12
if(k==0x35)//53
    12b6:	c5 33       	cpi	r28, 0x35	; 53
    12b8:	d1 f4       	brne	.+52     	; 0x12ee <__vector_11+0x62>
{
	mark=1;
    12ba:	81 e0       	ldi	r24, 0x01	; 1
    12bc:	80 93 60 00 	sts	0x0060, r24
	buzzer_on();
    12c0:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    12c4:	8f ef       	ldi	r24, 0xFF	; 255
    12c6:	9f eb       	ldi	r25, 0xBF	; 191
    12c8:	a6 e0       	ldi	r26, 0x06	; 6
    12ca:	81 50       	subi	r24, 0x01	; 1
    12cc:	90 40       	sbci	r25, 0x00	; 0
    12ce:	a0 40       	sbci	r26, 0x00	; 0
    12d0:	e1 f7       	brne	.-8      	; 0x12ca <__vector_11+0x3e>
    12d2:	00 c0       	rjmp	.+0      	; 0x12d4 <__vector_11+0x48>
    12d4:	00 00       	nop
	_delay_ms(300);
	buzzer_off();
    12d6:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    12da:	8f ef       	ldi	r24, 0xFF	; 255
    12dc:	9f eb       	ldi	r25, 0xBF	; 191
    12de:	a6 e0       	ldi	r26, 0x06	; 6
    12e0:	81 50       	subi	r24, 0x01	; 1
    12e2:	90 40       	sbci	r25, 0x00	; 0
    12e4:	a0 40       	sbci	r26, 0x00	; 0
    12e6:	e1 f7       	brne	.-8      	; 0x12e0 <__vector_11+0x54>
    12e8:	00 c0       	rjmp	.+0      	; 0x12ea <__vector_11+0x5e>
    12ea:	00 00       	nop
    12ec:	1f c0       	rjmp	.+62     	; 0x132c <__vector_11+0xa0>
	_delay_ms(300);
}
if (k==0x36)//54
    12ee:	c6 33       	cpi	r28, 0x36	; 54
    12f0:	e9 f4       	brne	.+58     	; 0x132c <__vector_11+0xa0>
{
	mark=0;
    12f2:	10 92 60 00 	sts	0x0060, r1
	next++;
    12f6:	80 91 6e 00 	lds	r24, 0x006E
    12fa:	8f 5f       	subi	r24, 0xFF	; 255
    12fc:	80 93 6e 00 	sts	0x006E, r24
	buzzer_on();
    1300:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1304:	8f ef       	ldi	r24, 0xFF	; 255
    1306:	9f eb       	ldi	r25, 0xBF	; 191
    1308:	a6 e0       	ldi	r26, 0x06	; 6
    130a:	81 50       	subi	r24, 0x01	; 1
    130c:	90 40       	sbci	r25, 0x00	; 0
    130e:	a0 40       	sbci	r26, 0x00	; 0
    1310:	e1 f7       	brne	.-8      	; 0x130a <__vector_11+0x7e>
    1312:	00 c0       	rjmp	.+0      	; 0x1314 <__vector_11+0x88>
    1314:	00 00       	nop
	_delay_ms(300);
	buzzer_off();
    1316:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    131a:	8f ef       	ldi	r24, 0xFF	; 255
    131c:	9f eb       	ldi	r25, 0xBF	; 191
    131e:	a6 e0       	ldi	r26, 0x06	; 6
    1320:	81 50       	subi	r24, 0x01	; 1
    1322:	90 40       	sbci	r25, 0x00	; 0
    1324:	a0 40       	sbci	r26, 0x00	; 0
    1326:	e1 f7       	brne	.-8      	; 0x1320 <__vector_11+0x94>
    1328:	00 c0       	rjmp	.+0      	; 0x132a <__vector_11+0x9e>
    132a:	00 00       	nop
	_delay_ms(300);
}

	if (mark==1)
    132c:	80 91 60 00 	lds	r24, 0x0060
    1330:	81 30       	cpi	r24, 0x01	; 1
    1332:	09 f0       	breq	.+2      	; 0x1336 <__vector_11+0xaa>
    1334:	53 c0       	rjmp	.+166    	; 0x13dc <__vector_11+0x150>
	{
		if(k>0x00 && k<0x31)//0-49
    1336:	8c 2f       	mov	r24, r28
    1338:	81 50       	subi	r24, 0x01	; 1
    133a:	80 33       	cpi	r24, 0x30	; 48
    133c:	30 f5       	brcc	.+76     	; 0x138a <__vector_11+0xfe>
		{
			blue_nodes[b]=conversion(k);
    133e:	00 91 70 00 	lds	r16, 0x0070
    1342:	10 e0       	ldi	r17, 0x00	; 0
    1344:	8c 2f       	mov	r24, r28
    1346:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <conversion>
    134a:	f8 01       	movw	r30, r16
    134c:	e2 57       	subi	r30, 0x72	; 114
    134e:	ff 4f       	sbci	r31, 0xFF	; 255
    1350:	80 83       	st	Z, r24
			
			b++;
    1352:	80 91 70 00 	lds	r24, 0x0070
    1356:	8f 5f       	subi	r24, 0xFF	; 255
    1358:	80 93 70 00 	sts	0x0070, r24
			buzzer_on();
    135c:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1360:	8f ef       	ldi	r24, 0xFF	; 255
    1362:	9f eb       	ldi	r25, 0xBF	; 191
    1364:	a6 e0       	ldi	r26, 0x06	; 6
    1366:	81 50       	subi	r24, 0x01	; 1
    1368:	90 40       	sbci	r25, 0x00	; 0
    136a:	a0 40       	sbci	r26, 0x00	; 0
    136c:	e1 f7       	brne	.-8      	; 0x1366 <__vector_11+0xda>
    136e:	00 c0       	rjmp	.+0      	; 0x1370 <__vector_11+0xe4>
    1370:	00 00       	nop
			_delay_ms(300);
			buzzer_off();
    1372:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    1376:	8f ef       	ldi	r24, 0xFF	; 255
    1378:	9f eb       	ldi	r25, 0xBF	; 191
    137a:	a6 e0       	ldi	r26, 0x06	; 6
    137c:	81 50       	subi	r24, 0x01	; 1
    137e:	90 40       	sbci	r25, 0x00	; 0
    1380:	a0 40       	sbci	r26, 0x00	; 0
    1382:	e1 f7       	brne	.-8      	; 0x137c <__vector_11+0xf0>
    1384:	00 c0       	rjmp	.+0      	; 0x1386 <__vector_11+0xfa>
    1386:	00 00       	nop
    1388:	29 c0       	rjmp	.+82     	; 0x13dc <__vector_11+0x150>
			_delay_ms(300);
			
		}
		else if(k==0x64 || k==0x65)//100-101
    138a:	8c 2f       	mov	r24, r28
    138c:	84 56       	subi	r24, 0x64	; 100
    138e:	82 30       	cpi	r24, 0x02	; 2
    1390:	28 f5       	brcc	.+74     	; 0x13dc <__vector_11+0x150>
		{
			blue_side[bs]=conversion(k);
    1392:	00 91 6f 00 	lds	r16, 0x006F
    1396:	10 e0       	ldi	r17, 0x00	; 0
    1398:	8c 2f       	mov	r24, r28
    139a:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <conversion>
    139e:	f8 01       	movw	r30, r16
    13a0:	e4 55       	subi	r30, 0x54	; 84
    13a2:	ff 4f       	sbci	r31, 0xFF	; 255
    13a4:	80 83       	st	Z, r24
			bs++;
    13a6:	80 91 6f 00 	lds	r24, 0x006F
    13aa:	8f 5f       	subi	r24, 0xFF	; 255
    13ac:	80 93 6f 00 	sts	0x006F, r24
			buzzer_on();
    13b0:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    13b4:	8f ef       	ldi	r24, 0xFF	; 255
    13b6:	9f eb       	ldi	r25, 0xBF	; 191
    13b8:	a6 e0       	ldi	r26, 0x06	; 6
    13ba:	81 50       	subi	r24, 0x01	; 1
    13bc:	90 40       	sbci	r25, 0x00	; 0
    13be:	a0 40       	sbci	r26, 0x00	; 0
    13c0:	e1 f7       	brne	.-8      	; 0x13ba <__vector_11+0x12e>
    13c2:	00 c0       	rjmp	.+0      	; 0x13c4 <__vector_11+0x138>
    13c4:	00 00       	nop
			_delay_ms(300);
			buzzer_off();
    13c6:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    13ca:	8f ef       	ldi	r24, 0xFF	; 255
    13cc:	9f eb       	ldi	r25, 0xBF	; 191
    13ce:	a6 e0       	ldi	r26, 0x06	; 6
    13d0:	81 50       	subi	r24, 0x01	; 1
    13d2:	90 40       	sbci	r25, 0x00	; 0
    13d4:	a0 40       	sbci	r26, 0x00	; 0
    13d6:	e1 f7       	brne	.-8      	; 0x13d0 <__vector_11+0x144>
    13d8:	00 c0       	rjmp	.+0      	; 0x13da <__vector_11+0x14e>
    13da:	00 00       	nop
			_delay_ms(300);
		}
	}		
 
}
    13dc:	ff 91       	pop	r31
    13de:	ef 91       	pop	r30
    13e0:	cf 91       	pop	r28
    13e2:	bf 91       	pop	r27
    13e4:	af 91       	pop	r26
    13e6:	9f 91       	pop	r25
    13e8:	8f 91       	pop	r24
    13ea:	7f 91       	pop	r23
    13ec:	6f 91       	pop	r22
    13ee:	5f 91       	pop	r21
    13f0:	4f 91       	pop	r20
    13f2:	3f 91       	pop	r19
    13f4:	2f 91       	pop	r18
    13f6:	1f 91       	pop	r17
    13f8:	0f 91       	pop	r16
    13fa:	0f 90       	pop	r0
    13fc:	0f be       	out	0x3f, r0	; 63
    13fe:	0f 90       	pop	r0
    1400:	1f 90       	pop	r1
    1402:	18 95       	reti

00001404 <USARTWriteChar>:
		//Do nothing
	*/

	//Now write the data to USART buffer
  
	UDR=data;
    1404:	8c b9       	out	0x0c, r24	; 12
		
	
}
    1406:	08 95       	ret

00001408 <direction>:
	PORTC=PORTC& 0x8F;//1000 1111
	//buzzer_beep();
}

void direction(void)
{	init_devices_buzzer();
    1408:	0f 93       	push	r16
    140a:	1f 93       	push	r17
    140c:	cf 93       	push	r28
    140e:	df 93       	push	r29
    1410:	0e 94 db 00 	call	0x1b6	; 0x1b6 <init_devices_buzzer>
	int w=0;
	if(t==max)
    1414:	90 91 73 00 	lds	r25, 0x0073
    1418:	80 91 80 00 	lds	r24, 0x0080
    141c:	98 17       	cp	r25, r24
    141e:	09 f0       	breq	.+2      	; 0x1422 <direction+0x1a>
    1420:	51 c1       	rjmp	.+674    	; 0x16c4 <direction+0x2bc>
	{	if(stage==1)
    1422:	80 91 65 00 	lds	r24, 0x0065
    1426:	81 30       	cpi	r24, 0x01	; 1
    1428:	09 f0       	breq	.+2      	; 0x142c <direction+0x24>
    142a:	4a c0       	rjmp	.+148    	; 0x14c0 <direction+0xb8>
		{	init_devices_pos();
    142c:	0e 94 18 04 	call	0x830	; 0x830 <init_devices_pos>
			if(dir==3)
    1430:	80 91 66 00 	lds	r24, 0x0066
    1434:	83 30       	cpi	r24, 0x03	; 3
    1436:	81 f4       	brne	.+32     	; 0x1458 <direction+0x50>
			{	//buzzer_beep();
				right_degrees(190);
    1438:	8e eb       	ldi	r24, 0xBE	; 190
    143a:	90 e0       	ldi	r25, 0x00	; 0
    143c:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <right_degrees>
				stop_pos();
    1440:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
    1444:	2f ef       	ldi	r18, 0xFF	; 255
    1446:	3f e3       	ldi	r19, 0x3F	; 63
    1448:	4b e0       	ldi	r20, 0x0B	; 11
    144a:	21 50       	subi	r18, 0x01	; 1
    144c:	30 40       	sbci	r19, 0x00	; 0
    144e:	40 40       	sbci	r20, 0x00	; 0
    1450:	e1 f7       	brne	.-8      	; 0x144a <direction+0x42>
    1452:	00 c0       	rjmp	.+0      	; 0x1454 <direction+0x4c>
    1454:	00 00       	nop
    1456:	23 c0       	rjmp	.+70     	; 0x149e <direction+0x96>
				_delay_ms(500);
			}
			else if(dir==4)
    1458:	84 30       	cpi	r24, 0x04	; 4
    145a:	81 f4       	brne	.+32     	; 0x147c <direction+0x74>
			{
				right_degrees(100);
    145c:	84 e6       	ldi	r24, 0x64	; 100
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <right_degrees>
				stop_pos();
    1464:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
    1468:	8f ef       	ldi	r24, 0xFF	; 255
    146a:	9f e3       	ldi	r25, 0x3F	; 63
    146c:	ab e0       	ldi	r26, 0x0B	; 11
    146e:	81 50       	subi	r24, 0x01	; 1
    1470:	90 40       	sbci	r25, 0x00	; 0
    1472:	a0 40       	sbci	r26, 0x00	; 0
    1474:	e1 f7       	brne	.-8      	; 0x146e <direction+0x66>
    1476:	00 c0       	rjmp	.+0      	; 0x1478 <direction+0x70>
    1478:	00 00       	nop
    147a:	11 c0       	rjmp	.+34     	; 0x149e <direction+0x96>
				_delay_ms(500);
			}
			else if(dir==2)
    147c:	82 30       	cpi	r24, 0x02	; 2
    147e:	79 f4       	brne	.+30     	; 0x149e <direction+0x96>
			{
				left_degrees(100);
    1480:	84 e6       	ldi	r24, 0x64	; 100
    1482:	90 e0       	ldi	r25, 0x00	; 0
    1484:	0e 94 ce 03 	call	0x79c	; 0x79c <left_degrees>
				stop_pos();
    1488:	0e 94 3d 03 	call	0x67a	; 0x67a <stop_pos>
    148c:	2f ef       	ldi	r18, 0xFF	; 255
    148e:	3f e3       	ldi	r19, 0x3F	; 63
    1490:	4b e0       	ldi	r20, 0x0B	; 11
    1492:	21 50       	subi	r18, 0x01	; 1
    1494:	30 40       	sbci	r19, 0x00	; 0
    1496:	40 40       	sbci	r20, 0x00	; 0
    1498:	e1 f7       	brne	.-8      	; 0x1492 <direction+0x8a>
    149a:	00 c0       	rjmp	.+0      	; 0x149c <direction+0x94>
    149c:	00 00       	nop
				_delay_ms(500);
			}
			
			dir=1;
    149e:	81 e0       	ldi	r24, 0x01	; 1
    14a0:	80 93 66 00 	sts	0x0066, r24
    14a4:	2f ef       	ldi	r18, 0xFF	; 255
    14a6:	3f e7       	ldi	r19, 0x7F	; 127
    14a8:	46 e1       	ldi	r20, 0x16	; 22
    14aa:	21 50       	subi	r18, 0x01	; 1
    14ac:	30 40       	sbci	r19, 0x00	; 0
    14ae:	40 40       	sbci	r20, 0x00	; 0
    14b0:	e1 f7       	brne	.-8      	; 0x14aa <direction+0xa2>
    14b2:	00 c0       	rjmp	.+0      	; 0x14b4 <direction+0xac>
    14b4:	00 00       	nop
		//	lcd_print(2,4,dir,3);
			_delay_ms(1000);
			g=1;
    14b6:	80 93 81 00 	sts	0x0081, r24
			init_devices();
    14ba:	0e 94 6e 06 	call	0xcdc	; 0xcdc <init_devices>
    14be:	02 c1       	rjmp	.+516    	; 0x16c4 <direction+0x2bc>
		}
		else if(stage==2)
    14c0:	82 30       	cpi	r24, 0x02	; 2
    14c2:	09 f0       	breq	.+2      	; 0x14c6 <direction+0xbe>
    14c4:	f4 c0       	rjmp	.+488    	; 0x16ae <direction+0x2a6>

		{	
			
			init_devices_zigbee();
    14c6:	0e 94 3f 09 	call	0x127e	; 0x127e <init_devices_zigbee>
    14ca:	8f ef       	ldi	r24, 0xFF	; 255
    14cc:	9f e3       	ldi	r25, 0x3F	; 63
    14ce:	a2 e0       	ldi	r26, 0x02	; 2
    14d0:	81 50       	subi	r24, 0x01	; 1
    14d2:	90 40       	sbci	r25, 0x00	; 0
    14d4:	a0 40       	sbci	r26, 0x00	; 0
    14d6:	e1 f7       	brne	.-8      	; 0x14d0 <direction+0xc8>
    14d8:	00 c0       	rjmp	.+0      	; 0x14da <direction+0xd2>
    14da:	00 00       	nop
			_delay_ms(100);
			while (1)
			{
				if(next>3)
    14dc:	80 91 6e 00 	lds	r24, 0x006E
    14e0:	84 30       	cpi	r24, 0x04	; 4
    14e2:	e0 f3       	brcs	.-8      	; 0x14dc <direction+0xd4>
					break;
					
				}
			}
			
			red_nodes[0]=51;
    14e4:	93 e3       	ldi	r25, 0x33	; 51
    14e6:	90 93 f3 00 	sts	0x00F3, r25
			red_nodes[r]=52;
    14ea:	e0 91 64 00 	lds	r30, 0x0064
    14ee:	f0 e0       	ldi	r31, 0x00	; 0
    14f0:	ed 50       	subi	r30, 0x0D	; 13
    14f2:	ff 4f       	sbci	r31, 0xFF	; 255
    14f4:	84 e3       	ldi	r24, 0x34	; 52
    14f6:	80 83       	st	Z, r24
			red_side[0]=51;
    14f8:	90 93 ff 00 	sts	0x00FF, r25
			red_side[rs]=52;
    14fc:	e0 91 63 00 	lds	r30, 0x0063
    1500:	f0 e0       	ldi	r31, 0x00	; 0
    1502:	e1 50       	subi	r30, 0x01	; 1
    1504:	ff 4f       	sbci	r31, 0xFF	; 255
    1506:	80 83       	st	Z, r24
			for(int i=0;i<=10;i++)
			{	if(red_nodes[i]==0)
    1508:	80 91 f3 00 	lds	r24, 0x00F3
    150c:	88 23       	and	r24, r24
    150e:	09 f0       	breq	.+2      	; 0x1512 <direction+0x10a>
    1510:	a1 c1       	rjmp	.+834    	; 0x1854 <direction+0x44c>
    1512:	19 c0       	rjmp	.+50     	; 0x1546 <direction+0x13e>
    1514:	f8 01       	movw	r30, r16
    1516:	ec 0f       	add	r30, r28
    1518:	fd 1f       	adc	r31, r29
    151a:	80 81       	ld	r24, Z
    151c:	88 23       	and	r24, r24
    151e:	99 f0       	breq	.+38     	; 0x1546 <direction+0x13e>
				{
					
					break;
					
				}
				USARTWriteChar(red_nodes[i]);
    1520:	f8 01       	movw	r30, r16
    1522:	ec 0f       	add	r30, r28
    1524:	fd 1f       	adc	r31, r29
    1526:	80 81       	ld	r24, Z
    1528:	0e 94 02 0a 	call	0x1404	; 0x1404 <USARTWriteChar>
    152c:	2f ef       	ldi	r18, 0xFF	; 255
    152e:	3f e3       	ldi	r19, 0x3F	; 63
    1530:	42 e0       	ldi	r20, 0x02	; 2
    1532:	21 50       	subi	r18, 0x01	; 1
    1534:	30 40       	sbci	r19, 0x00	; 0
    1536:	40 40       	sbci	r20, 0x00	; 0
    1538:	e1 f7       	brne	.-8      	; 0x1532 <direction+0x12a>
    153a:	00 c0       	rjmp	.+0      	; 0x153c <direction+0x134>
    153c:	00 00       	nop
			
			red_nodes[0]=51;
			red_nodes[r]=52;
			red_side[0]=51;
			red_side[rs]=52;
			for(int i=0;i<=10;i++)
    153e:	21 96       	adiw	r28, 0x01	; 1
    1540:	cb 30       	cpi	r28, 0x0B	; 11
    1542:	d1 05       	cpc	r29, r1
    1544:	39 f7       	brne	.-50     	; 0x1514 <direction+0x10c>
				}*/
				
				
			}
			
			buzzer_on();
    1546:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    154a:	8f ef       	ldi	r24, 0xFF	; 255
    154c:	9f e7       	ldi	r25, 0x7F	; 127
    154e:	a6 e1       	ldi	r26, 0x16	; 22
    1550:	81 50       	subi	r24, 0x01	; 1
    1552:	90 40       	sbci	r25, 0x00	; 0
    1554:	a0 40       	sbci	r26, 0x00	; 0
    1556:	e1 f7       	brne	.-8      	; 0x1550 <direction+0x148>
    1558:	00 c0       	rjmp	.+0      	; 0x155a <direction+0x152>
    155a:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    155c:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
			for(int i=0;i<10;i++)
			{	if(red_side[i]==0)
    1560:	80 91 ff 00 	lds	r24, 0x00FF
    1564:	88 23       	and	r24, r24
    1566:	09 f0       	breq	.+2      	; 0x156a <direction+0x162>
    1568:	63 c1       	rjmp	.+710    	; 0x1830 <direction+0x428>
    156a:	19 c0       	rjmp	.+50     	; 0x159e <direction+0x196>
    156c:	f8 01       	movw	r30, r16
    156e:	ec 0f       	add	r30, r28
    1570:	fd 1f       	adc	r31, r29
    1572:	80 81       	ld	r24, Z
    1574:	88 23       	and	r24, r24
    1576:	99 f0       	breq	.+38     	; 0x159e <direction+0x196>
				{
					break;
				}
				USARTWriteChar(red_side[i]);
    1578:	f8 01       	movw	r30, r16
    157a:	ec 0f       	add	r30, r28
    157c:	fd 1f       	adc	r31, r29
    157e:	80 81       	ld	r24, Z
    1580:	0e 94 02 0a 	call	0x1404	; 0x1404 <USARTWriteChar>
    1584:	2f ef       	ldi	r18, 0xFF	; 255
    1586:	3f e3       	ldi	r19, 0x3F	; 63
    1588:	42 e0       	ldi	r20, 0x02	; 2
    158a:	21 50       	subi	r18, 0x01	; 1
    158c:	30 40       	sbci	r19, 0x00	; 0
    158e:	40 40       	sbci	r20, 0x00	; 0
    1590:	e1 f7       	brne	.-8      	; 0x158a <direction+0x182>
    1592:	00 c0       	rjmp	.+0      	; 0x1594 <direction+0x18c>
    1594:	00 00       	nop
			}
			
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    1596:	21 96       	adiw	r28, 0x01	; 1
    1598:	ca 30       	cpi	r28, 0x0A	; 10
    159a:	d1 05       	cpc	r29, r1
    159c:	39 f7       	brne	.-50     	; 0x156c <direction+0x164>
				USARTWriteChar(red_side[i]);
				_delay_ms(100);
				
			}
			
			buzzer_on();
    159e:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    15a2:	8f ef       	ldi	r24, 0xFF	; 255
    15a4:	9f e7       	ldi	r25, 0x7F	; 127
    15a6:	a6 e1       	ldi	r26, 0x16	; 22
    15a8:	81 50       	subi	r24, 0x01	; 1
    15aa:	90 40       	sbci	r25, 0x00	; 0
    15ac:	a0 40       	sbci	r26, 0x00	; 0
    15ae:	e1 f7       	brne	.-8      	; 0x15a8 <direction+0x1a0>
    15b0:	00 c0       	rjmp	.+0      	; 0x15b2 <direction+0x1aa>
    15b2:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    15b4:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
			green_nodes[0]=55;
    15b8:	97 e3       	ldi	r25, 0x37	; 55
    15ba:	90 93 82 00 	sts	0x0082, r25
			green_nodes[gn]=56;
    15be:	e0 91 62 00 	lds	r30, 0x0062
    15c2:	f0 e0       	ldi	r31, 0x00	; 0
    15c4:	ee 57       	subi	r30, 0x7E	; 126
    15c6:	ff 4f       	sbci	r31, 0xFF	; 255
    15c8:	88 e3       	ldi	r24, 0x38	; 56
    15ca:	80 83       	st	Z, r24
			green_side[0]=55;
    15cc:	90 93 a0 00 	sts	0x00A0, r25
			green_side[gs]=56;
    15d0:	e0 91 61 00 	lds	r30, 0x0061
    15d4:	f0 e0       	ldi	r31, 0x00	; 0
    15d6:	e0 56       	subi	r30, 0x60	; 96
    15d8:	ff 4f       	sbci	r31, 0xFF	; 255
    15da:	80 83       	st	Z, r24
			for(int i=0;i<=10;i++)
			{	if(green_nodes[i]==0)
    15dc:	80 91 82 00 	lds	r24, 0x0082
    15e0:	88 23       	and	r24, r24
    15e2:	09 f0       	breq	.+2      	; 0x15e6 <direction+0x1de>
    15e4:	13 c1       	rjmp	.+550    	; 0x180c <direction+0x404>
    15e6:	19 c0       	rjmp	.+50     	; 0x161a <direction+0x212>
    15e8:	f8 01       	movw	r30, r16
    15ea:	ec 0f       	add	r30, r28
    15ec:	fd 1f       	adc	r31, r29
    15ee:	80 81       	ld	r24, Z
    15f0:	88 23       	and	r24, r24
    15f2:	99 f0       	breq	.+38     	; 0x161a <direction+0x212>
				{
					
					break;
					
				}
				USARTWriteChar(green_nodes[i]);
    15f4:	f8 01       	movw	r30, r16
    15f6:	ec 0f       	add	r30, r28
    15f8:	fd 1f       	adc	r31, r29
    15fa:	80 81       	ld	r24, Z
    15fc:	0e 94 02 0a 	call	0x1404	; 0x1404 <USARTWriteChar>
    1600:	2f ef       	ldi	r18, 0xFF	; 255
    1602:	3f e7       	ldi	r19, 0x7F	; 127
    1604:	46 e1       	ldi	r20, 0x16	; 22
    1606:	21 50       	subi	r18, 0x01	; 1
    1608:	30 40       	sbci	r19, 0x00	; 0
    160a:	40 40       	sbci	r20, 0x00	; 0
    160c:	e1 f7       	brne	.-8      	; 0x1606 <direction+0x1fe>
    160e:	00 c0       	rjmp	.+0      	; 0x1610 <direction+0x208>
    1610:	00 00       	nop
			buzzer_off();
			green_nodes[0]=55;
			green_nodes[gn]=56;
			green_side[0]=55;
			green_side[gs]=56;
			for(int i=0;i<=10;i++)
    1612:	21 96       	adiw	r28, 0x01	; 1
    1614:	cb 30       	cpi	r28, 0x0B	; 11
    1616:	d1 05       	cpc	r29, r1
    1618:	39 f7       	brne	.-50     	; 0x15e8 <direction+0x1e0>
				
				_delay_ms(1000);
				//buzzer_beep();
				
			}
			buzzer_on();
    161a:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    161e:	8f ef       	ldi	r24, 0xFF	; 255
    1620:	9f e7       	ldi	r25, 0x7F	; 127
    1622:	a6 e1       	ldi	r26, 0x16	; 22
    1624:	81 50       	subi	r24, 0x01	; 1
    1626:	90 40       	sbci	r25, 0x00	; 0
    1628:	a0 40       	sbci	r26, 0x00	; 0
    162a:	e1 f7       	brne	.-8      	; 0x1624 <direction+0x21c>
    162c:	00 c0       	rjmp	.+0      	; 0x162e <direction+0x226>
    162e:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    1630:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
			for(int i=0;i<10;i++)
			{	if(green_side[i]==0)
    1634:	80 91 a0 00 	lds	r24, 0x00A0
    1638:	88 23       	and	r24, r24
    163a:	09 f0       	breq	.+2      	; 0x163e <direction+0x236>
    163c:	d5 c0       	rjmp	.+426    	; 0x17e8 <direction+0x3e0>
    163e:	19 c0       	rjmp	.+50     	; 0x1672 <direction+0x26a>
    1640:	f8 01       	movw	r30, r16
    1642:	ec 0f       	add	r30, r28
    1644:	fd 1f       	adc	r31, r29
    1646:	80 81       	ld	r24, Z
    1648:	88 23       	and	r24, r24
    164a:	99 f0       	breq	.+38     	; 0x1672 <direction+0x26a>
				{
					break;
				}
				USARTWriteChar(green_side[i]);
    164c:	f8 01       	movw	r30, r16
    164e:	ec 0f       	add	r30, r28
    1650:	fd 1f       	adc	r31, r29
    1652:	80 81       	ld	r24, Z
    1654:	0e 94 02 0a 	call	0x1404	; 0x1404 <USARTWriteChar>
    1658:	2f ef       	ldi	r18, 0xFF	; 255
    165a:	3f e7       	ldi	r19, 0x7F	; 127
    165c:	46 e1       	ldi	r20, 0x16	; 22
    165e:	21 50       	subi	r18, 0x01	; 1
    1660:	30 40       	sbci	r19, 0x00	; 0
    1662:	40 40       	sbci	r20, 0x00	; 0
    1664:	e1 f7       	brne	.-8      	; 0x165e <direction+0x256>
    1666:	00 c0       	rjmp	.+0      	; 0x1668 <direction+0x260>
    1668:	00 00       	nop
				
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    166a:	21 96       	adiw	r28, 0x01	; 1
    166c:	ca 30       	cpi	r28, 0x0A	; 10
    166e:	d1 05       	cpc	r29, r1
    1670:	39 f7       	brne	.-50     	; 0x1640 <direction+0x238>
				}
				USARTWriteChar(green_side[i]);
				_delay_ms(1000);
				//buzzer_beep();
			}
			buzzer_on();
    1672:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1676:	8f ef       	ldi	r24, 0xFF	; 255
    1678:	9f e7       	ldi	r25, 0x7F	; 127
    167a:	a6 e1       	ldi	r26, 0x16	; 22
    167c:	81 50       	subi	r24, 0x01	; 1
    167e:	90 40       	sbci	r25, 0x00	; 0
    1680:	a0 40       	sbci	r26, 0x00	; 0
    1682:	e1 f7       	brne	.-8      	; 0x167c <direction+0x274>
    1684:	00 c0       	rjmp	.+0      	; 0x1686 <direction+0x27e>
    1686:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    1688:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
					break;
				}
				
			}*/
			
			g=1;
    168c:	81 e0       	ldi	r24, 0x01	; 1
    168e:	80 93 81 00 	sts	0x0081, r24
			buzzer_on();
    1692:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1696:	2f ef       	ldi	r18, 0xFF	; 255
    1698:	3f e7       	ldi	r19, 0x7F	; 127
    169a:	46 e1       	ldi	r20, 0x16	; 22
    169c:	21 50       	subi	r18, 0x01	; 1
    169e:	30 40       	sbci	r19, 0x00	; 0
    16a0:	40 40       	sbci	r20, 0x00	; 0
    16a2:	e1 f7       	brne	.-8      	; 0x169c <direction+0x294>
    16a4:	00 c0       	rjmp	.+0      	; 0x16a6 <direction+0x29e>
    16a6:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    16a8:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
    16ac:	0b c0       	rjmp	.+22     	; 0x16c4 <direction+0x2bc>
			
			
		}
		else if(stage==3)
    16ae:	83 30       	cpi	r24, 0x03	; 3
    16b0:	21 f4       	brne	.+8      	; 0x16ba <direction+0x2b2>
		{
			g=1;
    16b2:	81 e0       	ldi	r24, 0x01	; 1
    16b4:	80 93 81 00 	sts	0x0081, r24
    16b8:	05 c0       	rjmp	.+10     	; 0x16c4 <direction+0x2bc>
		
		}		
		else if(stage==4)
    16ba:	84 30       	cpi	r24, 0x04	; 4
    16bc:	19 f4       	brne	.+6      	; 0x16c4 <direction+0x2bc>
		{
			g=1;
    16be:	81 e0       	ldi	r24, 0x01	; 1
    16c0:	80 93 81 00 	sts	0x0081, r24
		}		
		
		
		
	}
	if(t<max)
    16c4:	20 91 73 00 	lds	r18, 0x0073
    16c8:	80 91 80 00 	lds	r24, 0x0080
    16cc:	28 17       	cp	r18, r24
    16ce:	08 f0       	brcs	.+2      	; 0x16d2 <direction+0x2ca>
    16d0:	d3 c0       	rjmp	.+422    	; 0x1878 <direction+0x470>
	{
		w=(path1.path[t]-path1.path[t+1]);
    16d2:	e8 ec       	ldi	r30, 0xC8	; 200
    16d4:	f0 e0       	ldi	r31, 0x00	; 0
    16d6:	e2 0f       	add	r30, r18
    16d8:	f1 1d       	adc	r31, r1
    16da:	80 81       	ld	r24, Z
    16dc:	90 e0       	ldi	r25, 0x00	; 0
    16de:	31 81       	ldd	r19, Z+1	; 0x01
    16e0:	83 1b       	sub	r24, r19
    16e2:	91 09       	sbc	r25, r1
		t++;
    16e4:	2f 5f       	subi	r18, 0xFF	; 255
    16e6:	20 93 73 00 	sts	0x0073, r18
			lcd_init();
			
		
		lcd_print(2,1,w,3);
		_delay_ms(4000);*/
		switch (w)
    16ea:	3f ef       	ldi	r19, 0xFF	; 255
    16ec:	8f 3f       	cpi	r24, 0xFF	; 255
    16ee:	93 07       	cpc	r25, r19
    16f0:	69 f1       	breq	.+90     	; 0x174c <direction+0x344>
    16f2:	4f ef       	ldi	r20, 0xFF	; 255
    16f4:	8f 3f       	cpi	r24, 0xFF	; 255
    16f6:	94 07       	cpc	r25, r20
    16f8:	09 f0       	breq	.+2      	; 0x16fc <direction+0x2f4>
    16fa:	34 f4       	brge	.+12     	; 0x1708 <direction+0x300>
    16fc:	5f ef       	ldi	r21, 0xFF	; 255
    16fe:	89 3f       	cpi	r24, 0xF9	; 249
    1700:	95 07       	cpc	r25, r21
    1702:	09 f0       	breq	.+2      	; 0x1706 <direction+0x2fe>
    1704:	b9 c0       	rjmp	.+370    	; 0x1878 <direction+0x470>
    1706:	56 c0       	rjmp	.+172    	; 0x17b4 <direction+0x3ac>
    1708:	81 30       	cpi	r24, 0x01	; 1
    170a:	91 05       	cpc	r25, r1
    170c:	29 f0       	breq	.+10     	; 0x1718 <direction+0x310>
    170e:	87 30       	cpi	r24, 0x07	; 7
    1710:	91 05       	cpc	r25, r1
    1712:	09 f0       	breq	.+2      	; 0x1716 <direction+0x30e>
    1714:	b1 c0       	rjmp	.+354    	; 0x1878 <direction+0x470>
    1716:	34 c0       	rjmp	.+104    	; 0x1780 <direction+0x378>
		{ 
			case 1:
			
				if(dir==1)
    1718:	80 91 66 00 	lds	r24, 0x0066
    171c:	81 30       	cpi	r24, 0x01	; 1
    171e:	29 f4       	brne	.+10     	; 0x172a <direction+0x322>
				success(3);
    1720:	83 e0       	ldi	r24, 0x03	; 3
    1722:	90 e0       	ldi	r25, 0x00	; 0
    1724:	0e 94 ab 05 	call	0xb56	; 0xb56 <success>
    1728:	0d c0       	rjmp	.+26     	; 0x1744 <direction+0x33c>
				else if(dir==3)
    172a:	83 30       	cpi	r24, 0x03	; 3
    172c:	29 f4       	brne	.+10     	; 0x1738 <direction+0x330>
				success(2);
    172e:	82 e0       	ldi	r24, 0x02	; 2
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	0e 94 ab 05 	call	0xb56	; 0xb56 <success>
    1736:	06 c0       	rjmp	.+12     	; 0x1744 <direction+0x33c>
				else if(dir==4)
    1738:	84 30       	cpi	r24, 0x04	; 4
    173a:	21 f4       	brne	.+8      	; 0x1744 <direction+0x33c>
				success(1);
    173c:	81 e0       	ldi	r24, 0x01	; 1
    173e:	90 e0       	ldi	r25, 0x00	; 0
    1740:	0e 94 ab 05 	call	0xb56	; 0xb56 <success>
				
				dir=4;
    1744:	84 e0       	ldi	r24, 0x04	; 4
    1746:	80 93 66 00 	sts	0x0066, r24
				break;
    174a:	96 c0       	rjmp	.+300    	; 0x1878 <direction+0x470>
			
			case (-1):
			
				if(dir==1)
    174c:	80 91 66 00 	lds	r24, 0x0066
    1750:	81 30       	cpi	r24, 0x01	; 1
    1752:	29 f4       	brne	.+10     	; 0x175e <direction+0x356>
				success(2);
    1754:	82 e0       	ldi	r24, 0x02	; 2
    1756:	90 e0       	ldi	r25, 0x00	; 0
    1758:	0e 94 ab 05 	call	0xb56	; 0xb56 <success>
    175c:	0d c0       	rjmp	.+26     	; 0x1778 <direction+0x370>
				else if(dir==2)
    175e:	82 30       	cpi	r24, 0x02	; 2
    1760:	29 f4       	brne	.+10     	; 0x176c <direction+0x364>
				success(1);
    1762:	81 e0       	ldi	r24, 0x01	; 1
    1764:	90 e0       	ldi	r25, 0x00	; 0
    1766:	0e 94 ab 05 	call	0xb56	; 0xb56 <success>
    176a:	06 c0       	rjmp	.+12     	; 0x1778 <direction+0x370>
				else if(dir==3)
    176c:	83 30       	cpi	r24, 0x03	; 3
    176e:	21 f4       	brne	.+8      	; 0x1778 <direction+0x370>
				success(3);
    1770:	83 e0       	ldi	r24, 0x03	; 3
    1772:	90 e0       	ldi	r25, 0x00	; 0
    1774:	0e 94 ab 05 	call	0xb56	; 0xb56 <success>
				
				dir=2;
    1778:	82 e0       	ldi	r24, 0x02	; 2
    177a:	80 93 66 00 	sts	0x0066, r24
				break;
    177e:	7c c0       	rjmp	.+248    	; 0x1878 <direction+0x470>
				
			
			case (7):
			
				if(dir==1)
    1780:	80 91 66 00 	lds	r24, 0x0066
    1784:	81 30       	cpi	r24, 0x01	; 1
    1786:	29 f4       	brne	.+10     	; 0x1792 <direction+0x38a>
				success(1);
    1788:	81 e0       	ldi	r24, 0x01	; 1
    178a:	90 e0       	ldi	r25, 0x00	; 0
    178c:	0e 94 ab 05 	call	0xb56	; 0xb56 <success>
    1790:	0d c0       	rjmp	.+26     	; 0x17ac <direction+0x3a4>
				else if(dir==2)
    1792:	82 30       	cpi	r24, 0x02	; 2
    1794:	29 f4       	brne	.+10     	; 0x17a0 <direction+0x398>
				success(3);
    1796:	83 e0       	ldi	r24, 0x03	; 3
    1798:	90 e0       	ldi	r25, 0x00	; 0
    179a:	0e 94 ab 05 	call	0xb56	; 0xb56 <success>
    179e:	06 c0       	rjmp	.+12     	; 0x17ac <direction+0x3a4>
				else if(dir==4)
    17a0:	84 30       	cpi	r24, 0x04	; 4
    17a2:	21 f4       	brne	.+8      	; 0x17ac <direction+0x3a4>
				success(2);
    17a4:	82 e0       	ldi	r24, 0x02	; 2
    17a6:	90 e0       	ldi	r25, 0x00	; 0
    17a8:	0e 94 ab 05 	call	0xb56	; 0xb56 <success>
				
				dir=1;
    17ac:	81 e0       	ldi	r24, 0x01	; 1
    17ae:	80 93 66 00 	sts	0x0066, r24
				break;
    17b2:	62 c0       	rjmp	.+196    	; 0x1878 <direction+0x470>
				
			
			case (-7):
			
				if(dir==2)
    17b4:	80 91 66 00 	lds	r24, 0x0066
    17b8:	82 30       	cpi	r24, 0x02	; 2
    17ba:	29 f4       	brne	.+10     	; 0x17c6 <direction+0x3be>
				success(2);
    17bc:	82 e0       	ldi	r24, 0x02	; 2
    17be:	90 e0       	ldi	r25, 0x00	; 0
    17c0:	0e 94 ab 05 	call	0xb56	; 0xb56 <success>
    17c4:	0d c0       	rjmp	.+26     	; 0x17e0 <direction+0x3d8>
				else if(dir==3)
    17c6:	83 30       	cpi	r24, 0x03	; 3
    17c8:	29 f4       	brne	.+10     	; 0x17d4 <direction+0x3cc>
				success(1);
    17ca:	81 e0       	ldi	r24, 0x01	; 1
    17cc:	90 e0       	ldi	r25, 0x00	; 0
    17ce:	0e 94 ab 05 	call	0xb56	; 0xb56 <success>
    17d2:	06 c0       	rjmp	.+12     	; 0x17e0 <direction+0x3d8>
				else if(dir==4)
    17d4:	84 30       	cpi	r24, 0x04	; 4
    17d6:	21 f4       	brne	.+8      	; 0x17e0 <direction+0x3d8>
				success(3);
    17d8:	83 e0       	ldi	r24, 0x03	; 3
    17da:	90 e0       	ldi	r25, 0x00	; 0
    17dc:	0e 94 ab 05 	call	0xb56	; 0xb56 <success>
				
				dir=3;
    17e0:	83 e0       	ldi	r24, 0x03	; 3
    17e2:	80 93 66 00 	sts	0x0066, r24
				break;
    17e6:	48 c0       	rjmp	.+144    	; 0x1878 <direction+0x470>
			for(int i=0;i<10;i++)
			{	if(green_side[i]==0)
				{
					break;
				}
				USARTWriteChar(green_side[i]);
    17e8:	80 91 a0 00 	lds	r24, 0x00A0
    17ec:	0e 94 02 0a 	call	0x1404	; 0x1404 <USARTWriteChar>
    17f0:	8f ef       	ldi	r24, 0xFF	; 255
    17f2:	9f e7       	ldi	r25, 0x7F	; 127
    17f4:	a6 e1       	ldi	r26, 0x16	; 22
    17f6:	81 50       	subi	r24, 0x01	; 1
    17f8:	90 40       	sbci	r25, 0x00	; 0
    17fa:	a0 40       	sbci	r26, 0x00	; 0
    17fc:	e1 f7       	brne	.-8      	; 0x17f6 <direction+0x3ee>
    17fe:	00 c0       	rjmp	.+0      	; 0x1800 <direction+0x3f8>
    1800:	00 00       	nop
				
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    1802:	c1 e0       	ldi	r28, 0x01	; 1
    1804:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(green_side[i]==0)
    1806:	00 ea       	ldi	r16, 0xA0	; 160
    1808:	10 e0       	ldi	r17, 0x00	; 0
    180a:	1a cf       	rjmp	.-460    	; 0x1640 <direction+0x238>
				{
					
					break;
					
				}
				USARTWriteChar(green_nodes[i]);
    180c:	80 91 82 00 	lds	r24, 0x0082
    1810:	0e 94 02 0a 	call	0x1404	; 0x1404 <USARTWriteChar>
    1814:	2f ef       	ldi	r18, 0xFF	; 255
    1816:	3f e7       	ldi	r19, 0x7F	; 127
    1818:	46 e1       	ldi	r20, 0x16	; 22
    181a:	21 50       	subi	r18, 0x01	; 1
    181c:	30 40       	sbci	r19, 0x00	; 0
    181e:	40 40       	sbci	r20, 0x00	; 0
    1820:	e1 f7       	brne	.-8      	; 0x181a <direction+0x412>
    1822:	00 c0       	rjmp	.+0      	; 0x1824 <direction+0x41c>
    1824:	00 00       	nop
			buzzer_off();
			green_nodes[0]=55;
			green_nodes[gn]=56;
			green_side[0]=55;
			green_side[gs]=56;
			for(int i=0;i<=10;i++)
    1826:	c1 e0       	ldi	r28, 0x01	; 1
    1828:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(green_nodes[i]==0)
    182a:	02 e8       	ldi	r16, 0x82	; 130
    182c:	10 e0       	ldi	r17, 0x00	; 0
    182e:	dc ce       	rjmp	.-584    	; 0x15e8 <direction+0x1e0>
			for(int i=0;i<10;i++)
			{	if(red_side[i]==0)
				{
					break;
				}
				USARTWriteChar(red_side[i]);
    1830:	80 91 ff 00 	lds	r24, 0x00FF
    1834:	0e 94 02 0a 	call	0x1404	; 0x1404 <USARTWriteChar>
    1838:	8f ef       	ldi	r24, 0xFF	; 255
    183a:	9f e3       	ldi	r25, 0x3F	; 63
    183c:	a2 e0       	ldi	r26, 0x02	; 2
    183e:	81 50       	subi	r24, 0x01	; 1
    1840:	90 40       	sbci	r25, 0x00	; 0
    1842:	a0 40       	sbci	r26, 0x00	; 0
    1844:	e1 f7       	brne	.-8      	; 0x183e <direction+0x436>
    1846:	00 c0       	rjmp	.+0      	; 0x1848 <direction+0x440>
    1848:	00 00       	nop
			}
			
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    184a:	c1 e0       	ldi	r28, 0x01	; 1
    184c:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(red_side[i]==0)
    184e:	0f ef       	ldi	r16, 0xFF	; 255
    1850:	10 e0       	ldi	r17, 0x00	; 0
    1852:	8c ce       	rjmp	.-744    	; 0x156c <direction+0x164>
				{
					
					break;
					
				}
				USARTWriteChar(red_nodes[i]);
    1854:	80 91 f3 00 	lds	r24, 0x00F3
    1858:	0e 94 02 0a 	call	0x1404	; 0x1404 <USARTWriteChar>
    185c:	2f ef       	ldi	r18, 0xFF	; 255
    185e:	3f e3       	ldi	r19, 0x3F	; 63
    1860:	42 e0       	ldi	r20, 0x02	; 2
    1862:	21 50       	subi	r18, 0x01	; 1
    1864:	30 40       	sbci	r19, 0x00	; 0
    1866:	40 40       	sbci	r20, 0x00	; 0
    1868:	e1 f7       	brne	.-8      	; 0x1862 <direction+0x45a>
    186a:	00 c0       	rjmp	.+0      	; 0x186c <direction+0x464>
    186c:	00 00       	nop
			
			red_nodes[0]=51;
			red_nodes[r]=52;
			red_side[0]=51;
			red_side[rs]=52;
			for(int i=0;i<=10;i++)
    186e:	c1 e0       	ldi	r28, 0x01	; 1
    1870:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(red_nodes[i]==0)
    1872:	03 ef       	ldi	r16, 0xF3	; 243
    1874:	10 e0       	ldi	r17, 0x00	; 0
    1876:	4e ce       	rjmp	.-868    	; 0x1514 <direction+0x10c>
			
			
		}
//		lcd_print(2,5,dir,2);
	}
}
    1878:	df 91       	pop	r29
    187a:	cf 91       	pop	r28
    187c:	1f 91       	pop	r17
    187e:	0f 91       	pop	r16
    1880:	08 95       	ret

00001882 <array_init>:


void array_init()
{
	for(int i=0;i<=10;i++)
    1882:	80 e0       	ldi	r24, 0x00	; 0
    1884:	90 e0       	ldi	r25, 0x00	; 0
	{
		red_nodes[i]=0;
    1886:	23 ef       	ldi	r18, 0xF3	; 243
    1888:	30 e0       	ldi	r19, 0x00	; 0
		green_nodes[i]=0;
    188a:	42 e8       	ldi	r20, 0x82	; 130
    188c:	50 e0       	ldi	r21, 0x00	; 0

void array_init()
{
	for(int i=0;i<=10;i++)
	{
		red_nodes[i]=0;
    188e:	f9 01       	movw	r30, r18
    1890:	e8 0f       	add	r30, r24
    1892:	f9 1f       	adc	r31, r25
    1894:	10 82       	st	Z, r1
		green_nodes[i]=0;
    1896:	fa 01       	movw	r30, r20
    1898:	e8 0f       	add	r30, r24
    189a:	f9 1f       	adc	r31, r25
    189c:	10 82       	st	Z, r1


void array_init()
{
	for(int i=0;i<=10;i++)
    189e:	01 96       	adiw	r24, 0x01	; 1
    18a0:	8b 30       	cpi	r24, 0x0B	; 11
    18a2:	91 05       	cpc	r25, r1
    18a4:	a1 f7       	brne	.-24     	; 0x188e <array_init+0xc>
    18a6:	80 e0       	ldi	r24, 0x00	; 0
    18a8:	90 e0       	ldi	r25, 0x00	; 0
		red_nodes[i]=0;
		green_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
	{
		red_side[i]=0;
    18aa:	2f ef       	ldi	r18, 0xFF	; 255
    18ac:	30 e0       	ldi	r19, 0x00	; 0
		green_side[i]=0;
    18ae:	40 ea       	ldi	r20, 0xA0	; 160
    18b0:	50 e0       	ldi	r21, 0x00	; 0
		red_nodes[i]=0;
		green_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
	{
		red_side[i]=0;
    18b2:	f9 01       	movw	r30, r18
    18b4:	e8 0f       	add	r30, r24
    18b6:	f9 1f       	adc	r31, r25
    18b8:	10 82       	st	Z, r1
		green_side[i]=0;
    18ba:	fa 01       	movw	r30, r20
    18bc:	e8 0f       	add	r30, r24
    18be:	f9 1f       	adc	r31, r25
    18c0:	10 82       	st	Z, r1
	for(int i=0;i<=10;i++)
	{
		red_nodes[i]=0;
		green_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
    18c2:	01 96       	adiw	r24, 0x01	; 1
    18c4:	85 31       	cpi	r24, 0x15	; 21
    18c6:	91 05       	cpc	r25, r1
    18c8:	a1 f7       	brne	.-24     	; 0x18b2 <array_init+0x30>
	{
		red_side[i]=0;
		green_side[i]=0;
	}
}
    18ca:	08 95       	ret

000018cc <ReachDestinationAvoidingNode>:
#include "direction.h"
//#include "adjsrc4.h"


void ReachDestinationAvoidingNode(unsigned char Xd,unsigned char Yd)
{
    18cc:	cf 93       	push	r28
    18ce:	df 93       	push	r29
    18d0:	cd b7       	in	r28, 0x3d	; 61
    18d2:	de b7       	in	r29, 0x3e	; 62
    18d4:	2f 97       	sbiw	r28, 0x0f	; 15
    18d6:	0f b6       	in	r0, 0x3f	; 63
    18d8:	f8 94       	cli
    18da:	de bf       	out	0x3e, r29	; 62
    18dc:	0f be       	out	0x3f, r0	; 63
    18de:	cd bf       	out	0x3d, r28	; 61
	
	

	path1 = main_function7( start,des);
    18e0:	ce 01       	movw	r24, r28
    18e2:	01 96       	adiw	r24, 0x01	; 1
    18e4:	60 91 68 00 	lds	r22, 0x0068
    18e8:	40 91 67 00 	lds	r20, 0x0067
    18ec:	0e 94 e0 00 	call	0x1c0	; 0x1c0 <main_function7>
    18f0:	a8 ec       	ldi	r26, 0xC8	; 200
    18f2:	b0 e0       	ldi	r27, 0x00	; 0
    18f4:	fe 01       	movw	r30, r28
    18f6:	31 96       	adiw	r30, 0x01	; 1
    18f8:	8f e0       	ldi	r24, 0x0F	; 15
    18fa:	01 90       	ld	r0, Z+
    18fc:	0d 92       	st	X+, r0
    18fe:	81 50       	subi	r24, 0x01	; 1
    1900:	e1 f7       	brne	.-8      	; 0x18fa <ReachDestinationAvoidingNode+0x2e>

	

	while(1)
	{
		line_follower();
    1902:	0e 94 77 06 	call	0xcee	; 0xcee <line_follower>
		if (g==1)
    1906:	80 91 81 00 	lds	r24, 0x0081
    190a:	81 30       	cpi	r24, 0x01	; 1
    190c:	d1 f7       	brne	.-12     	; 0x1902 <ReachDestinationAvoidingNode+0x36>
			
		
		
	}
	
	g=0;
    190e:	10 92 81 00 	sts	0x0081, r1
	l=0;
    1912:	10 92 74 00 	sts	0x0074, r1
	t=0;
    1916:	10 92 73 00 	sts	0x0073, r1
	back();
    191a:	0e 94 8a 05 	call	0xb14	; 0xb14 <back>
	velocity(100,100);
    191e:	84 e6       	ldi	r24, 0x64	; 100
    1920:	64 e6       	ldi	r22, 0x64	; 100
    1922:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
    1926:	8f ef       	ldi	r24, 0xFF	; 255
    1928:	9f eb       	ldi	r25, 0xBF	; 191
    192a:	a1 e2       	ldi	r26, 0x21	; 33
    192c:	81 50       	subi	r24, 0x01	; 1
    192e:	90 40       	sbci	r25, 0x00	; 0
    1930:	a0 40       	sbci	r26, 0x00	; 0
    1932:	e1 f7       	brne	.-8      	; 0x192c <ReachDestinationAvoidingNode+0x60>
    1934:	00 c0       	rjmp	.+0      	; 0x1936 <ReachDestinationAvoidingNode+0x6a>
    1936:	00 00       	nop
	
	_delay_ms(1500);
	
	start=des;
    1938:	80 91 67 00 	lds	r24, 0x0067
    193c:	80 93 68 00 	sts	0x0068, r24
}
    1940:	2f 96       	adiw	r28, 0x0f	; 15
    1942:	0f b6       	in	r0, 0x3f	; 63
    1944:	f8 94       	cli
    1946:	de bf       	out	0x3e, r29	; 62
    1948:	0f be       	out	0x3f, r0	; 63
    194a:	cd bf       	out	0x3d, r28	; 61
    194c:	df 91       	pop	r29
    194e:	cf 91       	pop	r28
    1950:	08 95       	ret

00001952 <main>:


//Do not make changes in main function

int main(void)
{   DDRB=0x20; 
    1952:	80 e2       	ldi	r24, 0x20	; 32
    1954:	87 bb       	out	0x17, r24	; 23
	//init_devices_pos();
     ReachDestinationAvoidingNode(start,des);//6-46
    1956:	80 91 68 00 	lds	r24, 0x0068
    195a:	60 91 67 00 	lds	r22, 0x0067
    195e:	0e 94 66 0c 	call	0x18cc	; 0x18cc <ReachDestinationAvoidingNode>
	 buzzer_on();
    1962:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1966:	8f ef       	ldi	r24, 0xFF	; 255
    1968:	9f e7       	ldi	r25, 0x7F	; 127
    196a:	a6 e1       	ldi	r26, 0x16	; 22
    196c:	81 50       	subi	r24, 0x01	; 1
    196e:	90 40       	sbci	r25, 0x00	; 0
    1970:	a0 40       	sbci	r26, 0x00	; 0
    1972:	e1 f7       	brne	.-8      	; 0x196c <main+0x1a>
    1974:	00 c0       	rjmp	.+0      	; 0x1976 <main+0x24>
    1976:	00 00       	nop
	   _delay_ms(1000);
	   buzzer_off();
    1978:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
	stage=2;
    197c:	82 e0       	ldi	r24, 0x02	; 2
    197e:	80 93 65 00 	sts	0x0065, r24
	//start=5;
	des=4;
    1982:	84 e0       	ldi	r24, 0x04	; 4
    1984:	80 93 67 00 	sts	0x0067, r24
	array_init();
    1988:	0e 94 41 0c 	call	0x1882	; 0x1882 <array_init>
		ReachDestinationAvoidingNode(start,des);//46-4
    198c:	80 91 68 00 	lds	r24, 0x0068
    1990:	60 91 67 00 	lds	r22, 0x0067
    1994:	0e 94 66 0c 	call	0x18cc	; 0x18cc <ReachDestinationAvoidingNode>
	//stage=4;
	//des=2;
	//ReachDestinationAvoidingNode(start,des);//4-2
	
 	stage=3;
    1998:	83 e0       	ldi	r24, 0x03	; 3
    199a:	80 93 65 00 	sts	0x0065, r24
	//start=2;////////
	/////////////stage==3/////start=4///
	des=44;
    199e:	8c e2       	ldi	r24, 0x2C	; 44
    19a0:	80 93 67 00 	sts	0x0067, r24
	ReachDestinationAvoidingNode(start,des);///2-44//4-44
    19a4:	80 91 68 00 	lds	r24, 0x0068
    19a8:	6c e2       	ldi	r22, 0x2C	; 44
    19aa:	0e 94 66 0c 	call	0x18cc	; 0x18cc <ReachDestinationAvoidingNode>
	
	//stage=4;
	//des=48;
	des=13;
    19ae:	8d e0       	ldi	r24, 0x0D	; 13
    19b0:	80 93 67 00 	sts	0x0067, r24
	buzzer_on();
    19b4:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    19b8:	8f ef       	ldi	r24, 0xFF	; 255
    19ba:	9f e7       	ldi	r25, 0x7F	; 127
    19bc:	a6 e1       	ldi	r26, 0x16	; 22
    19be:	81 50       	subi	r24, 0x01	; 1
    19c0:	90 40       	sbci	r25, 0x00	; 0
    19c2:	a0 40       	sbci	r26, 0x00	; 0
    19c4:	e1 f7       	brne	.-8      	; 0x19be <main+0x6c>
    19c6:	00 c0       	rjmp	.+0      	; 0x19c8 <main+0x76>
    19c8:	00 00       	nop
	_delay_ms(1000);
	buzzer_on();
    19ca:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
	ReachDestinationAvoidingNode(start,des);//44-48//44-13
    19ce:	80 91 68 00 	lds	r24, 0x0068
    19d2:	60 91 67 00 	lds	r22, 0x0067
    19d6:	0e 94 66 0c 	call	0x18cc	; 0x18cc <ReachDestinationAvoidingNode>
	buzzer_on();
    19da:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    19de:	8f ef       	ldi	r24, 0xFF	; 255
    19e0:	9f e7       	ldi	r25, 0x7F	; 127
    19e2:	a6 e1       	ldi	r26, 0x16	; 22
    19e4:	81 50       	subi	r24, 0x01	; 1
    19e6:	90 40       	sbci	r25, 0x00	; 0
    19e8:	a0 40       	sbci	r26, 0x00	; 0
    19ea:	e1 f7       	brne	.-8      	; 0x19e4 <main+0x92>
    19ec:	00 c0       	rjmp	.+0      	; 0x19ee <main+0x9c>
    19ee:	00 00       	nop
	_delay_ms(1000);
	buzzer_off();
    19f0:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_off>
// 	ReachDestinationAvoidingNode(start,des);//48-13
// 	buzzer_on();
// 	_delay_ms(1000);
// 	buzzer_on();
// 	stage=4;
	des=14;
    19f4:	8e e0       	ldi	r24, 0x0E	; 14
    19f6:	80 93 67 00 	sts	0x0067, r24
	ReachDestinationAvoidingNode(start,des);//13-14
    19fa:	80 91 68 00 	lds	r24, 0x0068
    19fe:	6e e0       	ldi	r22, 0x0E	; 14
    1a00:	0e 94 66 0c 	call	0x18cc	; 0x18cc <ReachDestinationAvoidingNode>
	

	buzzer_on();
    1a04:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
    1a08:	8f ef       	ldi	r24, 0xFF	; 255
    1a0a:	9f ef       	ldi	r25, 0xFF	; 255
    1a0c:	ac e2       	ldi	r26, 0x2C	; 44
    1a0e:	81 50       	subi	r24, 0x01	; 1
    1a10:	90 40       	sbci	r25, 0x00	; 0
    1a12:	a0 40       	sbci	r26, 0x00	; 0
    1a14:	e1 f7       	brne	.-8      	; 0x1a0e <main+0xbc>
    1a16:	00 c0       	rjmp	.+0      	; 0x1a18 <main+0xc6>
    1a18:	00 00       	nop
	_delay_ms(2000);
	buzzer_on();
    1a1a:	0e 94 bc 00 	call	0x178	; 0x178 <buzzer_on>
   forward();
    1a1e:	0e 94 86 05 	call	0xb0c	; 0xb0c <forward>
   velocity(0,0);
    1a22:	80 e0       	ldi	r24, 0x00	; 0
    1a24:	60 e0       	ldi	r22, 0x00	; 0
    1a26:	0e 94 a6 05 	call	0xb4c	; 0xb4c <velocity>
    1a2a:	8f ef       	ldi	r24, 0xFF	; 255
    1a2c:	9f eb       	ldi	r25, 0xBF	; 191
    1a2e:	a1 e2       	ldi	r26, 0x21	; 33
    1a30:	81 50       	subi	r24, 0x01	; 1
    1a32:	90 40       	sbci	r25, 0x00	; 0
    1a34:	a0 40       	sbci	r26, 0x00	; 0
    1a36:	e1 f7       	brne	.-8      	; 0x1a30 <main+0xde>
    1a38:	00 c0       	rjmp	.+0      	; 0x1a3a <main+0xe8>
    1a3a:	00 00       	nop
    1a3c:	ff cf       	rjmp	.-2      	; 0x1a3c <main+0xea>

00001a3e <__subsf3>:
    1a3e:	50 58       	subi	r21, 0x80	; 128

00001a40 <__addsf3>:
    1a40:	bb 27       	eor	r27, r27
    1a42:	aa 27       	eor	r26, r26
    1a44:	0e d0       	rcall	.+28     	; 0x1a62 <__addsf3x>
    1a46:	48 c1       	rjmp	.+656    	; 0x1cd8 <__fp_round>
    1a48:	39 d1       	rcall	.+626    	; 0x1cbc <__fp_pscA>
    1a4a:	30 f0       	brcs	.+12     	; 0x1a58 <__addsf3+0x18>
    1a4c:	3e d1       	rcall	.+636    	; 0x1cca <__fp_pscB>
    1a4e:	20 f0       	brcs	.+8      	; 0x1a58 <__addsf3+0x18>
    1a50:	31 f4       	brne	.+12     	; 0x1a5e <__addsf3+0x1e>
    1a52:	9f 3f       	cpi	r25, 0xFF	; 255
    1a54:	11 f4       	brne	.+4      	; 0x1a5a <__addsf3+0x1a>
    1a56:	1e f4       	brtc	.+6      	; 0x1a5e <__addsf3+0x1e>
    1a58:	2e c1       	rjmp	.+604    	; 0x1cb6 <__fp_nan>
    1a5a:	0e f4       	brtc	.+2      	; 0x1a5e <__addsf3+0x1e>
    1a5c:	e0 95       	com	r30
    1a5e:	e7 fb       	bst	r30, 7
    1a60:	24 c1       	rjmp	.+584    	; 0x1caa <__fp_inf>

00001a62 <__addsf3x>:
    1a62:	e9 2f       	mov	r30, r25
    1a64:	4a d1       	rcall	.+660    	; 0x1cfa <__fp_split3>
    1a66:	80 f3       	brcs	.-32     	; 0x1a48 <__addsf3+0x8>
    1a68:	ba 17       	cp	r27, r26
    1a6a:	62 07       	cpc	r22, r18
    1a6c:	73 07       	cpc	r23, r19
    1a6e:	84 07       	cpc	r24, r20
    1a70:	95 07       	cpc	r25, r21
    1a72:	18 f0       	brcs	.+6      	; 0x1a7a <__addsf3x+0x18>
    1a74:	71 f4       	brne	.+28     	; 0x1a92 <__addsf3x+0x30>
    1a76:	9e f5       	brtc	.+102    	; 0x1ade <__addsf3x+0x7c>
    1a78:	62 c1       	rjmp	.+708    	; 0x1d3e <__fp_zero>
    1a7a:	0e f4       	brtc	.+2      	; 0x1a7e <__addsf3x+0x1c>
    1a7c:	e0 95       	com	r30
    1a7e:	0b 2e       	mov	r0, r27
    1a80:	ba 2f       	mov	r27, r26
    1a82:	a0 2d       	mov	r26, r0
    1a84:	0b 01       	movw	r0, r22
    1a86:	b9 01       	movw	r22, r18
    1a88:	90 01       	movw	r18, r0
    1a8a:	0c 01       	movw	r0, r24
    1a8c:	ca 01       	movw	r24, r20
    1a8e:	a0 01       	movw	r20, r0
    1a90:	11 24       	eor	r1, r1
    1a92:	ff 27       	eor	r31, r31
    1a94:	59 1b       	sub	r21, r25
    1a96:	99 f0       	breq	.+38     	; 0x1abe <__addsf3x+0x5c>
    1a98:	59 3f       	cpi	r21, 0xF9	; 249
    1a9a:	50 f4       	brcc	.+20     	; 0x1ab0 <__addsf3x+0x4e>
    1a9c:	50 3e       	cpi	r21, 0xE0	; 224
    1a9e:	68 f1       	brcs	.+90     	; 0x1afa <__addsf3x+0x98>
    1aa0:	1a 16       	cp	r1, r26
    1aa2:	f0 40       	sbci	r31, 0x00	; 0
    1aa4:	a2 2f       	mov	r26, r18
    1aa6:	23 2f       	mov	r18, r19
    1aa8:	34 2f       	mov	r19, r20
    1aaa:	44 27       	eor	r20, r20
    1aac:	58 5f       	subi	r21, 0xF8	; 248
    1aae:	f3 cf       	rjmp	.-26     	; 0x1a96 <__addsf3x+0x34>
    1ab0:	46 95       	lsr	r20
    1ab2:	37 95       	ror	r19
    1ab4:	27 95       	ror	r18
    1ab6:	a7 95       	ror	r26
    1ab8:	f0 40       	sbci	r31, 0x00	; 0
    1aba:	53 95       	inc	r21
    1abc:	c9 f7       	brne	.-14     	; 0x1ab0 <__addsf3x+0x4e>
    1abe:	7e f4       	brtc	.+30     	; 0x1ade <__addsf3x+0x7c>
    1ac0:	1f 16       	cp	r1, r31
    1ac2:	ba 0b       	sbc	r27, r26
    1ac4:	62 0b       	sbc	r22, r18
    1ac6:	73 0b       	sbc	r23, r19
    1ac8:	84 0b       	sbc	r24, r20
    1aca:	ba f0       	brmi	.+46     	; 0x1afa <__addsf3x+0x98>
    1acc:	91 50       	subi	r25, 0x01	; 1
    1ace:	a1 f0       	breq	.+40     	; 0x1af8 <__addsf3x+0x96>
    1ad0:	ff 0f       	add	r31, r31
    1ad2:	bb 1f       	adc	r27, r27
    1ad4:	66 1f       	adc	r22, r22
    1ad6:	77 1f       	adc	r23, r23
    1ad8:	88 1f       	adc	r24, r24
    1ada:	c2 f7       	brpl	.-16     	; 0x1acc <__addsf3x+0x6a>
    1adc:	0e c0       	rjmp	.+28     	; 0x1afa <__addsf3x+0x98>
    1ade:	ba 0f       	add	r27, r26
    1ae0:	62 1f       	adc	r22, r18
    1ae2:	73 1f       	adc	r23, r19
    1ae4:	84 1f       	adc	r24, r20
    1ae6:	48 f4       	brcc	.+18     	; 0x1afa <__addsf3x+0x98>
    1ae8:	87 95       	ror	r24
    1aea:	77 95       	ror	r23
    1aec:	67 95       	ror	r22
    1aee:	b7 95       	ror	r27
    1af0:	f7 95       	ror	r31
    1af2:	9e 3f       	cpi	r25, 0xFE	; 254
    1af4:	08 f0       	brcs	.+2      	; 0x1af8 <__addsf3x+0x96>
    1af6:	b3 cf       	rjmp	.-154    	; 0x1a5e <__addsf3+0x1e>
    1af8:	93 95       	inc	r25
    1afa:	88 0f       	add	r24, r24
    1afc:	08 f0       	brcs	.+2      	; 0x1b00 <__addsf3x+0x9e>
    1afe:	99 27       	eor	r25, r25
    1b00:	ee 0f       	add	r30, r30
    1b02:	97 95       	ror	r25
    1b04:	87 95       	ror	r24
    1b06:	08 95       	ret

00001b08 <__divsf3>:
    1b08:	0c d0       	rcall	.+24     	; 0x1b22 <__divsf3x>
    1b0a:	e6 c0       	rjmp	.+460    	; 0x1cd8 <__fp_round>
    1b0c:	de d0       	rcall	.+444    	; 0x1cca <__fp_pscB>
    1b0e:	40 f0       	brcs	.+16     	; 0x1b20 <__divsf3+0x18>
    1b10:	d5 d0       	rcall	.+426    	; 0x1cbc <__fp_pscA>
    1b12:	30 f0       	brcs	.+12     	; 0x1b20 <__divsf3+0x18>
    1b14:	21 f4       	brne	.+8      	; 0x1b1e <__divsf3+0x16>
    1b16:	5f 3f       	cpi	r21, 0xFF	; 255
    1b18:	19 f0       	breq	.+6      	; 0x1b20 <__divsf3+0x18>
    1b1a:	c7 c0       	rjmp	.+398    	; 0x1caa <__fp_inf>
    1b1c:	51 11       	cpse	r21, r1
    1b1e:	10 c1       	rjmp	.+544    	; 0x1d40 <__fp_szero>
    1b20:	ca c0       	rjmp	.+404    	; 0x1cb6 <__fp_nan>

00001b22 <__divsf3x>:
    1b22:	eb d0       	rcall	.+470    	; 0x1cfa <__fp_split3>
    1b24:	98 f3       	brcs	.-26     	; 0x1b0c <__divsf3+0x4>

00001b26 <__divsf3_pse>:
    1b26:	99 23       	and	r25, r25
    1b28:	c9 f3       	breq	.-14     	; 0x1b1c <__divsf3+0x14>
    1b2a:	55 23       	and	r21, r21
    1b2c:	b1 f3       	breq	.-20     	; 0x1b1a <__divsf3+0x12>
    1b2e:	95 1b       	sub	r25, r21
    1b30:	55 0b       	sbc	r21, r21
    1b32:	bb 27       	eor	r27, r27
    1b34:	aa 27       	eor	r26, r26
    1b36:	62 17       	cp	r22, r18
    1b38:	73 07       	cpc	r23, r19
    1b3a:	84 07       	cpc	r24, r20
    1b3c:	38 f0       	brcs	.+14     	; 0x1b4c <__divsf3_pse+0x26>
    1b3e:	9f 5f       	subi	r25, 0xFF	; 255
    1b40:	5f 4f       	sbci	r21, 0xFF	; 255
    1b42:	22 0f       	add	r18, r18
    1b44:	33 1f       	adc	r19, r19
    1b46:	44 1f       	adc	r20, r20
    1b48:	aa 1f       	adc	r26, r26
    1b4a:	a9 f3       	breq	.-22     	; 0x1b36 <__divsf3_pse+0x10>
    1b4c:	33 d0       	rcall	.+102    	; 0x1bb4 <__divsf3_pse+0x8e>
    1b4e:	0e 2e       	mov	r0, r30
    1b50:	3a f0       	brmi	.+14     	; 0x1b60 <__divsf3_pse+0x3a>
    1b52:	e0 e8       	ldi	r30, 0x80	; 128
    1b54:	30 d0       	rcall	.+96     	; 0x1bb6 <__divsf3_pse+0x90>
    1b56:	91 50       	subi	r25, 0x01	; 1
    1b58:	50 40       	sbci	r21, 0x00	; 0
    1b5a:	e6 95       	lsr	r30
    1b5c:	00 1c       	adc	r0, r0
    1b5e:	ca f7       	brpl	.-14     	; 0x1b52 <__divsf3_pse+0x2c>
    1b60:	29 d0       	rcall	.+82     	; 0x1bb4 <__divsf3_pse+0x8e>
    1b62:	fe 2f       	mov	r31, r30
    1b64:	27 d0       	rcall	.+78     	; 0x1bb4 <__divsf3_pse+0x8e>
    1b66:	66 0f       	add	r22, r22
    1b68:	77 1f       	adc	r23, r23
    1b6a:	88 1f       	adc	r24, r24
    1b6c:	bb 1f       	adc	r27, r27
    1b6e:	26 17       	cp	r18, r22
    1b70:	37 07       	cpc	r19, r23
    1b72:	48 07       	cpc	r20, r24
    1b74:	ab 07       	cpc	r26, r27
    1b76:	b0 e8       	ldi	r27, 0x80	; 128
    1b78:	09 f0       	breq	.+2      	; 0x1b7c <__divsf3_pse+0x56>
    1b7a:	bb 0b       	sbc	r27, r27
    1b7c:	80 2d       	mov	r24, r0
    1b7e:	bf 01       	movw	r22, r30
    1b80:	ff 27       	eor	r31, r31
    1b82:	93 58       	subi	r25, 0x83	; 131
    1b84:	5f 4f       	sbci	r21, 0xFF	; 255
    1b86:	2a f0       	brmi	.+10     	; 0x1b92 <__divsf3_pse+0x6c>
    1b88:	9e 3f       	cpi	r25, 0xFE	; 254
    1b8a:	51 05       	cpc	r21, r1
    1b8c:	68 f0       	brcs	.+26     	; 0x1ba8 <__divsf3_pse+0x82>
    1b8e:	8d c0       	rjmp	.+282    	; 0x1caa <__fp_inf>
    1b90:	d7 c0       	rjmp	.+430    	; 0x1d40 <__fp_szero>
    1b92:	5f 3f       	cpi	r21, 0xFF	; 255
    1b94:	ec f3       	brlt	.-6      	; 0x1b90 <__divsf3_pse+0x6a>
    1b96:	98 3e       	cpi	r25, 0xE8	; 232
    1b98:	dc f3       	brlt	.-10     	; 0x1b90 <__divsf3_pse+0x6a>
    1b9a:	86 95       	lsr	r24
    1b9c:	77 95       	ror	r23
    1b9e:	67 95       	ror	r22
    1ba0:	b7 95       	ror	r27
    1ba2:	f7 95       	ror	r31
    1ba4:	9f 5f       	subi	r25, 0xFF	; 255
    1ba6:	c9 f7       	brne	.-14     	; 0x1b9a <__divsf3_pse+0x74>
    1ba8:	88 0f       	add	r24, r24
    1baa:	91 1d       	adc	r25, r1
    1bac:	96 95       	lsr	r25
    1bae:	87 95       	ror	r24
    1bb0:	97 f9       	bld	r25, 7
    1bb2:	08 95       	ret
    1bb4:	e1 e0       	ldi	r30, 0x01	; 1
    1bb6:	66 0f       	add	r22, r22
    1bb8:	77 1f       	adc	r23, r23
    1bba:	88 1f       	adc	r24, r24
    1bbc:	bb 1f       	adc	r27, r27
    1bbe:	62 17       	cp	r22, r18
    1bc0:	73 07       	cpc	r23, r19
    1bc2:	84 07       	cpc	r24, r20
    1bc4:	ba 07       	cpc	r27, r26
    1bc6:	20 f0       	brcs	.+8      	; 0x1bd0 <__divsf3_pse+0xaa>
    1bc8:	62 1b       	sub	r22, r18
    1bca:	73 0b       	sbc	r23, r19
    1bcc:	84 0b       	sbc	r24, r20
    1bce:	ba 0b       	sbc	r27, r26
    1bd0:	ee 1f       	adc	r30, r30
    1bd2:	88 f7       	brcc	.-30     	; 0x1bb6 <__divsf3_pse+0x90>
    1bd4:	e0 95       	com	r30
    1bd6:	08 95       	ret

00001bd8 <__fixunssfsi>:
    1bd8:	98 d0       	rcall	.+304    	; 0x1d0a <__fp_splitA>
    1bda:	88 f0       	brcs	.+34     	; 0x1bfe <__fixunssfsi+0x26>
    1bdc:	9f 57       	subi	r25, 0x7F	; 127
    1bde:	90 f0       	brcs	.+36     	; 0x1c04 <__fixunssfsi+0x2c>
    1be0:	b9 2f       	mov	r27, r25
    1be2:	99 27       	eor	r25, r25
    1be4:	b7 51       	subi	r27, 0x17	; 23
    1be6:	a0 f0       	brcs	.+40     	; 0x1c10 <__fixunssfsi+0x38>
    1be8:	d1 f0       	breq	.+52     	; 0x1c1e <__fixunssfsi+0x46>
    1bea:	66 0f       	add	r22, r22
    1bec:	77 1f       	adc	r23, r23
    1bee:	88 1f       	adc	r24, r24
    1bf0:	99 1f       	adc	r25, r25
    1bf2:	1a f0       	brmi	.+6      	; 0x1bfa <__fixunssfsi+0x22>
    1bf4:	ba 95       	dec	r27
    1bf6:	c9 f7       	brne	.-14     	; 0x1bea <__fixunssfsi+0x12>
    1bf8:	12 c0       	rjmp	.+36     	; 0x1c1e <__fixunssfsi+0x46>
    1bfa:	b1 30       	cpi	r27, 0x01	; 1
    1bfc:	81 f0       	breq	.+32     	; 0x1c1e <__fixunssfsi+0x46>
    1bfe:	9f d0       	rcall	.+318    	; 0x1d3e <__fp_zero>
    1c00:	b1 e0       	ldi	r27, 0x01	; 1
    1c02:	08 95       	ret
    1c04:	9c c0       	rjmp	.+312    	; 0x1d3e <__fp_zero>
    1c06:	67 2f       	mov	r22, r23
    1c08:	78 2f       	mov	r23, r24
    1c0a:	88 27       	eor	r24, r24
    1c0c:	b8 5f       	subi	r27, 0xF8	; 248
    1c0e:	39 f0       	breq	.+14     	; 0x1c1e <__fixunssfsi+0x46>
    1c10:	b9 3f       	cpi	r27, 0xF9	; 249
    1c12:	cc f3       	brlt	.-14     	; 0x1c06 <__fixunssfsi+0x2e>
    1c14:	86 95       	lsr	r24
    1c16:	77 95       	ror	r23
    1c18:	67 95       	ror	r22
    1c1a:	b3 95       	inc	r27
    1c1c:	d9 f7       	brne	.-10     	; 0x1c14 <__fixunssfsi+0x3c>
    1c1e:	3e f4       	brtc	.+14     	; 0x1c2e <__fixunssfsi+0x56>
    1c20:	90 95       	com	r25
    1c22:	80 95       	com	r24
    1c24:	70 95       	com	r23
    1c26:	61 95       	neg	r22
    1c28:	7f 4f       	sbci	r23, 0xFF	; 255
    1c2a:	8f 4f       	sbci	r24, 0xFF	; 255
    1c2c:	9f 4f       	sbci	r25, 0xFF	; 255
    1c2e:	08 95       	ret

00001c30 <__floatunsisf>:
    1c30:	e8 94       	clt
    1c32:	09 c0       	rjmp	.+18     	; 0x1c46 <__floatsisf+0x12>

00001c34 <__floatsisf>:
    1c34:	97 fb       	bst	r25, 7
    1c36:	3e f4       	brtc	.+14     	; 0x1c46 <__floatsisf+0x12>
    1c38:	90 95       	com	r25
    1c3a:	80 95       	com	r24
    1c3c:	70 95       	com	r23
    1c3e:	61 95       	neg	r22
    1c40:	7f 4f       	sbci	r23, 0xFF	; 255
    1c42:	8f 4f       	sbci	r24, 0xFF	; 255
    1c44:	9f 4f       	sbci	r25, 0xFF	; 255
    1c46:	99 23       	and	r25, r25
    1c48:	a9 f0       	breq	.+42     	; 0x1c74 <__floatsisf+0x40>
    1c4a:	f9 2f       	mov	r31, r25
    1c4c:	96 e9       	ldi	r25, 0x96	; 150
    1c4e:	bb 27       	eor	r27, r27
    1c50:	93 95       	inc	r25
    1c52:	f6 95       	lsr	r31
    1c54:	87 95       	ror	r24
    1c56:	77 95       	ror	r23
    1c58:	67 95       	ror	r22
    1c5a:	b7 95       	ror	r27
    1c5c:	f1 11       	cpse	r31, r1
    1c5e:	f8 cf       	rjmp	.-16     	; 0x1c50 <__floatsisf+0x1c>
    1c60:	fa f4       	brpl	.+62     	; 0x1ca0 <__floatsisf+0x6c>
    1c62:	bb 0f       	add	r27, r27
    1c64:	11 f4       	brne	.+4      	; 0x1c6a <__floatsisf+0x36>
    1c66:	60 ff       	sbrs	r22, 0
    1c68:	1b c0       	rjmp	.+54     	; 0x1ca0 <__floatsisf+0x6c>
    1c6a:	6f 5f       	subi	r22, 0xFF	; 255
    1c6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c6e:	8f 4f       	sbci	r24, 0xFF	; 255
    1c70:	9f 4f       	sbci	r25, 0xFF	; 255
    1c72:	16 c0       	rjmp	.+44     	; 0x1ca0 <__floatsisf+0x6c>
    1c74:	88 23       	and	r24, r24
    1c76:	11 f0       	breq	.+4      	; 0x1c7c <__floatsisf+0x48>
    1c78:	96 e9       	ldi	r25, 0x96	; 150
    1c7a:	11 c0       	rjmp	.+34     	; 0x1c9e <__floatsisf+0x6a>
    1c7c:	77 23       	and	r23, r23
    1c7e:	21 f0       	breq	.+8      	; 0x1c88 <__floatsisf+0x54>
    1c80:	9e e8       	ldi	r25, 0x8E	; 142
    1c82:	87 2f       	mov	r24, r23
    1c84:	76 2f       	mov	r23, r22
    1c86:	05 c0       	rjmp	.+10     	; 0x1c92 <__floatsisf+0x5e>
    1c88:	66 23       	and	r22, r22
    1c8a:	71 f0       	breq	.+28     	; 0x1ca8 <__floatsisf+0x74>
    1c8c:	96 e8       	ldi	r25, 0x86	; 134
    1c8e:	86 2f       	mov	r24, r22
    1c90:	70 e0       	ldi	r23, 0x00	; 0
    1c92:	60 e0       	ldi	r22, 0x00	; 0
    1c94:	2a f0       	brmi	.+10     	; 0x1ca0 <__floatsisf+0x6c>
    1c96:	9a 95       	dec	r25
    1c98:	66 0f       	add	r22, r22
    1c9a:	77 1f       	adc	r23, r23
    1c9c:	88 1f       	adc	r24, r24
    1c9e:	da f7       	brpl	.-10     	; 0x1c96 <__floatsisf+0x62>
    1ca0:	88 0f       	add	r24, r24
    1ca2:	96 95       	lsr	r25
    1ca4:	87 95       	ror	r24
    1ca6:	97 f9       	bld	r25, 7
    1ca8:	08 95       	ret

00001caa <__fp_inf>:
    1caa:	97 f9       	bld	r25, 7
    1cac:	9f 67       	ori	r25, 0x7F	; 127
    1cae:	80 e8       	ldi	r24, 0x80	; 128
    1cb0:	70 e0       	ldi	r23, 0x00	; 0
    1cb2:	60 e0       	ldi	r22, 0x00	; 0
    1cb4:	08 95       	ret

00001cb6 <__fp_nan>:
    1cb6:	9f ef       	ldi	r25, 0xFF	; 255
    1cb8:	80 ec       	ldi	r24, 0xC0	; 192
    1cba:	08 95       	ret

00001cbc <__fp_pscA>:
    1cbc:	00 24       	eor	r0, r0
    1cbe:	0a 94       	dec	r0
    1cc0:	16 16       	cp	r1, r22
    1cc2:	17 06       	cpc	r1, r23
    1cc4:	18 06       	cpc	r1, r24
    1cc6:	09 06       	cpc	r0, r25
    1cc8:	08 95       	ret

00001cca <__fp_pscB>:
    1cca:	00 24       	eor	r0, r0
    1ccc:	0a 94       	dec	r0
    1cce:	12 16       	cp	r1, r18
    1cd0:	13 06       	cpc	r1, r19
    1cd2:	14 06       	cpc	r1, r20
    1cd4:	05 06       	cpc	r0, r21
    1cd6:	08 95       	ret

00001cd8 <__fp_round>:
    1cd8:	09 2e       	mov	r0, r25
    1cda:	03 94       	inc	r0
    1cdc:	00 0c       	add	r0, r0
    1cde:	11 f4       	brne	.+4      	; 0x1ce4 <__fp_round+0xc>
    1ce0:	88 23       	and	r24, r24
    1ce2:	52 f0       	brmi	.+20     	; 0x1cf8 <__fp_round+0x20>
    1ce4:	bb 0f       	add	r27, r27
    1ce6:	40 f4       	brcc	.+16     	; 0x1cf8 <__fp_round+0x20>
    1ce8:	bf 2b       	or	r27, r31
    1cea:	11 f4       	brne	.+4      	; 0x1cf0 <__fp_round+0x18>
    1cec:	60 ff       	sbrs	r22, 0
    1cee:	04 c0       	rjmp	.+8      	; 0x1cf8 <__fp_round+0x20>
    1cf0:	6f 5f       	subi	r22, 0xFF	; 255
    1cf2:	7f 4f       	sbci	r23, 0xFF	; 255
    1cf4:	8f 4f       	sbci	r24, 0xFF	; 255
    1cf6:	9f 4f       	sbci	r25, 0xFF	; 255
    1cf8:	08 95       	ret

00001cfa <__fp_split3>:
    1cfa:	57 fd       	sbrc	r21, 7
    1cfc:	90 58       	subi	r25, 0x80	; 128
    1cfe:	44 0f       	add	r20, r20
    1d00:	55 1f       	adc	r21, r21
    1d02:	59 f0       	breq	.+22     	; 0x1d1a <__fp_splitA+0x10>
    1d04:	5f 3f       	cpi	r21, 0xFF	; 255
    1d06:	71 f0       	breq	.+28     	; 0x1d24 <__fp_splitA+0x1a>
    1d08:	47 95       	ror	r20

00001d0a <__fp_splitA>:
    1d0a:	88 0f       	add	r24, r24
    1d0c:	97 fb       	bst	r25, 7
    1d0e:	99 1f       	adc	r25, r25
    1d10:	61 f0       	breq	.+24     	; 0x1d2a <__fp_splitA+0x20>
    1d12:	9f 3f       	cpi	r25, 0xFF	; 255
    1d14:	79 f0       	breq	.+30     	; 0x1d34 <__fp_splitA+0x2a>
    1d16:	87 95       	ror	r24
    1d18:	08 95       	ret
    1d1a:	12 16       	cp	r1, r18
    1d1c:	13 06       	cpc	r1, r19
    1d1e:	14 06       	cpc	r1, r20
    1d20:	55 1f       	adc	r21, r21
    1d22:	f2 cf       	rjmp	.-28     	; 0x1d08 <__fp_split3+0xe>
    1d24:	46 95       	lsr	r20
    1d26:	f1 df       	rcall	.-30     	; 0x1d0a <__fp_splitA>
    1d28:	08 c0       	rjmp	.+16     	; 0x1d3a <__fp_splitA+0x30>
    1d2a:	16 16       	cp	r1, r22
    1d2c:	17 06       	cpc	r1, r23
    1d2e:	18 06       	cpc	r1, r24
    1d30:	99 1f       	adc	r25, r25
    1d32:	f1 cf       	rjmp	.-30     	; 0x1d16 <__fp_splitA+0xc>
    1d34:	86 95       	lsr	r24
    1d36:	71 05       	cpc	r23, r1
    1d38:	61 05       	cpc	r22, r1
    1d3a:	08 94       	sec
    1d3c:	08 95       	ret

00001d3e <__fp_zero>:
    1d3e:	e8 94       	clt

00001d40 <__fp_szero>:
    1d40:	bb 27       	eor	r27, r27
    1d42:	66 27       	eor	r22, r22
    1d44:	77 27       	eor	r23, r23
    1d46:	cb 01       	movw	r24, r22
    1d48:	97 f9       	bld	r25, 7
    1d4a:	08 95       	ret

00001d4c <__divmodhi4>:
    1d4c:	97 fb       	bst	r25, 7
    1d4e:	09 2e       	mov	r0, r25
    1d50:	07 26       	eor	r0, r23
    1d52:	0a d0       	rcall	.+20     	; 0x1d68 <__divmodhi4_neg1>
    1d54:	77 fd       	sbrc	r23, 7
    1d56:	04 d0       	rcall	.+8      	; 0x1d60 <__divmodhi4_neg2>
    1d58:	0c d0       	rcall	.+24     	; 0x1d72 <__udivmodhi4>
    1d5a:	06 d0       	rcall	.+12     	; 0x1d68 <__divmodhi4_neg1>
    1d5c:	00 20       	and	r0, r0
    1d5e:	1a f4       	brpl	.+6      	; 0x1d66 <__divmodhi4_exit>

00001d60 <__divmodhi4_neg2>:
    1d60:	70 95       	com	r23
    1d62:	61 95       	neg	r22
    1d64:	7f 4f       	sbci	r23, 0xFF	; 255

00001d66 <__divmodhi4_exit>:
    1d66:	08 95       	ret

00001d68 <__divmodhi4_neg1>:
    1d68:	f6 f7       	brtc	.-4      	; 0x1d66 <__divmodhi4_exit>
    1d6a:	90 95       	com	r25
    1d6c:	81 95       	neg	r24
    1d6e:	9f 4f       	sbci	r25, 0xFF	; 255
    1d70:	08 95       	ret

00001d72 <__udivmodhi4>:
    1d72:	aa 1b       	sub	r26, r26
    1d74:	bb 1b       	sub	r27, r27
    1d76:	51 e1       	ldi	r21, 0x11	; 17
    1d78:	07 c0       	rjmp	.+14     	; 0x1d88 <__udivmodhi4_ep>

00001d7a <__udivmodhi4_loop>:
    1d7a:	aa 1f       	adc	r26, r26
    1d7c:	bb 1f       	adc	r27, r27
    1d7e:	a6 17       	cp	r26, r22
    1d80:	b7 07       	cpc	r27, r23
    1d82:	10 f0       	brcs	.+4      	; 0x1d88 <__udivmodhi4_ep>
    1d84:	a6 1b       	sub	r26, r22
    1d86:	b7 0b       	sbc	r27, r23

00001d88 <__udivmodhi4_ep>:
    1d88:	88 1f       	adc	r24, r24
    1d8a:	99 1f       	adc	r25, r25
    1d8c:	5a 95       	dec	r21
    1d8e:	a9 f7       	brne	.-22     	; 0x1d7a <__udivmodhi4_loop>
    1d90:	80 95       	com	r24
    1d92:	90 95       	com	r25
    1d94:	bc 01       	movw	r22, r24
    1d96:	cd 01       	movw	r24, r26
    1d98:	08 95       	ret

00001d9a <_exit>:
    1d9a:	f8 94       	cli

00001d9c <__stop_program>:
    1d9c:	ff cf       	rjmp	.-2      	; 0x1d9c <__stop_program>
