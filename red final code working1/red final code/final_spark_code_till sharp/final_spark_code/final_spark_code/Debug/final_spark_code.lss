
final_spark_code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001f12  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000a  00800060  00001f12  00001fa6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000a9  0080006a  0080006a  00001fb0  2**0
                  ALLOC
  3 .stab         00001be4  00000000  00000000  00001fb0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000583  00000000  00000000  00003b94  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00004118  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002c8d  00000000  00000000  000041d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000479  00000000  00000000  00006e65  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000cd4  00000000  00000000  000072de  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000854  00000000  00000000  00007fb4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000008fb  00000000  00000000  00008808  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000023e7  00000000  00000000  00009103  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000108  00000000  00000000  0000b4ea  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 d1 02 	jmp	0x5a2	; 0x5a2 <__vector_1>
       8:	0c 94 f6 02 	jmp	0x5ec	; 0x5ec <__vector_2>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 bc 07 	jmp	0xf78	; 0xf78 <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 64 09 	jmp	0x12c8	; 0x12c8 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e1       	ldi	r30, 0x12	; 18
      68:	ff e1       	ldi	r31, 0x1F	; 31
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 36       	cpi	r26, 0x6A	; 106
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	aa e6       	ldi	r26, 0x6A	; 106
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 31       	cpi	r26, 0x13	; 19
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ce 0c 	call	0x199c	; 0x199c <main>
      8a:	0c 94 87 0f 	jmp	0x1f0e	; 0x1f0e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <do_task>:
		green_side[i]=0;
	}
}
void do_task()
{	
	if(task==1)//red
      92:	80 91 75 00 	lds	r24, 0x0075
      96:	81 30       	cpi	r24, 0x01	; 1
      98:	09 f5       	brne	.+66     	; 0xdc <do_task+0x4a>
      9a:	87 e9       	ldi	r24, 0x97	; 151
      9c:	90 e0       	ldi	r25, 0x00	; 0
	{	
		for(int i=0;i<=150;i++)   //back
		{
			PORTB=PORTB|0x20;//0010 0000 pb5
      9e:	c5 9a       	sbi	0x18, 5	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      a0:	e9 e9       	ldi	r30, 0x99	; 153
      a2:	f3 e0       	ldi	r31, 0x03	; 3
      a4:	31 97       	sbiw	r30, 0x01	; 1
      a6:	f1 f7       	brne	.-4      	; 0xa4 <do_task+0x12>
      a8:	00 c0       	rjmp	.+0      	; 0xaa <do_task+0x18>
			_delay_ms(0.5);
			PORTB=PORTB & 0xDF;//1101 1111
      aa:	c5 98       	cbi	0x18, 5	; 24
      ac:	e6 e6       	ldi	r30, 0x66	; 102
      ae:	fc e8       	ldi	r31, 0x8C	; 140
      b0:	31 97       	sbiw	r30, 0x01	; 1
      b2:	f1 f7       	brne	.-4      	; 0xb0 <do_task+0x1e>
      b4:	00 00       	nop
      b6:	01 97       	sbiw	r24, 0x01	; 1
}
void do_task()
{	
	if(task==1)//red
	{	
		for(int i=0;i<=150;i++)   //back
      b8:	91 f7       	brne	.-28     	; 0x9e <do_task+0xc>
      ba:	87 e9       	ldi	r24, 0x97	; 151
      bc:	90 e0       	ldi	r25, 0x00	; 0
		}


		for(int i=0;i<=150;i++)  //front
		{
			PORTB=PORTB|0x20;//0010 0000 pb5
      be:	c5 9a       	sbi	0x18, 5	; 24
      c0:	ee e1       	ldi	r30, 0x1E	; 30
      c2:	f6 e0       	ldi	r31, 0x06	; 6
      c4:	31 97       	sbiw	r30, 0x01	; 1
      c6:	f1 f7       	brne	.-4      	; 0xc4 <do_task+0x32>
      c8:	00 c0       	rjmp	.+0      	; 0xca <do_task+0x38>
			_delay_ms(0.85);
			PORTB=PORTB & 0xDF;//1101 1111
      ca:	c5 98       	cbi	0x18, 5	; 24
      cc:	e1 ee       	ldi	r30, 0xE1	; 225
      ce:	f9 e8       	ldi	r31, 0x89	; 137
      d0:	31 97       	sbiw	r30, 0x01	; 1
      d2:	f1 f7       	brne	.-4      	; 0xd0 <do_task+0x3e>
      d4:	00 00       	nop
      d6:	01 97       	sbiw	r24, 0x01	; 1
			_delay_ms(19.5);
			
		}


		for(int i=0;i<=150;i++)  //front
      d8:	91 f7       	brne	.-28     	; 0xbe <do_task+0x2c>
      da:	1f c0       	rjmp	.+62     	; 0x11a <do_task+0x88>
			
		}
		
		
	}
	else if(task==2)//green
      dc:	82 30       	cpi	r24, 0x02	; 2
      de:	e9 f4       	brne	.+58     	; 0x11a <do_task+0x88>
	{
		green_nodes[gn]=path1.path[t];
      e0:	90 91 62 00 	lds	r25, 0x0062
      e4:	80 91 76 00 	lds	r24, 0x0076
      e8:	e8 ec       	ldi	r30, 0xC8	; 200
      ea:	f0 e0       	ldi	r31, 0x00	; 0
      ec:	e8 0f       	add	r30, r24
      ee:	f1 1d       	adc	r31, r1
      f0:	80 81       	ld	r24, Z
      f2:	e2 e8       	ldi	r30, 0x82	; 130
      f4:	f0 e0       	ldi	r31, 0x00	; 0
      f6:	e9 0f       	add	r30, r25
      f8:	f1 1d       	adc	r31, r1
      fa:	80 83       	st	Z, r24
		green_side[gs]=side;
      fc:	80 91 61 00 	lds	r24, 0x0061
     100:	20 91 74 00 	lds	r18, 0x0074
     104:	e0 ea       	ldi	r30, 0xA0	; 160
     106:	f0 e0       	ldi	r31, 0x00	; 0
     108:	e8 0f       	add	r30, r24
     10a:	f1 1d       	adc	r31, r1
     10c:	20 83       	st	Z, r18
		gn++;
     10e:	9f 5f       	subi	r25, 0xFF	; 255
     110:	90 93 62 00 	sts	0x0062, r25
		gs++;
     114:	8f 5f       	subi	r24, 0xFF	; 255
     116:	80 93 61 00 	sts	0x0061, r24
		
	}
	if(task==3)
     11a:	80 91 75 00 	lds	r24, 0x0075
     11e:	83 30       	cpi	r24, 0x03	; 3
     120:	09 f5       	brne	.+66     	; 0x164 <do_task+0xd2>
	{
		blue_nodes[r]=path1.path[t];
     122:	90 91 73 00 	lds	r25, 0x0073
     126:	80 91 76 00 	lds	r24, 0x0076
     12a:	e8 ec       	ldi	r30, 0xC8	; 200
     12c:	f0 e0       	ldi	r31, 0x00	; 0
     12e:	e8 0f       	add	r30, r24
     130:	f1 1d       	adc	r31, r1
     132:	80 81       	ld	r24, Z
     134:	ee e8       	ldi	r30, 0x8E	; 142
     136:	f0 e0       	ldi	r31, 0x00	; 0
     138:	e9 0f       	add	r30, r25
     13a:	f1 1d       	adc	r31, r1
     13c:	80 83       	st	Z, r24
		blue_side[rs]=side;
     13e:	90 91 72 00 	lds	r25, 0x0072
     142:	80 91 74 00 	lds	r24, 0x0074
     146:	ec ea       	ldi	r30, 0xAC	; 172
     148:	f0 e0       	ldi	r31, 0x00	; 0
     14a:	e9 0f       	add	r30, r25
     14c:	f1 1d       	adc	r31, r1
     14e:	80 83       	st	Z, r24
		b++;
     150:	80 91 64 00 	lds	r24, 0x0064
     154:	8f 5f       	subi	r24, 0xFF	; 255
     156:	80 93 64 00 	sts	0x0064, r24
		bs++;
     15a:	80 91 63 00 	lds	r24, 0x0063
     15e:	8f 5f       	subi	r24, 0xFF	; 255
     160:	80 93 63 00 	sts	0x0063, r24
	}
	if(red_side[0]==1 && red_side[1]==1)
	{
		buzzer_beep();
	}*/
	task=0;
     164:	10 92 75 00 	sts	0x0075, r1
	side=0;
     168:	10 92 74 00 	sts	0x0074, r1
	PORTC=PORTC& 0x8F;
     16c:	85 b3       	in	r24, 0x15	; 21
     16e:	8f 78       	andi	r24, 0x8F	; 143
     170:	85 bb       	out	0x15, r24	; 21
	//buzzer_beep();
}
     172:	08 95       	ret

00000174 <buzzer_pin_config>:
#include <util/delay.h>

//Function to initialize Buzzer 
void buzzer_pin_config (void)
{
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     174:	a3 9a       	sbi	0x14, 3	; 20
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     176:	ab 98       	cbi	0x15, 3	; 21
}
     178:	08 95       	ret

0000017a <port_init_buzzer>:

void port_init_buzzer (void)
{
 buzzer_pin_config();
     17a:	0e 94 ba 00 	call	0x174	; 0x174 <buzzer_pin_config>
}
     17e:	08 95       	ret

00000180 <buzzer_on>:

void buzzer_on (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     180:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore | 0x08;
     182:	88 60       	ori	r24, 0x08	; 8
 PORTC = port_restore;
     184:	85 bb       	out	0x15, r24	; 21
}
     186:	08 95       	ret

00000188 <buzzer_off>:

void buzzer_off (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
     188:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore & 0xF7;
     18a:	87 7f       	andi	r24, 0xF7	; 247
 PORTC = port_restore;
     18c:	85 bb       	out	0x15, r24	; 21
}
     18e:	08 95       	ret

00000190 <buzzer_beep>:
void buzzer_beep()
{
	buzzer_on();
     190:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
     194:	8f ef       	ldi	r24, 0xFF	; 255
     196:	9f e7       	ldi	r25, 0x7F	; 127
     198:	a4 e0       	ldi	r26, 0x04	; 4
     19a:	81 50       	subi	r24, 0x01	; 1
     19c:	90 40       	sbci	r25, 0x00	; 0
     19e:	a0 40       	sbci	r26, 0x00	; 0
     1a0:	e1 f7       	brne	.-8      	; 0x19a <buzzer_beep+0xa>
     1a2:	00 c0       	rjmp	.+0      	; 0x1a4 <buzzer_beep+0x14>
     1a4:	00 00       	nop
	_delay_ms(200);
	buzzer_off();
     1a6:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
     1aa:	8f ef       	ldi	r24, 0xFF	; 255
     1ac:	9f e7       	ldi	r25, 0x7F	; 127
     1ae:	a4 e0       	ldi	r26, 0x04	; 4
     1b0:	81 50       	subi	r24, 0x01	; 1
     1b2:	90 40       	sbci	r25, 0x00	; 0
     1b4:	a0 40       	sbci	r26, 0x00	; 0
     1b6:	e1 f7       	brne	.-8      	; 0x1b0 <buzzer_beep+0x20>
     1b8:	00 c0       	rjmp	.+0      	; 0x1ba <buzzer_beep+0x2a>
     1ba:	00 00       	nop
	_delay_ms(200);
}
     1bc:	08 95       	ret

000001be <init_devices_buzzer>:
void init_devices_buzzer (void)
{
 cli(); 			//Clears the global interrupts
     1be:	f8 94       	cli
 port_init_buzzer();
     1c0:	0e 94 bd 00 	call	0x17a	; 0x17a <port_init_buzzer>
 sei(); 			//Enables the global interrupts
     1c4:	78 94       	sei
}
     1c6:	08 95       	ret

000001c8 <main_function7>:




struct Path_Array main_function7(unsigned char start, unsigned char finish)
{
     1c8:	cf 92       	push	r12
     1ca:	df 92       	push	r13
     1cc:	ef 92       	push	r14
     1ce:	ff 92       	push	r15
     1d0:	0f 93       	push	r16
     1d2:	1f 93       	push	r17
     1d4:	cf 93       	push	r28
     1d6:	df 93       	push	r29
     1d8:	cd b7       	in	r28, 0x3d	; 61
     1da:	de b7       	in	r29, 0x3e	; 62
     1dc:	2f 97       	sbiw	r28, 0x0f	; 15
     1de:	0f b6       	in	r0, 0x3f	; 63
     1e0:	f8 94       	cli
     1e2:	de bf       	out	0x3e, r29	; 62
     1e4:	0f be       	out	0x3f, r0	; 63
     1e6:	cd bf       	out	0x3d, r28	; 61
     1e8:	08 2f       	mov	r16, r24
     1ea:	f9 2e       	mov	r15, r25
     1ec:	26 2f       	mov	r18, r22
	struct Path_Array path;
unsigned char friend; 
signed char k =(((start-1)/7)-((finish-1)/7));
     1ee:	c4 2e       	mov	r12, r20
     1f0:	dd 24       	eor	r13, r13
     1f2:	86 2f       	mov	r24, r22
     1f4:	90 e0       	ldi	r25, 0x00	; 0
     1f6:	01 97       	sbiw	r24, 0x01	; 1
     1f8:	e7 e0       	ldi	r30, 0x07	; 7
     1fa:	f0 e0       	ldi	r31, 0x00	; 0
     1fc:	bf 01       	movw	r22, r30
     1fe:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <__divmodhi4>
     202:	36 2f       	mov	r19, r22
     204:	c6 01       	movw	r24, r12
     206:	01 97       	sbiw	r24, 0x01	; 1
     208:	bf 01       	movw	r22, r30
     20a:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <__divmodhi4>
     20e:	36 1b       	sub	r19, r22
     210:	53 2f       	mov	r21, r19
if(k>0)
     212:	13 16       	cp	r1, r19
     214:	3c f4       	brge	.+14     	; 0x224 <main_function7+0x5c>
{
	friend=((k*7)+finish);
     216:	13 2f       	mov	r17, r19
     218:	11 0f       	add	r17, r17
     21a:	11 0f       	add	r17, r17
     21c:	11 0f       	add	r17, r17
     21e:	13 1b       	sub	r17, r19
     220:	14 0f       	add	r17, r20
     222:	06 c0       	rjmp	.+12     	; 0x230 <main_function7+0x68>
}
else
{
	friend=(finish-(k*(-1))*7);
     224:	13 2f       	mov	r17, r19
     226:	11 0f       	add	r17, r17
     228:	11 0f       	add	r17, r17
     22a:	11 0f       	add	r17, r17
     22c:	13 1b       	sub	r17, r19
     22e:	14 0f       	add	r17, r20
}
signed char l=0;
unsigned char m=0;
 unsigned char st =start;
l=(friend - start);
     230:	31 2f       	mov	r19, r17
     232:	32 1b       	sub	r19, r18
     234:	e3 2e       	mov	r14, r19

if(l>0)
     236:	13 16       	cp	r1, r19
     238:	0c f0       	brlt	.+2      	; 0x23c <main_function7+0x74>
     23a:	ad c0       	rjmp	.+346    	; 0x396 <main_function7+0x1ce>
{
	for(unsigned char i = 0;i<=l;i++)
     23c:	e3 2f       	mov	r30, r19
     23e:	ff 27       	eor	r31, r31
     240:	e7 fd       	sbrc	r30, 7
     242:	f0 95       	com	r31
     244:	ff 23       	and	r31, r31
     246:	9c f0       	brlt	.+38     	; 0x26e <main_function7+0xa6>
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	60 e0       	ldi	r22, 0x00	; 0
	{path.path[i]=st;
     24e:	a1 e0       	ldi	r26, 0x01	; 1
     250:	b0 e0       	ldi	r27, 0x00	; 0
     252:	ac 0f       	add	r26, r28
     254:	bd 1f       	adc	r27, r29
     256:	8a 0f       	add	r24, r26
     258:	9b 1f       	adc	r25, r27
     25a:	76 2f       	mov	r23, r22
     25c:	72 0f       	add	r23, r18
     25e:	dc 01       	movw	r26, r24
     260:	7c 93       	st	X, r23
 unsigned char st =start;
l=(friend - start);

if(l>0)
{
	for(unsigned char i = 0;i<=l;i++)
     262:	6f 5f       	subi	r22, 0xFF	; 255
     264:	86 2f       	mov	r24, r22
     266:	90 e0       	ldi	r25, 0x00	; 0
     268:	e8 17       	cp	r30, r24
     26a:	f9 07       	cpc	r31, r25
     26c:	84 f7       	brge	.-32     	; 0x24e <main_function7+0x86>
	{path.path[i]=st;
	st++;
	}
	if(k>0)	
     26e:	15 16       	cp	r1, r21
     270:	0c f0       	brlt	.+2      	; 0x274 <main_function7+0xac>
     272:	47 c0       	rjmp	.+142    	; 0x302 <main_function7+0x13a>
	{   
		if(friend > finish)
     274:	41 17       	cp	r20, r17
     276:	18 f5       	brcc	.+70     	; 0x2be <main_function7+0xf6>
		{
			m=((friend-finish)/7);
     278:	81 2f       	mov	r24, r17
     27a:	90 e0       	ldi	r25, 0x00	; 0
     27c:	8c 19       	sub	r24, r12
     27e:	9d 09       	sbc	r25, r13
     280:	67 e0       	ldi	r22, 0x07	; 7
     282:	70 e0       	ldi	r23, 0x00	; 0
     284:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     288:	66 23       	and	r22, r22
     28a:	09 f4       	brne	.+2      	; 0x28e <main_function7+0xc6>
     28c:	34 c1       	rjmp	.+616    	; 0x4f6 <__stack+0x97>
     28e:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     290:	ec 0f       	add	r30, r28
     292:	fd 1f       	adc	r31, r29
     294:	32 96       	adiw	r30, 0x02	; 2
     296:	83 2f       	mov	r24, r19
     298:	99 27       	eor	r25, r25
     29a:	87 fd       	sbrc	r24, 7
     29c:	90 95       	com	r25
     29e:	23 e0       	ldi	r18, 0x03	; 3
     2a0:	30 e0       	ldi	r19, 0x00	; 0
     2a2:	2c 0f       	add	r18, r28
     2a4:	3d 1f       	adc	r19, r29
     2a6:	82 0f       	add	r24, r18
     2a8:	93 1f       	adc	r25, r19
     2aa:	26 2f       	mov	r18, r22
     2ac:	21 50       	subi	r18, 0x01	; 1
     2ae:	82 0f       	add	r24, r18
     2b0:	91 1d       	adc	r25, r1
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     2b2:	11 93       	st	Z+, r17
     2b4:	17 50       	subi	r17, 0x07	; 7
	if(k>0)	
	{   
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     2b6:	e8 17       	cp	r30, r24
     2b8:	f9 07       	cpc	r31, r25
     2ba:	d9 f7       	brne	.-10     	; 0x2b2 <main_function7+0xea>
     2bc:	1c c1       	rjmp	.+568    	; 0x4f6 <__stack+0x97>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     2be:	c6 01       	movw	r24, r12
     2c0:	81 1b       	sub	r24, r17
     2c2:	91 09       	sbc	r25, r1
     2c4:	67 e0       	ldi	r22, 0x07	; 7
     2c6:	70 e0       	ldi	r23, 0x00	; 0
     2c8:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     2cc:	66 23       	and	r22, r22
     2ce:	09 f4       	brne	.+2      	; 0x2d2 <main_function7+0x10a>
     2d0:	12 c1       	rjmp	.+548    	; 0x4f6 <__stack+0x97>
     2d2:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     2d4:	ec 0f       	add	r30, r28
     2d6:	fd 1f       	adc	r31, r29
     2d8:	32 96       	adiw	r30, 0x02	; 2
     2da:	83 2f       	mov	r24, r19
     2dc:	99 27       	eor	r25, r25
     2de:	87 fd       	sbrc	r24, 7
     2e0:	90 95       	com	r25
     2e2:	a3 e0       	ldi	r26, 0x03	; 3
     2e4:	b0 e0       	ldi	r27, 0x00	; 0
     2e6:	ac 0f       	add	r26, r28
     2e8:	bd 1f       	adc	r27, r29
     2ea:	8a 0f       	add	r24, r26
     2ec:	9b 1f       	adc	r25, r27
     2ee:	26 2f       	mov	r18, r22
     2f0:	21 50       	subi	r18, 0x01	; 1
     2f2:	82 0f       	add	r24, r18
     2f4:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     2f6:	11 93       	st	Z+, r17
     2f8:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     2fa:	e8 17       	cp	r30, r24
     2fc:	f9 07       	cpc	r31, r25
     2fe:	d9 f7       	brne	.-10     	; 0x2f6 <main_function7+0x12e>
     300:	fa c0       	rjmp	.+500    	; 0x4f6 <__stack+0x97>
				path.path[l+i+1]=friend+((7*i)+7);
			}
		}
		
	}
	else if(k<0)
     302:	55 23       	and	r21, r21
     304:	0c f0       	brlt	.+2      	; 0x308 <main_function7+0x140>
     306:	f4 c0       	rjmp	.+488    	; 0x4f0 <__stack+0x91>
	{ if(friend > finish)
     308:	41 17       	cp	r20, r17
     30a:	18 f5       	brcc	.+70     	; 0x352 <main_function7+0x18a>
		{	
			m=((friend-finish)/7);
     30c:	81 2f       	mov	r24, r17
     30e:	90 e0       	ldi	r25, 0x00	; 0
     310:	8c 19       	sub	r24, r12
     312:	9d 09       	sbc	r25, r13
     314:	67 e0       	ldi	r22, 0x07	; 7
     316:	70 e0       	ldi	r23, 0x00	; 0
     318:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     31c:	66 23       	and	r22, r22
     31e:	09 f4       	brne	.+2      	; 0x322 <main_function7+0x15a>
     320:	ea c0       	rjmp	.+468    	; 0x4f6 <__stack+0x97>
     322:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     324:	ec 0f       	add	r30, r28
     326:	fd 1f       	adc	r31, r29
     328:	32 96       	adiw	r30, 0x02	; 2
     32a:	83 2f       	mov	r24, r19
     32c:	99 27       	eor	r25, r25
     32e:	87 fd       	sbrc	r24, 7
     330:	90 95       	com	r25
     332:	23 e0       	ldi	r18, 0x03	; 3
     334:	30 e0       	ldi	r19, 0x00	; 0
     336:	2c 0f       	add	r18, r28
     338:	3d 1f       	adc	r19, r29
     33a:	82 0f       	add	r24, r18
     33c:	93 1f       	adc	r25, r19
     33e:	26 2f       	mov	r18, r22
     340:	21 50       	subi	r18, 0x01	; 1
     342:	82 0f       	add	r24, r18
     344:	91 1d       	adc	r25, r1
	{ if(friend > finish)
		{	
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     346:	11 93       	st	Z+, r17
     348:	17 50       	subi	r17, 0x07	; 7
	}
	else if(k<0)
	{ if(friend > finish)
		{	
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     34a:	e8 17       	cp	r30, r24
     34c:	f9 07       	cpc	r31, r25
     34e:	d9 f7       	brne	.-10     	; 0x346 <main_function7+0x17e>
     350:	d2 c0       	rjmp	.+420    	; 0x4f6 <__stack+0x97>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     352:	c6 01       	movw	r24, r12
     354:	81 1b       	sub	r24, r17
     356:	91 09       	sbc	r25, r1
     358:	67 e0       	ldi	r22, 0x07	; 7
     35a:	70 e0       	ldi	r23, 0x00	; 0
     35c:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     360:	66 23       	and	r22, r22
     362:	09 f4       	brne	.+2      	; 0x366 <main_function7+0x19e>
     364:	c8 c0       	rjmp	.+400    	; 0x4f6 <__stack+0x97>
     366:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     368:	ec 0f       	add	r30, r28
     36a:	fd 1f       	adc	r31, r29
     36c:	32 96       	adiw	r30, 0x02	; 2
     36e:	83 2f       	mov	r24, r19
     370:	99 27       	eor	r25, r25
     372:	87 fd       	sbrc	r24, 7
     374:	90 95       	com	r25
     376:	a3 e0       	ldi	r26, 0x03	; 3
     378:	b0 e0       	ldi	r27, 0x00	; 0
     37a:	ac 0f       	add	r26, r28
     37c:	bd 1f       	adc	r27, r29
     37e:	8a 0f       	add	r24, r26
     380:	9b 1f       	adc	r25, r27
     382:	26 2f       	mov	r18, r22
     384:	21 50       	subi	r18, 0x01	; 1
     386:	82 0f       	add	r24, r18
     388:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     38a:	11 93       	st	Z+, r17
     38c:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     38e:	e8 17       	cp	r30, r24
     390:	f9 07       	cpc	r31, r25
     392:	d9 f7       	brne	.-10     	; 0x38a <main_function7+0x1c2>
     394:	b0 c0       	rjmp	.+352    	; 0x4f6 <__stack+0x97>
		
	}
	
}
else
{ l=(l*(-1));
     396:	e3 2e       	mov	r14, r19
     398:	e1 94       	neg	r14
	for(unsigned char i = 0;i<=(l);i++)
     39a:	ee 2d       	mov	r30, r14
     39c:	ff 27       	eor	r31, r31
     39e:	e7 fd       	sbrc	r30, 7
     3a0:	f0 95       	com	r31
     3a2:	ff 23       	and	r31, r31
     3a4:	9c f0       	brlt	.+38     	; 0x3cc <main_function7+0x204>
     3a6:	80 e0       	ldi	r24, 0x00	; 0
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	30 e0       	ldi	r19, 0x00	; 0
	{path.path[i]=st;
     3ac:	61 e0       	ldi	r22, 0x01	; 1
     3ae:	70 e0       	ldi	r23, 0x00	; 0
     3b0:	6c 0f       	add	r22, r28
     3b2:	7d 1f       	adc	r23, r29
     3b4:	86 0f       	add	r24, r22
     3b6:	97 1f       	adc	r25, r23
     3b8:	62 2f       	mov	r22, r18
     3ba:	63 1b       	sub	r22, r19
     3bc:	dc 01       	movw	r26, r24
     3be:	6c 93       	st	X, r22
	}
	
}
else
{ l=(l*(-1));
	for(unsigned char i = 0;i<=(l);i++)
     3c0:	3f 5f       	subi	r19, 0xFF	; 255
     3c2:	83 2f       	mov	r24, r19
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	e8 17       	cp	r30, r24
     3c8:	f9 07       	cpc	r31, r25
     3ca:	84 f7       	brge	.-32     	; 0x3ac <main_function7+0x1e4>
	{path.path[i]=st;
		st--;
	}
	if(k>0)
     3cc:	15 16       	cp	r1, r21
     3ce:	0c f0       	brlt	.+2      	; 0x3d2 <main_function7+0x20a>
     3d0:	47 c0       	rjmp	.+142    	; 0x460 <__stack+0x1>
	{  
		if(friend > finish)
     3d2:	41 17       	cp	r20, r17
     3d4:	18 f5       	brcc	.+70     	; 0x41c <main_function7+0x254>
		{
			m=((friend-finish)/7);
     3d6:	81 2f       	mov	r24, r17
     3d8:	90 e0       	ldi	r25, 0x00	; 0
     3da:	8c 19       	sub	r24, r12
     3dc:	9d 09       	sbc	r25, r13
     3de:	67 e0       	ldi	r22, 0x07	; 7
     3e0:	70 e0       	ldi	r23, 0x00	; 0
     3e2:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     3e6:	66 23       	and	r22, r22
     3e8:	09 f4       	brne	.+2      	; 0x3ec <main_function7+0x224>
     3ea:	85 c0       	rjmp	.+266    	; 0x4f6 <__stack+0x97>
     3ec:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     3ee:	ec 0f       	add	r30, r28
     3f0:	fd 1f       	adc	r31, r29
     3f2:	32 96       	adiw	r30, 0x02	; 2
     3f4:	8e 2d       	mov	r24, r14
     3f6:	99 27       	eor	r25, r25
     3f8:	87 fd       	sbrc	r24, 7
     3fa:	90 95       	com	r25
     3fc:	23 e0       	ldi	r18, 0x03	; 3
     3fe:	30 e0       	ldi	r19, 0x00	; 0
     400:	2c 0f       	add	r18, r28
     402:	3d 1f       	adc	r19, r29
     404:	82 0f       	add	r24, r18
     406:	93 1f       	adc	r25, r19
     408:	26 2f       	mov	r18, r22
     40a:	21 50       	subi	r18, 0x01	; 1
     40c:	82 0f       	add	r24, r18
     40e:	91 1d       	adc	r25, r1
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     410:	11 93       	st	Z+, r17
     412:	17 50       	subi	r17, 0x07	; 7
	if(k>0)
	{  
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     414:	e8 17       	cp	r30, r24
     416:	f9 07       	cpc	r31, r25
     418:	d9 f7       	brne	.-10     	; 0x410 <main_function7+0x248>
     41a:	6d c0       	rjmp	.+218    	; 0x4f6 <__stack+0x97>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     41c:	c6 01       	movw	r24, r12
     41e:	81 1b       	sub	r24, r17
     420:	91 09       	sbc	r25, r1
     422:	67 e0       	ldi	r22, 0x07	; 7
     424:	70 e0       	ldi	r23, 0x00	; 0
     426:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     42a:	66 23       	and	r22, r22
     42c:	09 f4       	brne	.+2      	; 0x430 <main_function7+0x268>
     42e:	63 c0       	rjmp	.+198    	; 0x4f6 <__stack+0x97>
     430:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     432:	ec 0f       	add	r30, r28
     434:	fd 1f       	adc	r31, r29
     436:	32 96       	adiw	r30, 0x02	; 2
     438:	8e 2d       	mov	r24, r14
     43a:	99 27       	eor	r25, r25
     43c:	87 fd       	sbrc	r24, 7
     43e:	90 95       	com	r25
     440:	a3 e0       	ldi	r26, 0x03	; 3
     442:	b0 e0       	ldi	r27, 0x00	; 0
     444:	ac 0f       	add	r26, r28
     446:	bd 1f       	adc	r27, r29
     448:	8a 0f       	add	r24, r26
     44a:	9b 1f       	adc	r25, r27
     44c:	26 2f       	mov	r18, r22
     44e:	21 50       	subi	r18, 0x01	; 1
     450:	82 0f       	add	r24, r18
     452:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     454:	11 93       	st	Z+, r17
     456:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     458:	e8 17       	cp	r30, r24
     45a:	f9 07       	cpc	r31, r25
     45c:	d9 f7       	brne	.-10     	; 0x454 <main_function7+0x28c>
     45e:	4b c0       	rjmp	.+150    	; 0x4f6 <__stack+0x97>
			{
				path.path[l+i+1]=friend+((7*i)+7);
			}
		}
	}
	else  if(k<0)
     460:	55 23       	and	r21, r21
     462:	0c f0       	brlt	.+2      	; 0x466 <__stack+0x7>
     464:	47 c0       	rjmp	.+142    	; 0x4f4 <__stack+0x95>
	{
		if(friend > finish)
     466:	41 17       	cp	r20, r17
     468:	10 f5       	brcc	.+68     	; 0x4ae <__stack+0x4f>
		{
			m=((friend-finish)/7);
     46a:	81 2f       	mov	r24, r17
     46c:	90 e0       	ldi	r25, 0x00	; 0
     46e:	8c 19       	sub	r24, r12
     470:	9d 09       	sbc	r25, r13
     472:	67 e0       	ldi	r22, 0x07	; 7
     474:	70 e0       	ldi	r23, 0x00	; 0
     476:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     47a:	66 23       	and	r22, r22
     47c:	e1 f1       	breq	.+120    	; 0x4f6 <__stack+0x97>
     47e:	17 50       	subi	r17, 0x07	; 7
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     480:	ec 0f       	add	r30, r28
     482:	fd 1f       	adc	r31, r29
     484:	32 96       	adiw	r30, 0x02	; 2
     486:	8e 2d       	mov	r24, r14
     488:	99 27       	eor	r25, r25
     48a:	87 fd       	sbrc	r24, 7
     48c:	90 95       	com	r25
     48e:	23 e0       	ldi	r18, 0x03	; 3
     490:	30 e0       	ldi	r19, 0x00	; 0
     492:	2c 0f       	add	r18, r28
     494:	3d 1f       	adc	r19, r29
     496:	82 0f       	add	r24, r18
     498:	93 1f       	adc	r25, r19
     49a:	26 2f       	mov	r18, r22
     49c:	21 50       	subi	r18, 0x01	; 1
     49e:	82 0f       	add	r24, r18
     4a0:	91 1d       	adc	r25, r1
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     4a2:	11 93       	st	Z+, r17
     4a4:	17 50       	subi	r17, 0x07	; 7
	else  if(k<0)
	{
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     4a6:	e8 17       	cp	r30, r24
     4a8:	f9 07       	cpc	r31, r25
     4aa:	d9 f7       	brne	.-10     	; 0x4a2 <__stack+0x43>
     4ac:	24 c0       	rjmp	.+72     	; 0x4f6 <__stack+0x97>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     4ae:	c6 01       	movw	r24, r12
     4b0:	81 1b       	sub	r24, r17
     4b2:	91 09       	sbc	r25, r1
     4b4:	67 e0       	ldi	r22, 0x07	; 7
     4b6:	70 e0       	ldi	r23, 0x00	; 0
     4b8:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     4bc:	66 23       	and	r22, r22
     4be:	d9 f0       	breq	.+54     	; 0x4f6 <__stack+0x97>
     4c0:	19 5f       	subi	r17, 0xF9	; 249
struct Path_Array path1;




struct Path_Array main_function7(unsigned char start, unsigned char finish)
     4c2:	ec 0f       	add	r30, r28
     4c4:	fd 1f       	adc	r31, r29
     4c6:	32 96       	adiw	r30, 0x02	; 2
     4c8:	8e 2d       	mov	r24, r14
     4ca:	99 27       	eor	r25, r25
     4cc:	87 fd       	sbrc	r24, 7
     4ce:	90 95       	com	r25
     4d0:	a3 e0       	ldi	r26, 0x03	; 3
     4d2:	b0 e0       	ldi	r27, 0x00	; 0
     4d4:	ac 0f       	add	r26, r28
     4d6:	bd 1f       	adc	r27, r29
     4d8:	8a 0f       	add	r24, r26
     4da:	9b 1f       	adc	r25, r27
     4dc:	26 2f       	mov	r18, r22
     4de:	21 50       	subi	r18, 0x01	; 1
     4e0:	82 0f       	add	r24, r18
     4e2:	91 1d       	adc	r25, r1
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     4e4:	11 93       	st	Z+, r17
     4e6:	19 5f       	subi	r17, 0xF9	; 249
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     4e8:	e8 17       	cp	r30, r24
     4ea:	f9 07       	cpc	r31, r25
     4ec:	d9 f7       	brne	.-10     	; 0x4e4 <__stack+0x85>
     4ee:	03 c0       	rjmp	.+6      	; 0x4f6 <__stack+0x97>
else
{
	friend=(finish-(k*(-1))*7);
}
signed char l=0;
unsigned char m=0;
     4f0:	60 e0       	ldi	r22, 0x00	; 0
     4f2:	01 c0       	rjmp	.+2      	; 0x4f6 <__stack+0x97>
     4f4:	60 e0       	ldi	r22, 0x00	; 0
		}
		
	}
	
}
 max = l+m;
     4f6:	6e 0d       	add	r22, r14
     4f8:	60 93 80 00 	sts	0x0080, r22
 for(unsigned char i=(l+m+1);i<15;i++)
     4fc:	6f 5f       	subi	r22, 0xFF	; 255
     4fe:	6f 30       	cpi	r22, 0x0F	; 15
     500:	50 f4       	brcc	.+20     	; 0x516 <__stack+0xb7>
 {
	 path.path[i]=0;
     502:	e1 e0       	ldi	r30, 0x01	; 1
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	ec 0f       	add	r30, r28
     508:	fd 1f       	adc	r31, r29
     50a:	e6 0f       	add	r30, r22
     50c:	f1 1d       	adc	r31, r1
     50e:	10 82       	st	Z, r1
		
	}
	
}
 max = l+m;
 for(unsigned char i=(l+m+1);i<15;i++)
     510:	6f 5f       	subi	r22, 0xFF	; 255
     512:	6f 30       	cpi	r22, 0x0F	; 15
     514:	b1 f7       	brne	.-20     	; 0x502 <__stack+0xa3>
 {
	 path.path[i]=0;
 }

	
	return path;
     516:	e0 2f       	mov	r30, r16
     518:	ff 2d       	mov	r31, r15
     51a:	de 01       	movw	r26, r28
     51c:	11 96       	adiw	r26, 0x01	; 1
     51e:	8f e0       	ldi	r24, 0x0F	; 15
     520:	0d 90       	ld	r0, X+
     522:	01 92       	st	Z+, r0
     524:	81 50       	subi	r24, 0x01	; 1
     526:	e1 f7       	brne	.-8      	; 0x520 <__stack+0xc1>
}
     528:	80 2f       	mov	r24, r16
     52a:	9f 2d       	mov	r25, r15
     52c:	2f 96       	adiw	r28, 0x0f	; 15
     52e:	0f b6       	in	r0, 0x3f	; 63
     530:	f8 94       	cli
     532:	de bf       	out	0x3e, r29	; 62
     534:	0f be       	out	0x3f, r0	; 63
     536:	cd bf       	out	0x3d, r28	; 61
     538:	df 91       	pop	r29
     53a:	cf 91       	pop	r28
     53c:	1f 91       	pop	r17
     53e:	0f 91       	pop	r16
     540:	ff 90       	pop	r15
     542:	ef 90       	pop	r14
     544:	df 90       	pop	r13
     546:	cf 90       	pop	r12
     548:	08 95       	ret

0000054a <motion_pin_config_pos>:
volatile unsigned int Degrees; //to accept angle in degrees for turning

//Function to configure ports to enable robot's motion
void motion_pin_config_pos (void) 
{
 DDRB = DDRB | 0x0F;   //set direction of the PORTB3 to PORTB0 pins as output
     54a:	87 b3       	in	r24, 0x17	; 23
     54c:	8f 60       	ori	r24, 0x0F	; 15
     54e:	87 bb       	out	0x17, r24	; 23
 PORTB = PORTB & 0xF0; // set initial value of the PORTB3 to PORTB0 pins to logic 0
     550:	88 b3       	in	r24, 0x18	; 24
     552:	80 7f       	andi	r24, 0xF0	; 240
     554:	88 bb       	out	0x18, r24	; 24
 DDRD = DDRD | 0x30;   //Setting PD4 and PD5 pins as output for PWM generation
     556:	81 b3       	in	r24, 0x11	; 17
     558:	80 63       	ori	r24, 0x30	; 48
     55a:	81 bb       	out	0x11, r24	; 17
 PORTD = PORTD | 0x30; //PD4 and PD5 pins are for velocity control using PWM
     55c:	82 b3       	in	r24, 0x12	; 18
     55e:	80 63       	ori	r24, 0x30	; 48
     560:	82 bb       	out	0x12, r24	; 18
}
     562:	08 95       	ret

00000564 <left_encoder_pin_config>:

//Function to configure INT1 (PORTD 3) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xF7;  //Set the direction of the PORTD 3 pin as input
     564:	8b 98       	cbi	0x11, 3	; 17
 PORTD = PORTD | 0x08; //Enable internal pull-up for PORTD 3 pin
     566:	93 9a       	sbi	0x12, 3	; 18
}
     568:	08 95       	ret

0000056a <right_encoder_pin_config>:

//Function to configure INT0 (PORTD 2) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
 DDRD  = DDRD & 0xFB;  //Set the direction of the PORTD 2 pin as input
     56a:	8a 98       	cbi	0x11, 2	; 17
 PORTD = PORTD | 0x04; //Enable internal pull-up for PORTD 2 pin
     56c:	92 9a       	sbi	0x12, 2	; 18
}
     56e:	08 95       	ret

00000570 <port_init_pos>:

//Function to initialize ports
void port_init_pos()
{
 motion_pin_config_pos();          //robot motion pins config
     570:	0e 94 a5 02 	call	0x54a	; 0x54a <motion_pin_config_pos>
 left_encoder_pin_config();    //left encoder pin config
     574:	0e 94 b2 02 	call	0x564	; 0x564 <left_encoder_pin_config>
 right_encoder_pin_config();   //right encoder pin config	
     578:	0e 94 b5 02 	call	0x56a	; 0x56a <right_encoder_pin_config>
}
     57c:	08 95       	ret

0000057e <left_position_encoder_interrupt_init>:

void left_position_encoder_interrupt_init (void) //Interrupt 1 enable
{
 cli(); //Clears the global interrupt
     57e:	f8 94       	cli
 MCUCR = MCUCR | 0x08; // INT1 is set to trigger with falling edge
     580:	85 b7       	in	r24, 0x35	; 53
     582:	88 60       	ori	r24, 0x08	; 8
     584:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x80;   // Enable Interrupt INT1 for left position encoder
     586:	8b b7       	in	r24, 0x3b	; 59
     588:	80 68       	ori	r24, 0x80	; 128
     58a:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     58c:	78 94       	sei
}
     58e:	08 95       	ret

00000590 <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 0 enable
{
 cli(); //Clears the global interrupt
     590:	f8 94       	cli
 MCUCR = MCUCR | 0x02; // INT0 is set to trigger with falling edge
     592:	85 b7       	in	r24, 0x35	; 53
     594:	82 60       	ori	r24, 0x02	; 2
     596:	85 bf       	out	0x35, r24	; 53
 GICR = GICR | 0x40;   // Enable Interrupt INT5 for right position encoder
     598:	8b b7       	in	r24, 0x3b	; 59
     59a:	80 64       	ori	r24, 0x40	; 64
     59c:	8b bf       	out	0x3b, r24	; 59
 sei(); // Enables the global interrupt 
     59e:	78 94       	sei
}
     5a0:	08 95       	ret

000005a2 <__vector_1>:

//ISR for right position encoder
ISR(INT0_vect)  
{
     5a2:	1f 92       	push	r1
     5a4:	0f 92       	push	r0
     5a6:	0f b6       	in	r0, 0x3f	; 63
     5a8:	0f 92       	push	r0
     5aa:	11 24       	eor	r1, r1
     5ac:	8f 93       	push	r24
     5ae:	9f 93       	push	r25
     5b0:	af 93       	push	r26
     5b2:	bf 93       	push	r27
 ShaftCountRight++;  //increment right shaft position count
     5b4:	80 91 78 00 	lds	r24, 0x0078
     5b8:	90 91 79 00 	lds	r25, 0x0079
     5bc:	a0 91 7a 00 	lds	r26, 0x007A
     5c0:	b0 91 7b 00 	lds	r27, 0x007B
     5c4:	01 96       	adiw	r24, 0x01	; 1
     5c6:	a1 1d       	adc	r26, r1
     5c8:	b1 1d       	adc	r27, r1
     5ca:	80 93 78 00 	sts	0x0078, r24
     5ce:	90 93 79 00 	sts	0x0079, r25
     5d2:	a0 93 7a 00 	sts	0x007A, r26
     5d6:	b0 93 7b 00 	sts	0x007B, r27
}
     5da:	bf 91       	pop	r27
     5dc:	af 91       	pop	r26
     5de:	9f 91       	pop	r25
     5e0:	8f 91       	pop	r24
     5e2:	0f 90       	pop	r0
     5e4:	0f be       	out	0x3f, r0	; 63
     5e6:	0f 90       	pop	r0
     5e8:	1f 90       	pop	r1
     5ea:	18 95       	reti

000005ec <__vector_2>:

//ISR for left position encoder
ISR(INT1_vect)
{
     5ec:	1f 92       	push	r1
     5ee:	0f 92       	push	r0
     5f0:	0f b6       	in	r0, 0x3f	; 63
     5f2:	0f 92       	push	r0
     5f4:	11 24       	eor	r1, r1
     5f6:	8f 93       	push	r24
     5f8:	9f 93       	push	r25
     5fa:	af 93       	push	r26
     5fc:	bf 93       	push	r27
 ShaftCountLeft++;  //increment left shaft position count
     5fe:	80 91 7c 00 	lds	r24, 0x007C
     602:	90 91 7d 00 	lds	r25, 0x007D
     606:	a0 91 7e 00 	lds	r26, 0x007E
     60a:	b0 91 7f 00 	lds	r27, 0x007F
     60e:	01 96       	adiw	r24, 0x01	; 1
     610:	a1 1d       	adc	r26, r1
     612:	b1 1d       	adc	r27, r1
     614:	80 93 7c 00 	sts	0x007C, r24
     618:	90 93 7d 00 	sts	0x007D, r25
     61c:	a0 93 7e 00 	sts	0x007E, r26
     620:	b0 93 7f 00 	sts	0x007F, r27
}
     624:	bf 91       	pop	r27
     626:	af 91       	pop	r26
     628:	9f 91       	pop	r25
     62a:	8f 91       	pop	r24
     62c:	0f 90       	pop	r0
     62e:	0f be       	out	0x3f, r0	; 63
     630:	0f 90       	pop	r0
     632:	1f 90       	pop	r1
     634:	18 95       	reti

00000636 <motion_set_pos>:
void motion_set_pos (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortBRestore = PORTB; 		// reading the PORT original status
     636:	98 b3       	in	r25, 0x18	; 24
 PortBRestore &= 0xF0; 		// making lower direction nibbel to 0
     638:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set_pos (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
     63a:	8f 70       	andi	r24, 0x0F	; 15
 PortBRestore = PORTB; 		// reading the PORT original status
 PortBRestore &= 0xF0; 		// making lower direction nibbel to 0
 PortBRestore |= Direction; // adding lower nibbel for forward command and restoring the PORTB status
     63c:	98 2b       	or	r25, r24
 PORTB = PortBRestore; 		// executing the command
     63e:	98 bb       	out	0x18, r25	; 24
}
     640:	08 95       	ret

00000642 <forward_pos>:

void forward_pos (void) //both wheels forward
{
  motion_set_pos(0x06);
     642:	86 e0       	ldi	r24, 0x06	; 6
     644:	0e 94 1b 03 	call	0x636	; 0x636 <motion_set_pos>
}
     648:	08 95       	ret

0000064a <back_pos>:

void back_pos (void) //both wheels backward
{
  motion_set_pos(0x09);
     64a:	89 e0       	ldi	r24, 0x09	; 9
     64c:	0e 94 1b 03 	call	0x636	; 0x636 <motion_set_pos>
}
     650:	08 95       	ret

00000652 <left_pos>:

void left_pos (void) //Left wheel backward, Right wheel forward
{
  motion_set_pos(0x05);
     652:	85 e0       	ldi	r24, 0x05	; 5
     654:	0e 94 1b 03 	call	0x636	; 0x636 <motion_set_pos>
}
     658:	08 95       	ret

0000065a <right_pos>:

void right_pos (void) //Left wheel forward, Right wheel backward
{
  motion_set_pos(0x0A);
     65a:	8a e0       	ldi	r24, 0x0A	; 10
     65c:	0e 94 1b 03 	call	0x636	; 0x636 <motion_set_pos>
}
     660:	08 95       	ret

00000662 <soft_left_pos>:

void soft_left_pos (void) //Left wheel stationary, Right wheel forward
{
 motion_set_pos(0x04);
     662:	84 e0       	ldi	r24, 0x04	; 4
     664:	0e 94 1b 03 	call	0x636	; 0x636 <motion_set_pos>
}
     668:	08 95       	ret

0000066a <soft_right_pos>:

void soft_right_pos (void) //Left wheel forward, Right wheel is stationary
{
 motion_set_pos(0x02);
     66a:	82 e0       	ldi	r24, 0x02	; 2
     66c:	0e 94 1b 03 	call	0x636	; 0x636 <motion_set_pos>
}
     670:	08 95       	ret

00000672 <soft_left_2_pos>:

void soft_left_2_pos (void) //Left wheel backward, right wheel stationary
{
 motion_set_pos(0x01);
     672:	81 e0       	ldi	r24, 0x01	; 1
     674:	0e 94 1b 03 	call	0x636	; 0x636 <motion_set_pos>
}
     678:	08 95       	ret

0000067a <soft_right_2_pos>:

void soft_right_2_pos (void) //Left wheel stationary, Right wheel backward
{
 motion_set_pos(0x08);
     67a:	88 e0       	ldi	r24, 0x08	; 8
     67c:	0e 94 1b 03 	call	0x636	; 0x636 <motion_set_pos>
}
     680:	08 95       	ret

00000682 <stop_pos>:

void stop_pos (void)
{
  motion_set_pos(0x00);
     682:	80 e0       	ldi	r24, 0x00	; 0
     684:	0e 94 1b 03 	call	0x636	; 0x636 <motion_set_pos>
}
     688:	08 95       	ret

0000068a <angle_rotate>:


//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     68a:	0f 93       	push	r16
     68c:	1f 93       	push	r17
     68e:	cf 93       	push	r28
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = (float) Degrees/ 12.85; // division by resolution to get shaft count 
     690:	bc 01       	movw	r22, r24
     692:	80 e0       	ldi	r24, 0x00	; 0
     694:	90 e0       	ldi	r25, 0x00	; 0
     696:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <__floatunsisf>
     69a:	2a e9       	ldi	r18, 0x9A	; 154
     69c:	39 e9       	ldi	r19, 0x99	; 153
     69e:	4d e4       	ldi	r20, 0x4D	; 77
     6a0:	51 e4       	ldi	r21, 0x41	; 65
     6a2:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <__divsf3>
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     6a6:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__fixunssfsi>
     6aa:	dc 01       	movw	r26, r24
     6ac:	cb 01       	movw	r24, r22
     6ae:	a0 e0       	ldi	r26, 0x00	; 0
     6b0:	b0 e0       	ldi	r27, 0x00	; 0
 ShaftCountRight = 0; 
     6b2:	10 92 78 00 	sts	0x0078, r1
     6b6:	10 92 79 00 	sts	0x0079, r1
     6ba:	10 92 7a 00 	sts	0x007A, r1
     6be:	10 92 7b 00 	sts	0x007B, r1
 ShaftCountLeft = 0; 
     6c2:	10 92 7c 00 	sts	0x007C, r1
     6c6:	10 92 7d 00 	sts	0x007D, r1
     6ca:	10 92 7e 00 	sts	0x007E, r1
     6ce:	10 92 7f 00 	sts	0x007F, r1

 while (1)
 {
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     6d2:	f1 e0       	ldi	r31, 0x01	; 1
     6d4:	c0 e0       	ldi	r28, 0x00	; 0
     6d6:	40 91 78 00 	lds	r20, 0x0078
     6da:	50 91 79 00 	lds	r21, 0x0079
     6de:	60 91 7a 00 	lds	r22, 0x007A
     6e2:	70 91 7b 00 	lds	r23, 0x007B
     6e6:	00 91 7c 00 	lds	r16, 0x007C
     6ea:	10 91 7d 00 	lds	r17, 0x007D
     6ee:	20 91 7e 00 	lds	r18, 0x007E
     6f2:	30 91 7f 00 	lds	r19, 0x007F
     6f6:	ef 2f       	mov	r30, r31
     6f8:	48 17       	cp	r20, r24
     6fa:	59 07       	cpc	r21, r25
     6fc:	6a 07       	cpc	r22, r26
     6fe:	7b 07       	cpc	r23, r27
     700:	08 f4       	brcc	.+2      	; 0x704 <angle_rotate+0x7a>
     702:	ec 2f       	mov	r30, r28
     704:	ee 23       	and	r30, r30
     706:	49 f4       	brne	.+18     	; 0x71a <angle_rotate+0x90>
     708:	4f 2f       	mov	r20, r31
     70a:	08 17       	cp	r16, r24
     70c:	19 07       	cpc	r17, r25
     70e:	2a 07       	cpc	r18, r26
     710:	3b 07       	cpc	r19, r27
     712:	08 f4       	brcc	.+2      	; 0x716 <angle_rotate+0x8c>
     714:	4c 2f       	mov	r20, r28
     716:	44 23       	and	r20, r20
     718:	f1 f2       	breq	.-68     	; 0x6d6 <angle_rotate+0x4c>
  break;
 }
 stop_pos(); //Stop robot
     71a:	0e 94 41 03 	call	0x682	; 0x682 <stop_pos>
}
     71e:	cf 91       	pop	r28
     720:	1f 91       	pop	r17
     722:	0f 91       	pop	r16
     724:	08 95       	ret

00000726 <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = DistanceInMM / 12.92; // division by resolution to get shaft count
     726:	bc 01       	movw	r22, r24
     728:	80 e0       	ldi	r24, 0x00	; 0
     72a:	90 e0       	ldi	r25, 0x00	; 0
     72c:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <__floatunsisf>
     730:	22 e5       	ldi	r18, 0x52	; 82
     732:	38 eb       	ldi	r19, 0xB8	; 184
     734:	4e e4       	ldi	r20, 0x4E	; 78
     736:	51 e4       	ldi	r21, 0x41	; 65
     738:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <__divsf3>
 ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     73c:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__fixunssfsi>
     740:	46 2f       	mov	r20, r22
     742:	57 2f       	mov	r21, r23
     744:	68 2f       	mov	r22, r24
     746:	79 2f       	mov	r23, r25
  
 ShaftCountRight = 0;
     748:	10 92 78 00 	sts	0x0078, r1
     74c:	10 92 79 00 	sts	0x0079, r1
     750:	10 92 7a 00 	sts	0x007A, r1
     754:	10 92 7b 00 	sts	0x007B, r1
 while(1)
 {
  if(ShaftCountRight > ReqdShaftCountInt)
     758:	80 91 78 00 	lds	r24, 0x0078
     75c:	90 91 79 00 	lds	r25, 0x0079
     760:	a0 91 7a 00 	lds	r26, 0x007A
     764:	b0 91 7b 00 	lds	r27, 0x007B
     768:	48 17       	cp	r20, r24
     76a:	59 07       	cpc	r21, r25
     76c:	6a 07       	cpc	r22, r26
     76e:	7b 07       	cpc	r23, r27
     770:	98 f7       	brcc	.-26     	; 0x758 <linear_distance_mm+0x32>
  {
  	break;
  }
 } 
 stop_pos(); //Stop robot
     772:	0e 94 41 03 	call	0x682	; 0x682 <stop_pos>
}
     776:	08 95       	ret

00000778 <forward_mm>:

void forward_mm(unsigned int DistanceInMM)
{
     778:	cf 93       	push	r28
     77a:	df 93       	push	r29
     77c:	ec 01       	movw	r28, r24
 forward_pos();
     77e:	0e 94 21 03 	call	0x642	; 0x642 <forward_pos>
 linear_distance_mm(DistanceInMM);
     782:	ce 01       	movw	r24, r28
     784:	0e 94 93 03 	call	0x726	; 0x726 <linear_distance_mm>
}
     788:	df 91       	pop	r29
     78a:	cf 91       	pop	r28
     78c:	08 95       	ret

0000078e <back_mm>:

void back_mm(unsigned int DistanceInMM)
{
     78e:	cf 93       	push	r28
     790:	df 93       	push	r29
     792:	ec 01       	movw	r28, r24
 back_pos();
     794:	0e 94 25 03 	call	0x64a	; 0x64a <back_pos>
 linear_distance_mm(DistanceInMM);
     798:	ce 01       	movw	r24, r28
     79a:	0e 94 93 03 	call	0x726	; 0x726 <linear_distance_mm>
}
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	08 95       	ret

000007a4 <left_degrees>:

void left_degrees(unsigned int Degrees) 
{
     7a4:	cf 93       	push	r28
     7a6:	df 93       	push	r29
     7a8:	ec 01       	movw	r28, r24
// 28 pulses for 360 degrees rotation 12.92 degrees per count
 left_pos(); //Turn left
     7aa:	0e 94 29 03 	call	0x652	; 0x652 <left_pos>
 angle_rotate(Degrees);
     7ae:	ce 01       	movw	r24, r28
     7b0:	0e 94 45 03 	call	0x68a	; 0x68a <angle_rotate>
}
     7b4:	df 91       	pop	r29
     7b6:	cf 91       	pop	r28
     7b8:	08 95       	ret

000007ba <right_degrees>:



void right_degrees(unsigned int Degrees)
{
     7ba:	cf 93       	push	r28
     7bc:	df 93       	push	r29
     7be:	ec 01       	movw	r28, r24
// 28 pulses for 360 degrees rotation 12.92 degrees per count
 right_pos(); //Turn right
     7c0:	0e 94 2d 03 	call	0x65a	; 0x65a <right_pos>
 angle_rotate(Degrees);
     7c4:	ce 01       	movw	r24, r28
     7c6:	0e 94 45 03 	call	0x68a	; 0x68a <angle_rotate>
}
     7ca:	df 91       	pop	r29
     7cc:	cf 91       	pop	r28
     7ce:	08 95       	ret

000007d0 <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)
{
     7d0:	cf 93       	push	r28
     7d2:	df 93       	push	r29
     7d4:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_left_pos(); //Turn soft left
     7d6:	0e 94 31 03 	call	0x662	; 0x662 <soft_left_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     7da:	ce 01       	movw	r24, r28
     7dc:	88 0f       	add	r24, r24
     7de:	99 1f       	adc	r25, r25
     7e0:	0e 94 45 03 	call	0x68a	; 0x68a <angle_rotate>
}
     7e4:	df 91       	pop	r29
     7e6:	cf 91       	pop	r28
     7e8:	08 95       	ret

000007ea <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
     7ea:	cf 93       	push	r28
     7ec:	df 93       	push	r29
     7ee:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_right_pos();  //Turn soft right
     7f0:	0e 94 35 03 	call	0x66a	; 0x66a <soft_right_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     7f4:	ce 01       	movw	r24, r28
     7f6:	88 0f       	add	r24, r24
     7f8:	99 1f       	adc	r25, r25
     7fa:	0e 94 45 03 	call	0x68a	; 0x68a <angle_rotate>
}
     7fe:	df 91       	pop	r29
     800:	cf 91       	pop	r28
     802:	08 95       	ret

00000804 <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
     804:	cf 93       	push	r28
     806:	df 93       	push	r29
     808:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_left_2_pos(); //Turn reverse soft left
     80a:	0e 94 39 03 	call	0x672	; 0x672 <soft_left_2_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     80e:	ce 01       	movw	r24, r28
     810:	88 0f       	add	r24, r24
     812:	99 1f       	adc	r25, r25
     814:	0e 94 45 03 	call	0x68a	; 0x68a <angle_rotate>
}
     818:	df 91       	pop	r29
     81a:	cf 91       	pop	r28
     81c:	08 95       	ret

0000081e <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	ec 01       	movw	r28, r24
 // 56 pulses for 360 degrees rotation 12.85 degrees per count
 soft_right_2_pos();  //Turn reverse soft right
     824:	0e 94 3d 03 	call	0x67a	; 0x67a <soft_right_2_pos>
 Degrees=Degrees*2;
 angle_rotate(Degrees);
     828:	ce 01       	movw	r24, r28
     82a:	88 0f       	add	r24, r24
     82c:	99 1f       	adc	r25, r25
     82e:	0e 94 45 03 	call	0x68a	; 0x68a <angle_rotate>
}
     832:	df 91       	pop	r29
     834:	cf 91       	pop	r28
     836:	08 95       	ret

00000838 <init_devices_pos>:

//Function to initialize all the devices
void init_devices_pos()
{
 cli(); //Clears the global interrupt
     838:	f8 94       	cli
 port_init_pos();  //Initializes all the ports
     83a:	0e 94 b8 02 	call	0x570	; 0x570 <port_init_pos>
 left_position_encoder_interrupt_init();
     83e:	0e 94 bf 02 	call	0x57e	; 0x57e <left_position_encoder_interrupt_init>
 right_position_encoder_interrupt_init();
     842:	0e 94 c8 02 	call	0x590	; 0x590 <right_position_encoder_interrupt_init>
 sei();   // Enables the global interrupt 
     846:	78 94       	sei
}
     848:	08 95       	ret

0000084a <servo1_pin_config>:
#include <util/delay.h>

//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
	DDRD  = DDRD | 0x80;  //making PORTB 5 pin output
     84a:	8f 9a       	sbi	0x11, 7	; 17
	PORTD = PORTD | 0x80; //setting PORTB 5 pin to logic 1
     84c:	97 9a       	sbi	0x12, 7	; 18
}
     84e:	08 95       	ret

00000850 <port_init_servo>:
void port_init_servo(void)
{
	servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
     850:	0e 94 25 04 	call	0x84a	; 0x84a <servo1_pin_config>
	
}
     854:	08 95       	ret

00000856 <timer2_init>:
void timer2_init(void)
{
 TCCR2= 0x00; //stop
     856:	15 bc       	out	0x25, r1	; 37
 TCNT2 = 0xFE;
     858:	8e ef       	ldi	r24, 0xFE	; 254
     85a:	84 bd       	out	0x24, r24	; 36
 OCR2 = 0x8F;
     85c:	8f e8       	ldi	r24, 0x8F	; 143
     85e:	83 bd       	out	0x23, r24	; 35
 TCCR2= (1<< COM21)|(1<<WGM20)|(1<<WGM21);
     860:	88 e6       	ldi	r24, 0x68	; 104
     862:	85 bd       	out	0x25, r24	; 37
 //OCR2 = 0x8F;	//Output compare Register high value for servo 1
 
 
 
 
 TCCR2|= (1<<CS22)|(1<<CS20);
     864:	85 b5       	in	r24, 0x25	; 37
     866:	85 60       	ori	r24, 0x05	; 5
     868:	85 bd       	out	0x25, r24	; 37
 
}
     86a:	08 95       	ret

0000086c <init_devices_servo>:
void init_devices_servo(void)
{
	cli(); //disable all interrupts
     86c:	f8 94       	cli
	port_init_servo();
     86e:	0e 94 28 04 	call	0x850	; 0x850 <port_init_servo>
	timer2_init();
     872:	0e 94 2b 04 	call	0x856	; 0x856 <timer2_init>
	sei(); //re-enable interrupts
     876:	78 94       	sei
}
     878:	08 95       	ret

0000087a <servo_1>:

void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
     87a:	68 2f       	mov	r22, r24
     87c:	70 e0       	ldi	r23, 0x00	; 0
     87e:	80 e0       	ldi	r24, 0x00	; 0
     880:	90 e0       	ldi	r25, 0x00	; 0
     882:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <__floatunsisf>
     886:	2b e7       	ldi	r18, 0x7B	; 123
     888:	34 e1       	ldi	r19, 0x14	; 20
     88a:	4e ee       	ldi	r20, 0xEE	; 238
     88c:	5f e3       	ldi	r21, 0x3F	; 63
     88e:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <__divsf3>
     892:	20 e0       	ldi	r18, 0x00	; 0
     894:	30 e0       	ldi	r19, 0x00	; 0
     896:	4c e0       	ldi	r20, 0x0C	; 12
     898:	52 e4       	ldi	r21, 0x42	; 66
     89a:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <__addsf3>
	
	//OCR1AH = 0x00;
	OCR2 = (unsigned char) PositionPanServo;
     89e:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <__fixunssfsi>
     8a2:	63 bd       	out	0x23, r22	; 35
}
     8a4:	08 95       	ret

000008a6 <servo_1_free>:
void servo_1_free (void) //makes servo 1 free rotating
{
	//OCR1AH = 0x03;
	OCR2 = 0x8F; //Servo 1 off
     8a6:	8f e8       	ldi	r24, 0x8F	; 143
     8a8:	83 bd       	out	0x23, r24	; 35
}
     8aa:	08 95       	ret

000008ac <adc_pin_config_sharp>:
}*/

//ADC pin configuration
void adc_pin_config_sharp (void)
{
 DDRA = 0x00;  //set PORTF direction as input
     8ac:	1a ba       	out	0x1a, r1	; 26
 PORTA = 0x00; //set PORTF pins floating
     8ae:	1b ba       	out	0x1b, r1	; 27
}
     8b0:	08 95       	ret

000008b2 <ultrsonic_trigger_config>:

void ultrsonic_trigger_config(void)
{
 DDRD = DDRD | 0x40;   //all the LCD pin's direction set as output
     8b2:	8e 9a       	sbi	0x11, 6	; 17
 PORTD = PORTD & 0x00; // all the LCD pins are set to logic 0 except PORTC 7
     8b4:	82 b3       	in	r24, 0x12	; 18
     8b6:	12 ba       	out	0x12, r1	; 18
}
     8b8:	08 95       	ret

000008ba <port_init_sharp>:

//Function to Initialize PORTs
void port_init_sharp()
{
 //lcd_port_config();
 adc_pin_config_sharp();		
     8ba:	0e 94 56 04 	call	0x8ac	; 0x8ac <adc_pin_config_sharp>
 ultrsonic_trigger_config();
     8be:	0e 94 59 04 	call	0x8b2	; 0x8b2 <ultrsonic_trigger_config>
}
     8c2:	08 95       	ret

000008c4 <adc_init_sharp>:

//Function to Initialize ADC
void adc_init_sharp()
{
 ADCSRA = 0x00;
     8c4:	16 b8       	out	0x06, r1	; 6
 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     8c6:	80 e2       	ldi	r24, 0x20	; 32
     8c8:	87 b9       	out	0x07, r24	; 7
 ACSR = 0x80;
     8ca:	80 e8       	ldi	r24, 0x80	; 128
     8cc:	88 b9       	out	0x08, r24	; 8
 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     8ce:	86 e8       	ldi	r24, 0x86	; 134
     8d0:	86 b9       	out	0x06, r24	; 6
}
     8d2:	08 95       	ret

000008d4 <ADC_Conversion_sharp>:

//This Function accepts the Channel Number and returns the corresponding Analog Value 
unsigned char ADC_Conversion_sharp(unsigned char Ch)
{
 unsigned char a;
 Ch = Ch & 0x07;  			
     8d4:	87 70       	andi	r24, 0x07	; 7
 ADMUX= 0x20| Ch;	   		
     8d6:	80 62       	ori	r24, 0x20	; 32
     8d8:	87 b9       	out	0x07, r24	; 7
 ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     8da:	36 9a       	sbi	0x06, 6	; 6
 while((ADCSRA&0x10)==0);	    //Wait for ADC conversion to complete
     8dc:	34 9b       	sbis	0x06, 4	; 6
     8de:	fe cf       	rjmp	.-4      	; 0x8dc <ADC_Conversion_sharp+0x8>
 a=ADCH;
     8e0:	85 b1       	in	r24, 0x05	; 5
 ADCSRA = ADCSRA|0x10;          //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     8e2:	34 9a       	sbi	0x06, 4	; 6
 return a;
}
     8e4:	08 95       	ret

000008e6 <ultrasonic_trigger>:

// Ultrasonic sensor are connected in chaining mode. This function rise a 
// trigger pulse of >20usec to command ringing.     
void ultrasonic_trigger(void)                 
{
 PORTD = PORTD | 0x40;  // make high the Trigger input for Ultrasonic sensor
     8e6:	96 9a       	sbi	0x12, 6	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     8e8:	8b e7       	ldi	r24, 0x7B	; 123
     8ea:	8a 95       	dec	r24
     8ec:	f1 f7       	brne	.-4      	; 0x8ea <ultrasonic_trigger+0x4>
 _delay_us(50);         // Wait for >20usec
 PORTD = PORTD & 0xBF;  // make low the Trigger input for Ultrasonic sensor
     8ee:	96 98       	cbi	0x12, 6	; 18
}
     8f0:	08 95       	ret

000008f2 <init_devices_sharp>:

void init_devices_sharp (void)
{
 cli();           //Clears the global interrupts
     8f2:	f8 94       	cli
 port_init_sharp();
     8f4:	0e 94 5d 04 	call	0x8ba	; 0x8ba <port_init_sharp>
 adc_init_sharp();
     8f8:	0e 94 62 04 	call	0x8c4	; 0x8c4 <adc_init_sharp>
 sei();           //Enables the global interrupts
     8fc:	78 94       	sei
}
     8fe:	08 95       	ret

00000900 <servo100>:
									  // on white line  
#define		VELOCITY_MAX	60  
#define		VELOCITY_MIN	20
#define 	VELOCITY_LOW	0
void servo100()
{
     900:	cf 93       	push	r28
     902:	ca e5       	ldi	r28, 0x5A	; 90
	for(int i=90;i<=200;i=i+2)
	{
		init_devices_sharp();
     904:	0e 94 79 04 	call	0x8f2	; 0x8f2 <init_devices_sharp>
		//			lcd_set_4bit();
		//			lcd_init();
		for (int i=0;i<2;i++)
		{
			Center_ultrasonic_Sensor = ADC_Conversion_sharp(1) * 2;
     908:	81 e0       	ldi	r24, 0x01	; 1
     90a:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <ADC_Conversion_sharp>
     90e:	88 0f       	add	r24, r24
     910:	80 93 d8 00 	sts	0x00D8, r24
     914:	81 e0       	ldi	r24, 0x01	; 1
     916:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <ADC_Conversion_sharp>
     91a:	88 0f       	add	r24, r24
     91c:	80 93 d8 00 	sts	0x00D8, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     920:	8f ef       	ldi	r24, 0xFF	; 255
     922:	9f e3       	ldi	r25, 0x3F	; 63
     924:	a2 e0       	ldi	r26, 0x02	; 2
     926:	81 50       	subi	r24, 0x01	; 1
     928:	90 40       	sbci	r25, 0x00	; 0
     92a:	a0 40       	sbci	r26, 0x00	; 0
     92c:	e1 f7       	brne	.-8      	; 0x926 <servo100+0x26>
     92e:	00 c0       	rjmp	.+0      	; 0x930 <servo100+0x30>
     930:	00 00       	nop
			//lcd_print(2,12,Center_ultrasonic_Sensor,3);       // In Inches
			
		}
		_delay_ms(100);
		
		init_devices_servo();
     932:	0e 94 36 04 	call	0x86c	; 0x86c <init_devices_servo>
		servo_1(i);
     936:	8c 2f       	mov	r24, r28
     938:	0e 94 3d 04 	call	0x87a	; 0x87a <servo_1>
     93c:	af ef       	ldi	r26, 0xFF	; 255
     93e:	b7 e4       	ldi	r27, 0x47	; 71
     940:	11 97       	sbiw	r26, 0x01	; 1
     942:	f1 f7       	brne	.-4      	; 0x940 <servo100+0x40>
     944:	00 c0       	rjmp	.+0      	; 0x946 <servo100+0x46>
     946:	00 00       	nop
		_delay_ms(10);
		
		
		if(Center_ultrasonic_Sensor>200 )
     948:	80 91 d8 00 	lds	r24, 0x00D8
     94c:	89 3c       	cpi	r24, 0xC9	; 201
     94e:	18 f1       	brcs	.+70     	; 0x996 <servo100+0x96>
     950:	8f ef       	ldi	r24, 0xFF	; 255
     952:	9f e7       	ldi	r25, 0x7F	; 127
     954:	a6 e1       	ldi	r26, 0x16	; 22
     956:	81 50       	subi	r24, 0x01	; 1
     958:	90 40       	sbci	r25, 0x00	; 0
     95a:	a0 40       	sbci	r26, 0x00	; 0
     95c:	e1 f7       	brne	.-8      	; 0x956 <servo100+0x56>
     95e:	00 c0       	rjmp	.+0      	; 0x960 <servo100+0x60>
     960:	00 00       	nop
		{
			//servo_1_free();
			_delay_ms(1000);
			//buzzer_beep();
			side=100;
     962:	84 e6       	ldi	r24, 0x64	; 100
     964:	80 93 74 00 	sts	0x0074, r24
			color_sensor_work();
     968:	0e 94 a0 08 	call	0x1140	; 0x1140 <color_sensor_work>
     96c:	8f ef       	ldi	r24, 0xFF	; 255
     96e:	9f e3       	ldi	r25, 0x3F	; 63
     970:	a2 e0       	ldi	r26, 0x02	; 2
     972:	81 50       	subi	r24, 0x01	; 1
     974:	90 40       	sbci	r25, 0x00	; 0
     976:	a0 40       	sbci	r26, 0x00	; 0
     978:	e1 f7       	brne	.-8      	; 0x972 <servo100+0x72>
     97a:	00 c0       	rjmp	.+0      	; 0x97c <servo100+0x7c>
     97c:	00 00       	nop
			
			_delay_ms(100);
			do_task();
     97e:	0e 94 49 00 	call	0x92	; 0x92 <do_task>
     982:	8f ef       	ldi	r24, 0xFF	; 255
     984:	9f e3       	ldi	r25, 0x3F	; 63
     986:	ab e0       	ldi	r26, 0x0B	; 11
     988:	81 50       	subi	r24, 0x01	; 1
     98a:	90 40       	sbci	r25, 0x00	; 0
     98c:	a0 40       	sbci	r26, 0x00	; 0
     98e:	e1 f7       	brne	.-8      	; 0x988 <servo100+0x88>
     990:	00 c0       	rjmp	.+0      	; 0x992 <servo100+0x92>
     992:	00 00       	nop
     994:	04 c0       	rjmp	.+8      	; 0x99e <servo100+0x9e>
     996:	ce 5f       	subi	r28, 0xFE	; 254
#define		VELOCITY_MAX	60  
#define		VELOCITY_MIN	20
#define 	VELOCITY_LOW	0
void servo100()
{
	for(int i=90;i<=200;i=i+2)
     998:	ca 3c       	cpi	r28, 0xCA	; 202
     99a:	09 f0       	breq	.+2      	; 0x99e <servo100+0x9e>
     99c:	b3 cf       	rjmp	.-154    	; 0x904 <servo100+0x4>
			
			
		}
		
	}
	servo_1(90);
     99e:	8a e5       	ldi	r24, 0x5A	; 90
     9a0:	0e 94 3d 04 	call	0x87a	; 0x87a <servo_1>
     9a4:	8f ef       	ldi	r24, 0xFF	; 255
     9a6:	9f e3       	ldi	r25, 0x3F	; 63
     9a8:	ab e0       	ldi	r26, 0x0B	; 11
     9aa:	81 50       	subi	r24, 0x01	; 1
     9ac:	90 40       	sbci	r25, 0x00	; 0
     9ae:	a0 40       	sbci	r26, 0x00	; 0
     9b0:	e1 f7       	brne	.-8      	; 0x9aa <servo100+0xaa>
     9b2:	00 c0       	rjmp	.+0      	; 0x9b4 <servo100+0xb4>
     9b4:	00 00       	nop
	_delay_ms(500);
	
}
     9b6:	cf 91       	pop	r28
     9b8:	08 95       	ret

000009ba <servo101>:
void servo101()
{
     9ba:	cf 93       	push	r28
     9bc:	ca e5       	ldi	r28, 0x5A	; 90
	for(int i=90;i>=10;i=i-2)
	{
		init_devices_sharp();
     9be:	0e 94 79 04 	call	0x8f2	; 0x8f2 <init_devices_sharp>
		//			lcd_set_4bit();
		//			lcd_init();
		for (int i=0;i<2;i++)
		{
			Center_ultrasonic_Sensor = ADC_Conversion_sharp(1) * 2;
     9c2:	81 e0       	ldi	r24, 0x01	; 1
     9c4:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <ADC_Conversion_sharp>
     9c8:	88 0f       	add	r24, r24
     9ca:	80 93 d8 00 	sts	0x00D8, r24
     9ce:	81 e0       	ldi	r24, 0x01	; 1
     9d0:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <ADC_Conversion_sharp>
     9d4:	88 0f       	add	r24, r24
     9d6:	80 93 d8 00 	sts	0x00D8, r24
     9da:	8f ef       	ldi	r24, 0xFF	; 255
     9dc:	9f e3       	ldi	r25, 0x3F	; 63
     9de:	a2 e0       	ldi	r26, 0x02	; 2
     9e0:	81 50       	subi	r24, 0x01	; 1
     9e2:	90 40       	sbci	r25, 0x00	; 0
     9e4:	a0 40       	sbci	r26, 0x00	; 0
     9e6:	e1 f7       	brne	.-8      	; 0x9e0 <servo101+0x26>
     9e8:	00 c0       	rjmp	.+0      	; 0x9ea <servo101+0x30>
     9ea:	00 00       	nop
			//lcd_print(2,12,Center_ultrasonic_Sensor,3);       // In Inches
			
		}
		_delay_ms(100);
		
		init_devices_servo();
     9ec:	0e 94 36 04 	call	0x86c	; 0x86c <init_devices_servo>
		servo_1(i);
     9f0:	8c 2f       	mov	r24, r28
     9f2:	0e 94 3d 04 	call	0x87a	; 0x87a <servo_1>
     9f6:	af ef       	ldi	r26, 0xFF	; 255
     9f8:	b7 e4       	ldi	r27, 0x47	; 71
     9fa:	11 97       	sbiw	r26, 0x01	; 1
     9fc:	f1 f7       	brne	.-4      	; 0x9fa <servo101+0x40>
     9fe:	00 c0       	rjmp	.+0      	; 0xa00 <servo101+0x46>
     a00:	00 00       	nop
		_delay_ms(10);
		
		
		if(Center_ultrasonic_Sensor>200 )
     a02:	80 91 d8 00 	lds	r24, 0x00D8
     a06:	89 3c       	cpi	r24, 0xC9	; 201
     a08:	18 f1       	brcs	.+70     	; 0xa50 <servo101+0x96>
     a0a:	8f ef       	ldi	r24, 0xFF	; 255
     a0c:	9f e7       	ldi	r25, 0x7F	; 127
     a0e:	a6 e1       	ldi	r26, 0x16	; 22
     a10:	81 50       	subi	r24, 0x01	; 1
     a12:	90 40       	sbci	r25, 0x00	; 0
     a14:	a0 40       	sbci	r26, 0x00	; 0
     a16:	e1 f7       	brne	.-8      	; 0xa10 <servo101+0x56>
     a18:	00 c0       	rjmp	.+0      	; 0xa1a <servo101+0x60>
     a1a:	00 00       	nop
		{	//servo_1_free();
			_delay_ms(1000);
			//buzzer_beep();
			side=101;
     a1c:	85 e6       	ldi	r24, 0x65	; 101
     a1e:	80 93 74 00 	sts	0x0074, r24
			color_sensor_work();
     a22:	0e 94 a0 08 	call	0x1140	; 0x1140 <color_sensor_work>
     a26:	8f ef       	ldi	r24, 0xFF	; 255
     a28:	9f e3       	ldi	r25, 0x3F	; 63
     a2a:	a2 e0       	ldi	r26, 0x02	; 2
     a2c:	81 50       	subi	r24, 0x01	; 1
     a2e:	90 40       	sbci	r25, 0x00	; 0
     a30:	a0 40       	sbci	r26, 0x00	; 0
     a32:	e1 f7       	brne	.-8      	; 0xa2c <servo101+0x72>
     a34:	00 c0       	rjmp	.+0      	; 0xa36 <servo101+0x7c>
     a36:	00 00       	nop
			
			_delay_ms(100);
			do_task();
     a38:	0e 94 49 00 	call	0x92	; 0x92 <do_task>
     a3c:	8f ef       	ldi	r24, 0xFF	; 255
     a3e:	9f e3       	ldi	r25, 0x3F	; 63
     a40:	ab e0       	ldi	r26, 0x0B	; 11
     a42:	81 50       	subi	r24, 0x01	; 1
     a44:	90 40       	sbci	r25, 0x00	; 0
     a46:	a0 40       	sbci	r26, 0x00	; 0
     a48:	e1 f7       	brne	.-8      	; 0xa42 <servo101+0x88>
     a4a:	00 c0       	rjmp	.+0      	; 0xa4c <servo101+0x92>
     a4c:	00 00       	nop
     a4e:	04 c0       	rjmp	.+8      	; 0xa58 <servo101+0x9e>
     a50:	c2 50       	subi	r28, 0x02	; 2
	_delay_ms(500);
	
}
void servo101()
{
	for(int i=90;i>=10;i=i-2)
     a52:	c8 30       	cpi	r28, 0x08	; 8
     a54:	09 f0       	breq	.+2      	; 0xa58 <servo101+0x9e>
     a56:	b3 cf       	rjmp	.-154    	; 0x9be <servo101+0x4>
			
			break;
		}
		
	}
	servo_1(90);
     a58:	8a e5       	ldi	r24, 0x5A	; 90
     a5a:	0e 94 3d 04 	call	0x87a	; 0x87a <servo_1>
     a5e:	8f ef       	ldi	r24, 0xFF	; 255
     a60:	9f e3       	ldi	r25, 0x3F	; 63
     a62:	a2 e0       	ldi	r26, 0x02	; 2
     a64:	81 50       	subi	r24, 0x01	; 1
     a66:	90 40       	sbci	r25, 0x00	; 0
     a68:	a0 40       	sbci	r26, 0x00	; 0
     a6a:	e1 f7       	brne	.-8      	; 0xa64 <servo101+0xaa>
     a6c:	00 c0       	rjmp	.+0      	; 0xa6e <servo101+0xb4>
     a6e:	00 00       	nop
	_delay_ms(100);
}
     a70:	cf 91       	pop	r28
     a72:	08 95       	ret

00000a74 <lcd_port_config>:
unsigned char Right_white_line = 0;

//Function to configure LCD port
void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7;    //all the LCD pin's direction set as output
     a74:	84 b3       	in	r24, 0x14	; 20
     a76:	87 6f       	ori	r24, 0xF7	; 247
     a78:	84 bb       	out	0x14, r24	; 20
 PORTC = PORTC & 0x80;  // all the LCD pins are set to logic 0 except PORTC 7
     a7a:	85 b3       	in	r24, 0x15	; 21
     a7c:	80 78       	andi	r24, 0x80	; 128
     a7e:	85 bb       	out	0x15, r24	; 21
}
     a80:	08 95       	ret

00000a82 <adc_pin_config>:

//ADC pin configuration
void adc_pin_config (void)
{
 DDRA = 0x00;   //set PORTF direction as input
     a82:	1a ba       	out	0x1a, r1	; 26
 PORTA = 0x00;  //set PORTF pins floating
     a84:	1b ba       	out	0x1b, r1	; 27
}
     a86:	08 95       	ret

00000a88 <motion_pin_config>:

//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
 DDRB = DDRB | 0x0F;    //set direction of the PORTB3 to PORTB0 pins as output
     a88:	87 b3       	in	r24, 0x17	; 23
     a8a:	8f 60       	ori	r24, 0x0F	; 15
     a8c:	87 bb       	out	0x17, r24	; 23
 PORTB = PORTB & 0xF0;  //set initial value of the PORTB3 to PORTB0 pins to logic 0
     a8e:	88 b3       	in	r24, 0x18	; 24
     a90:	80 7f       	andi	r24, 0xF0	; 240
     a92:	88 bb       	out	0x18, r24	; 24
 DDRD = DDRD | 0x30;    //Setting PD5 and PD4 pins as output for PWM generation
     a94:	81 b3       	in	r24, 0x11	; 17
     a96:	80 63       	ori	r24, 0x30	; 48
     a98:	81 bb       	out	0x11, r24	; 17
 PORTD = PORTD | 0x30;  //PD5 and PD4 pins are for velocity control using PWM
     a9a:	82 b3       	in	r24, 0x12	; 18
     a9c:	80 63       	ori	r24, 0x30	; 48
     a9e:	82 bb       	out	0x12, r24	; 18
}
     aa0:	08 95       	ret

00000aa2 <port_init>:

//Function to Initialize PORTS
void port_init()
{
 lcd_port_config();
     aa2:	0e 94 3a 05 	call	0xa74	; 0xa74 <lcd_port_config>
 adc_pin_config();		
     aa6:	0e 94 41 05 	call	0xa82	; 0xa82 <adc_pin_config>
 motion_pin_config();
     aaa:	0e 94 44 05 	call	0xa88	; 0xa88 <motion_pin_config>
}
     aae:	08 95       	ret

00000ab0 <timer1_init>:
// WGM: 5) PWM 8bit fast, TOP=0x00FF
// desired value: 450Hz
// actual value: 450.000Hz (0.0%)
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     ab0:	1e bc       	out	0x2e, r1	; 46
 TCNT1H = 0xFF; //setup
     ab2:	8f ef       	ldi	r24, 0xFF	; 255
     ab4:	8d bd       	out	0x2d, r24	; 45
 TCNT1L = 0x01;
     ab6:	91 e0       	ldi	r25, 0x01	; 1
     ab8:	9c bd       	out	0x2c, r25	; 44
 OCR1AH = 0x00;
     aba:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = 0xFF;
     abc:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     abe:	19 bc       	out	0x29, r1	; 41
 OCR1BL = 0xFF;
     ac0:	88 bd       	out	0x28, r24	; 40
 ICR1H  = 0x00;
     ac2:	17 bc       	out	0x27, r1	; 39
 ICR1L  = 0xFF;
     ac4:	86 bd       	out	0x26, r24	; 38
 TCCR1A = 0xA1;
     ac6:	81 ea       	ldi	r24, 0xA1	; 161
     ac8:	8f bd       	out	0x2f, r24	; 47
 TCCR1B = 0x0D; //start Timer
     aca:	8d e0       	ldi	r24, 0x0D	; 13
     acc:	8e bd       	out	0x2e, r24	; 46
}
     ace:	08 95       	ret

00000ad0 <adc_init>:


//Function to Initialize ADC
void adc_init()
{
 ADCSRA = 0x00;
     ad0:	16 b8       	out	0x06, r1	; 6
 ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     ad2:	80 e2       	ldi	r24, 0x20	; 32
     ad4:	87 b9       	out	0x07, r24	; 7
 ACSR = 0x80;
     ad6:	80 e8       	ldi	r24, 0x80	; 128
     ad8:	88 b9       	out	0x08, r24	; 8
 ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     ada:	86 e8       	ldi	r24, 0x86	; 134
     adc:	86 b9       	out	0x06, r24	; 6
}
     ade:	08 95       	ret

00000ae0 <ADC_Conversion>:

//This Function accepts the Channel Number and returns the corresponding Analog Value 
unsigned char ADC_Conversion(unsigned char Ch)
{
 unsigned char a;
 Ch = Ch & 0x07;  			
     ae0:	87 70       	andi	r24, 0x07	; 7
 ADMUX= 0x20| Ch;	   		
     ae2:	80 62       	ori	r24, 0x20	; 32
     ae4:	87 b9       	out	0x07, r24	; 7
 ADCSRA = ADCSRA | 0x40;	//Set start conversion bit
     ae6:	36 9a       	sbi	0x06, 6	; 6
 while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     ae8:	34 9b       	sbis	0x06, 4	; 6
     aea:	fe cf       	rjmp	.-4      	; 0xae8 <ADC_Conversion+0x8>
 a=ADCH;
     aec:	85 b1       	in	r24, 0x05	; 5
 ADCSRA = ADCSRA|0x10;      //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     aee:	34 9a       	sbi	0x06, 4	; 6
 return a;
}
     af0:	08 95       	ret

00000af2 <print_sensor>:

// This Function prints the Analog Value Of Corresponding Channel No. at required Row
// and Coloumn Location. 
void print_sensor(char row, char coloumn,unsigned char channel)
{
     af2:	84 2f       	mov	r24, r20
 ADC_Value = ADC_Conversion(channel);
     af4:	0e 94 70 05 	call	0xae0	; 0xae0 <ADC_Conversion>
     af8:	80 93 d7 00 	sts	0x00D7, r24
 
}
     afc:	08 95       	ret

00000afe <motion_set>:
void motion_set (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 			// removing upper nibbel as it is not needed
 PortBRestore = PORTB; 			// reading the PORTB's original status
     afe:	98 b3       	in	r25, 0x18	; 24
 PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
     b00:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
 unsigned char PortBRestore = 0;

 Direction &= 0x0F; 			// removing upper nibbel as it is not needed
     b02:	8f 70       	andi	r24, 0x0F	; 15
 PortBRestore = PORTB; 			// reading the PORTB's original status
 PortBRestore &= 0xF0; 			// setting lower direction nibbel to 0
 PortBRestore |= Direction; 	// adding lower nibbel for direction command and restoring the PORTB status
     b04:	98 2b       	or	r25, r24
 PORTB = PortBRestore; 			// setting the command to the port
     b06:	98 bb       	out	0x18, r25	; 24
}
     b08:	08 95       	ret

00000b0a <forward>:

void forward (void) //both wheels forward
{
  motion_set(0x06);
     b0a:	86 e0       	ldi	r24, 0x06	; 6
     b0c:	0e 94 7f 05 	call	0xafe	; 0xafe <motion_set>
}
     b10:	08 95       	ret

00000b12 <back>:

void back (void) //hard stop
{
  motion_set(0x09);
     b12:	89 e0       	ldi	r24, 0x09	; 9
     b14:	0e 94 7f 05 	call	0xafe	; 0xafe <motion_set>
}
     b18:	08 95       	ret

00000b1a <left>:
void left (void) //hard stop
{
	motion_set(0x05);
     b1a:	85 e0       	ldi	r24, 0x05	; 5
     b1c:	0e 94 7f 05 	call	0xafe	; 0xafe <motion_set>
}
     b20:	08 95       	ret

00000b22 <right>:
void right (void) //hard stop
{
	motion_set(0x0A);
     b22:	8a e0       	ldi	r24, 0x0A	; 10
     b24:	0e 94 7f 05 	call	0xafe	; 0xafe <motion_set>
}
     b28:	08 95       	ret

00000b2a <hard_stop>:
void hard_stop (void) //hard stop
{
	motion_set(0x00);
     b2a:	80 e0       	ldi	r24, 0x00	; 0
     b2c:	0e 94 7f 05 	call	0xafe	; 0xafe <motion_set>
}
     b30:	08 95       	ret

00000b32 <s_L>:
void s_L (void) //hard stop
{
	motion_set(0x04);
     b32:	84 e0       	ldi	r24, 0x04	; 4
     b34:	0e 94 7f 05 	call	0xafe	; 0xafe <motion_set>
}
     b38:	08 95       	ret

00000b3a <S_R>:
void S_R (void) //hard stop
{
	motion_set(0x02);
     b3a:	82 e0       	ldi	r24, 0x02	; 2
     b3c:	0e 94 7f 05 	call	0xafe	; 0xafe <motion_set>
}
     b40:	08 95       	ret

00000b42 <S_STOP>:
void S_STOP (void) //hard stop
{
	motion_set(0x0F);
     b42:	8f e0       	ldi	r24, 0x0F	; 15
     b44:	0e 94 7f 05 	call	0xafe	; 0xafe <motion_set>
}
     b48:	08 95       	ret

00000b4a <velocity>:


//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
 OCR1AH = 0x00;
     b4a:	1b bc       	out	0x2b, r1	; 43
 OCR1AL = left_motor; 
     b4c:	8a bd       	out	0x2a, r24	; 42
 OCR1BH = 0x00;
     b4e:	19 bc       	out	0x29, r1	; 41
 OCR1BL = right_motor;
     b50:	68 bd       	out	0x28, r22	; 40
}
     b52:	08 95       	ret

00000b54 <success>:
	}
}


void success(int x)
{
     b54:	0f 93       	push	r16
     b56:	1f 93       	push	r17
     b58:	cf 93       	push	r28
     b5a:	df 93       	push	r29
     b5c:	ec 01       	movw	r28, r24
	unsigned char Left_white_line = 0;
	unsigned char Center_white_line = 0;
	unsigned char Right_white_line = 0;

	switch (x)
     b5e:	82 30       	cpi	r24, 0x02	; 2
     b60:	91 05       	cpc	r25, r1
     b62:	b1 f0       	breq	.+44     	; 0xb90 <success+0x3c>
     b64:	83 30       	cpi	r24, 0x03	; 3
     b66:	91 05       	cpc	r25, r1
     b68:	19 f1       	breq	.+70     	; 0xbb0 <success+0x5c>
     b6a:	81 30       	cpi	r24, 0x01	; 1
     b6c:	91 05       	cpc	r25, r1
     b6e:	79 f5       	brne	.+94     	; 0xbce <success+0x7a>
	{
		case 1:
		forward();
     b70:	0e 94 85 05 	call	0xb0a	; 0xb0a <forward>
		velocity(125,125);
     b74:	8d e7       	ldi	r24, 0x7D	; 125
     b76:	6d e7       	ldi	r22, 0x7D	; 125
     b78:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
     b7c:	8f ef       	ldi	r24, 0xFF	; 255
     b7e:	9f e3       	ldi	r25, 0x3F	; 63
     b80:	a2 e0       	ldi	r26, 0x02	; 2
     b82:	81 50       	subi	r24, 0x01	; 1
     b84:	90 40       	sbci	r25, 0x00	; 0
     b86:	a0 40       	sbci	r26, 0x00	; 0
     b88:	e1 f7       	brne	.-8      	; 0xb82 <success+0x2e>
     b8a:	00 c0       	rjmp	.+0      	; 0xb8c <success+0x38>
     b8c:	00 00       	nop
     b8e:	1f c0       	rjmp	.+62     	; 0xbce <success+0x7a>
		_delay_ms(100);
		break;
		case 2:
		forward();
     b90:	0e 94 85 05 	call	0xb0a	; 0xb0a <forward>
		velocity(130,30);
     b94:	82 e8       	ldi	r24, 0x82	; 130
     b96:	6e e1       	ldi	r22, 0x1E	; 30
     b98:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
     b9c:	8f ef       	ldi	r24, 0xFF	; 255
     b9e:	9f e9       	ldi	r25, 0x9F	; 159
     ba0:	a7 e1       	ldi	r26, 0x17	; 23
     ba2:	81 50       	subi	r24, 0x01	; 1
     ba4:	90 40       	sbci	r25, 0x00	; 0
     ba6:	a0 40       	sbci	r26, 0x00	; 0
     ba8:	e1 f7       	brne	.-8      	; 0xba2 <success+0x4e>
     baa:	00 c0       	rjmp	.+0      	; 0xbac <success+0x58>
     bac:	00 00       	nop
     bae:	0f c0       	rjmp	.+30     	; 0xbce <success+0x7a>
		_delay_ms(1050);
		
		break;
		case 3:
		forward();
     bb0:	0e 94 85 05 	call	0xb0a	; 0xb0a <forward>
		velocity(30,130);
     bb4:	8e e1       	ldi	r24, 0x1E	; 30
     bb6:	62 e8       	ldi	r22, 0x82	; 130
     bb8:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
     bbc:	8f ef       	ldi	r24, 0xFF	; 255
     bbe:	9f e9       	ldi	r25, 0x9F	; 159
     bc0:	a7 e1       	ldi	r26, 0x17	; 23
     bc2:	81 50       	subi	r24, 0x01	; 1
     bc4:	90 40       	sbci	r25, 0x00	; 0
     bc6:	a0 40       	sbci	r26, 0x00	; 0
     bc8:	e1 f7       	brne	.-8      	; 0xbc2 <success+0x6e>
     bca:	00 c0       	rjmp	.+0      	; 0xbcc <success+0x78>
     bcc:	00 00       	nop
	}
	
	while(1)
	{
		
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     bce:	83 e0       	ldi	r24, 0x03	; 3
     bd0:	0e 94 70 05 	call	0xae0	; 0xae0 <ADC_Conversion>
     bd4:	08 2f       	mov	r16, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     bd6:	82 e0       	ldi	r24, 0x02	; 2
     bd8:	0e 94 70 05 	call	0xae0	; 0xae0 <ADC_Conversion>
     bdc:	18 2f       	mov	r17, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
     bde:	81 e0       	ldi	r24, 0x01	; 1
     be0:	0e 94 70 05 	call	0xae0	; 0xae0 <ADC_Conversion>

//		print_sensor(1,1,3);	//Prints value of White Line Sensor1
		//print_sensor(1,5,2);	//Prints Value of White Line Sensor2
	//	print_sensor(1,9,1);	//Prints Value of White Line Sensor3

		if(Center_white_line<0x19 && Left_white_line<0x19 && Right_white_line<0x19)
     be4:	19 31       	cpi	r17, 0x19	; 25
     be6:	f0 f5       	brcc	.+124    	; 0xc64 <success+0x110>
     be8:	09 31       	cpi	r16, 0x19	; 25
     bea:	08 f0       	brcs	.+2      	; 0xbee <success+0x9a>
     bec:	4d c0       	rjmp	.+154    	; 0xc88 <success+0x134>
     bee:	89 31       	cpi	r24, 0x19	; 25
     bf0:	d8 f5       	brcc	.+118    	; 0xc68 <success+0x114>
		{
			switch (x)
     bf2:	c2 30       	cpi	r28, 0x02	; 2
     bf4:	d1 05       	cpc	r29, r1
     bf6:	b1 f0       	breq	.+44     	; 0xc24 <success+0xd0>
     bf8:	c3 30       	cpi	r28, 0x03	; 3
     bfa:	d1 05       	cpc	r29, r1
     bfc:	19 f1       	breq	.+70     	; 0xc44 <success+0xf0>
     bfe:	c1 30       	cpi	r28, 0x01	; 1
     c00:	d1 05       	cpc	r29, r1
     c02:	29 f7       	brne	.-54     	; 0xbce <success+0x7a>
			{
				case 1:
				forward();
     c04:	0e 94 85 05 	call	0xb0a	; 0xb0a <forward>
				velocity(125,125);
     c08:	8d e7       	ldi	r24, 0x7D	; 125
     c0a:	6d e7       	ldi	r22, 0x7D	; 125
     c0c:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
     c10:	8f ef       	ldi	r24, 0xFF	; 255
     c12:	9f e3       	ldi	r25, 0x3F	; 63
     c14:	a2 e0       	ldi	r26, 0x02	; 2
     c16:	81 50       	subi	r24, 0x01	; 1
     c18:	90 40       	sbci	r25, 0x00	; 0
     c1a:	a0 40       	sbci	r26, 0x00	; 0
     c1c:	e1 f7       	brne	.-8      	; 0xc16 <success+0xc2>
     c1e:	00 c0       	rjmp	.+0      	; 0xc20 <success+0xcc>
     c20:	00 00       	nop
     c22:	d5 cf       	rjmp	.-86     	; 0xbce <success+0x7a>
				_delay_ms(100);
				break;
				case 2:
				forward();
     c24:	0e 94 85 05 	call	0xb0a	; 0xb0a <forward>
				velocity(130,30);
     c28:	82 e8       	ldi	r24, 0x82	; 130
     c2a:	6e e1       	ldi	r22, 0x1E	; 30
     c2c:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
     c30:	8f ef       	ldi	r24, 0xFF	; 255
     c32:	9f e3       	ldi	r25, 0x3F	; 63
     c34:	a2 e0       	ldi	r26, 0x02	; 2
     c36:	81 50       	subi	r24, 0x01	; 1
     c38:	90 40       	sbci	r25, 0x00	; 0
     c3a:	a0 40       	sbci	r26, 0x00	; 0
     c3c:	e1 f7       	brne	.-8      	; 0xc36 <success+0xe2>
     c3e:	00 c0       	rjmp	.+0      	; 0xc40 <success+0xec>
     c40:	00 00       	nop
     c42:	c5 cf       	rjmp	.-118    	; 0xbce <success+0x7a>
				_delay_ms(100);
				
				break;
				case 3:
				forward();
     c44:	0e 94 85 05 	call	0xb0a	; 0xb0a <forward>
				velocity(30,130);
     c48:	8e e1       	ldi	r24, 0x1E	; 30
     c4a:	62 e8       	ldi	r22, 0x82	; 130
     c4c:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
     c50:	8f ef       	ldi	r24, 0xFF	; 255
     c52:	9f e3       	ldi	r25, 0x3F	; 63
     c54:	a2 e0       	ldi	r26, 0x02	; 2
     c56:	81 50       	subi	r24, 0x01	; 1
     c58:	90 40       	sbci	r25, 0x00	; 0
     c5a:	a0 40       	sbci	r26, 0x00	; 0
     c5c:	e1 f7       	brne	.-8      	; 0xc56 <success+0x102>
     c5e:	00 c0       	rjmp	.+0      	; 0xc60 <success+0x10c>
     c60:	00 00       	nop
     c62:	b5 cf       	rjmp	.-150    	; 0xbce <success+0x7a>
		}


		

		else if((Left_white_line<0x19)) //&& (flag==0))
     c64:	09 31       	cpi	r16, 0x19	; 25
     c66:	80 f4       	brcc	.+32     	; 0xc88 <success+0x134>
		{
			//flag=1;
			forward();
     c68:	0e 94 85 05 	call	0xb0a	; 0xb0a <forward>
			velocity(130,30);
     c6c:	82 e8       	ldi	r24, 0x82	; 130
     c6e:	6e e1       	ldi	r22, 0x1E	; 30
     c70:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
     c74:	8f ef       	ldi	r24, 0xFF	; 255
     c76:	9f eb       	ldi	r25, 0xBF	; 191
     c78:	a6 e0       	ldi	r26, 0x06	; 6
     c7a:	81 50       	subi	r24, 0x01	; 1
     c7c:	90 40       	sbci	r25, 0x00	; 0
     c7e:	a0 40       	sbci	r26, 0x00	; 0
     c80:	e1 f7       	brne	.-8      	; 0xc7a <success+0x126>
     c82:	00 c0       	rjmp	.+0      	; 0xc84 <success+0x130>
     c84:	00 00       	nop
     c86:	24 c0       	rjmp	.+72     	; 0xcd0 <success+0x17c>
			_delay_ms(300);
			break;
		}

		else if((Right_white_line<0x19))// && (flag==0))
     c88:	89 31       	cpi	r24, 0x19	; 25
     c8a:	80 f4       	brcc	.+32     	; 0xcac <success+0x158>
		{
			//	flag=1;
			
			forward();
     c8c:	0e 94 85 05 	call	0xb0a	; 0xb0a <forward>
			velocity(30,130);
     c90:	8e e1       	ldi	r24, 0x1E	; 30
     c92:	62 e8       	ldi	r22, 0x82	; 130
     c94:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
     c98:	8f ef       	ldi	r24, 0xFF	; 255
     c9a:	9f eb       	ldi	r25, 0xBF	; 191
     c9c:	a6 e0       	ldi	r26, 0x06	; 6
     c9e:	81 50       	subi	r24, 0x01	; 1
     ca0:	90 40       	sbci	r25, 0x00	; 0
     ca2:	a0 40       	sbci	r26, 0x00	; 0
     ca4:	e1 f7       	brne	.-8      	; 0xc9e <success+0x14a>
     ca6:	00 c0       	rjmp	.+0      	; 0xca8 <success+0x154>
     ca8:	00 00       	nop
     caa:	12 c0       	rjmp	.+36     	; 0xcd0 <success+0x17c>
			_delay_ms(300);
			break;
		}
		else if(Center_white_line>0x19)
     cac:	1a 31       	cpi	r17, 0x1A	; 26
     cae:	08 f4       	brcc	.+2      	; 0xcb2 <success+0x15e>
     cb0:	8e cf       	rjmp	.-228    	; 0xbce <success+0x7a>
		{
			//flag=1;
			forward();
     cb2:	0e 94 85 05 	call	0xb0a	; 0xb0a <forward>
			velocity(135,135);
     cb6:	87 e8       	ldi	r24, 0x87	; 135
     cb8:	67 e8       	ldi	r22, 0x87	; 135
     cba:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
     cbe:	8f ef       	ldi	r24, 0xFF	; 255
     cc0:	9f eb       	ldi	r25, 0xBF	; 191
     cc2:	a6 e0       	ldi	r26, 0x06	; 6
     cc4:	81 50       	subi	r24, 0x01	; 1
     cc6:	90 40       	sbci	r25, 0x00	; 0
     cc8:	a0 40       	sbci	r26, 0x00	; 0
     cca:	e1 f7       	brne	.-8      	; 0xcc4 <success+0x170>
     ccc:	00 c0       	rjmp	.+0      	; 0xcce <success+0x17a>
     cce:	00 00       	nop
		
		

	}
	
     cd0:	df 91       	pop	r29
     cd2:	cf 91       	pop	r28
     cd4:	1f 91       	pop	r17
     cd6:	0f 91       	pop	r16
     cd8:	08 95       	ret

00000cda <init_devices>:

void init_devices (void)
{
 cli();          //Clears the global interrupts
     cda:	f8 94       	cli
 port_init();
     cdc:	0e 94 51 05 	call	0xaa2	; 0xaa2 <port_init>
 timer1_init();
     ce0:	0e 94 58 05 	call	0xab0	; 0xab0 <timer1_init>
 adc_init();
     ce4:	0e 94 68 05 	call	0xad0	; 0xad0 <adc_init>
 sei();          //Enables the global interrupts
     ce8:	78 94       	sei
}
     cea:	08 95       	ret

00000cec <line_follower>:

//Main Function
int line_follower(void)
{
     cec:	cf 93       	push	r28
     cee:	df 93       	push	r29
 //unsigned char flag ;

 init_devices();
     cf0:	0e 94 6d 06 	call	0xcda	; 0xcda <init_devices>



 velocity(VELOCITY_MAX,VELOCITY_MAX);    // Set the speed to max velocity
     cf4:	8c e3       	ldi	r24, 0x3C	; 60
     cf6:	6c e3       	ldi	r22, 0x3C	; 60
     cf8:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>

 //forward();                              // start to move froward

 
	Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
     cfc:	83 e0       	ldi	r24, 0x03	; 3
     cfe:	0e 94 70 05 	call	0xae0	; 0xae0 <ADC_Conversion>
     d02:	80 93 70 00 	sts	0x0070, r24
	Center_white_line = ADC_Conversion(4);	//Getting data of Center WL Sensor
     d06:	84 e0       	ldi	r24, 0x04	; 4
     d08:	0e 94 70 05 	call	0xae0	; 0xae0 <ADC_Conversion>
     d0c:	80 93 6f 00 	sts	0x006F, r24
	Right_white_line = ADC_Conversion(5);	//Getting data of Right WL Sensor
     d10:	85 e0       	ldi	r24, 0x05	; 5
     d12:	0e 94 70 05 	call	0xae0	; 0xae0 <ADC_Conversion>
     d16:	80 93 6e 00 	sts	0x006E, r24
 
	print_sensor(1,1,3);		//Prints value of White Line Sensor Left
     d1a:	81 e0       	ldi	r24, 0x01	; 1
     d1c:	61 e0       	ldi	r22, 0x01	; 1
     d1e:	43 e0       	ldi	r20, 0x03	; 3
     d20:	0e 94 79 05 	call	0xaf2	; 0xaf2 <print_sensor>
	print_sensor(1,5,4);		//Prints value of White Line Sensor Cen.
     d24:	81 e0       	ldi	r24, 0x01	; 1
     d26:	65 e0       	ldi	r22, 0x05	; 5
     d28:	44 e0       	ldi	r20, 0x04	; 4
     d2a:	0e 94 79 05 	call	0xaf2	; 0xaf2 <print_sensor>
	
	//ter
	print_sensor(1,9,5);		//Prints value of White Line Sensor Right
     d2e:	81 e0       	ldi	r24, 0x01	; 1
     d30:	69 e0       	ldi	r22, 0x09	; 9
     d32:	45 e0       	ldi	r20, 0x05	; 5
     d34:	0e 94 79 05 	call	0xaf2	; 0xaf2 <print_sensor>

	//flag=0;

	if(Center_white_line<THRESHOLDL && Left_white_line<THRESHOLDL && Right_white_line<THRESHOLDL)               // Is middle Whiteline is within threshold limit
     d38:	80 91 6f 00 	lds	r24, 0x006F
     d3c:	8b 30       	cpi	r24, 0x0B	; 11
     d3e:	78 f4       	brcc	.+30     	; 0xd5e <line_follower+0x72>
     d40:	90 91 70 00 	lds	r25, 0x0070
     d44:	9b 30       	cpi	r25, 0x0B	; 11
     d46:	58 f4       	brcc	.+22     	; 0xd5e <line_follower+0x72>
     d48:	90 91 6e 00 	lds	r25, 0x006E
     d4c:	9b 30       	cpi	r25, 0x0B	; 11
     d4e:	38 f4       	brcc	.+14     	; 0xd5e <line_follower+0x72>
	{                                             
		//flag=1;                                                                                                  //c0,l0,r0  
		velocity(VELOCITY_MIN,VELOCITY_MIN);      // Run robot at max velocity 
     d50:	84 e1       	ldi	r24, 0x14	; 20
     d52:	64 e1       	ldi	r22, 0x14	; 20
     d54:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
		back();
     d58:	0e 94 89 05 	call	0xb12	; 0xb12 <back>
     d5c:	f5 c0       	rjmp	.+490    	; 0xf48 <line_follower+0x25c>
		
		
	}
	else if(Center_white_line>THRESHOLDH && Left_white_line<THRESHOLDL && Right_white_line<THRESHOLDL)               // Is middle Whiteline is within threshold limit
     d5e:	85 31       	cpi	r24, 0x15	; 21
     d60:	78 f0       	brcs	.+30     	; 0xd80 <line_follower+0x94>
     d62:	90 91 70 00 	lds	r25, 0x0070
     d66:	9b 30       	cpi	r25, 0x0B	; 11
     d68:	58 f4       	brcc	.+22     	; 0xd80 <line_follower+0x94>
     d6a:	90 91 6e 00 	lds	r25, 0x006E
     d6e:	9b 30       	cpi	r25, 0x0B	; 11
     d70:	38 f4       	brcc	.+14     	; 0xd80 <line_follower+0x94>
	{
		//flag=1;                                                                                                 //c1,l0,r0
		velocity(VELOCITY_MAX,VELOCITY_MAX);      // Run robot at max velocity
     d72:	8c e3       	ldi	r24, 0x3C	; 60
     d74:	6c e3       	ldi	r22, 0x3C	; 60
     d76:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
		forward();
     d7a:	0e 94 85 05 	call	0xb0a	; 0xb0a <forward>
     d7e:	e4 c0       	rjmp	.+456    	; 0xf48 <line_follower+0x25c>
		
	}


	
	else if(Center_white_line<THRESHOLDL && Left_white_line<THRESHOLDL && Right_white_line>THRESHOLDH)  // Is left Whiteline is not within threshold limit
     d80:	8b 30       	cpi	r24, 0x0B	; 11
     d82:	78 f4       	brcc	.+30     	; 0xda2 <line_follower+0xb6>
     d84:	90 91 70 00 	lds	r25, 0x0070
     d88:	9b 30       	cpi	r25, 0x0B	; 11
     d8a:	58 f4       	brcc	.+22     	; 0xda2 <line_follower+0xb6>
     d8c:	90 91 6e 00 	lds	r25, 0x006E
     d90:	95 31       	cpi	r25, 0x15	; 21
     d92:	38 f0       	brcs	.+14     	; 0xda2 <line_follower+0xb6>
	{                                             
	    //	flag=1;                                                                                                     //c0,l0,r1
		velocity(VELOCITY_MAX,VELOCITY_MIN);      // Run robot left wheel at max velocity and right wheel 
     d94:	8c e3       	ldi	r24, 0x3C	; 60
     d96:	64 e1       	ldi	r22, 0x14	; 20
     d98:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
		right();
     d9c:	0e 94 91 05 	call	0xb22	; 0xb22 <right>
     da0:	d3 c0       	rjmp	.+422    	; 0xf48 <line_follower+0x25c>
		
	}
	
	else if(Center_white_line>THRESHOLDH && Left_white_line<THRESHOLDL && Right_white_line>THRESHOLDH)  // Is left Whiteline is not within threshold limit
     da2:	85 31       	cpi	r24, 0x15	; 21
     da4:	78 f0       	brcs	.+30     	; 0xdc4 <line_follower+0xd8>
     da6:	90 91 70 00 	lds	r25, 0x0070
     daa:	9b 30       	cpi	r25, 0x0B	; 11
     dac:	58 f4       	brcc	.+22     	; 0xdc4 <line_follower+0xd8>
     dae:	90 91 6e 00 	lds	r25, 0x006E
     db2:	95 31       	cpi	r25, 0x15	; 21
     db4:	38 f0       	brcs	.+14     	; 0xdc4 <line_follower+0xd8>
	{                                                                                                                  //c1,l0,r1                 
		//	flag=1;
		velocity(VELOCITY_MAX,VELOCITY_MIN);      // Run robot left wheel at max velocity and right wheel
     db6:	8c e3       	ldi	r24, 0x3C	; 60
     db8:	64 e1       	ldi	r22, 0x14	; 20
     dba:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
		S_R();
     dbe:	0e 94 9d 05 	call	0xb3a	; 0xb3a <S_R>
     dc2:	c2 c0       	rjmp	.+388    	; 0xf48 <line_follower+0x25c>
		
	}

	
	else if(Center_white_line<THRESHOLDL && Left_white_line>THRESHOLDH && Right_white_line<THRESHOLDL ) // Is right Whiteline is not within threshold limit
     dc4:	8b 30       	cpi	r24, 0x0B	; 11
     dc6:	78 f4       	brcc	.+30     	; 0xde6 <line_follower+0xfa>
     dc8:	90 91 70 00 	lds	r25, 0x0070
     dcc:	95 31       	cpi	r25, 0x15	; 21
     dce:	58 f0       	brcs	.+22     	; 0xde6 <line_follower+0xfa>
     dd0:	90 91 6e 00 	lds	r25, 0x006E
     dd4:	9b 30       	cpi	r25, 0x0B	; 11
     dd6:	38 f4       	brcc	.+14     	; 0xde6 <line_follower+0xfa>
	{
		//flag=1;                                                                                                 //c0,l1,r0
		velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel 
     dd8:	84 e1       	ldi	r24, 0x14	; 20
     dda:	6c e3       	ldi	r22, 0x3C	; 60
     ddc:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
		s_L();
     de0:	0e 94 99 05 	call	0xb32	; 0xb32 <s_L>
     de4:	b1 c0       	rjmp	.+354    	; 0xf48 <line_follower+0x25c>
		
	}
	else if(Center_white_line>THRESHOLDH && Left_white_line>THRESHOLDH && Right_white_line<THRESHOLDL ) // Is right Whiteline is not within threshold limit
     de6:	85 31       	cpi	r24, 0x15	; 21
     de8:	08 f4       	brcc	.+2      	; 0xdec <line_follower+0x100>
     dea:	ae c0       	rjmp	.+348    	; 0xf48 <line_follower+0x25c>
     dec:	80 91 70 00 	lds	r24, 0x0070
     df0:	85 31       	cpi	r24, 0x15	; 21
     df2:	08 f4       	brcc	.+2      	; 0xdf6 <line_follower+0x10a>
     df4:	a9 c0       	rjmp	.+338    	; 0xf48 <line_follower+0x25c>
     df6:	80 91 6e 00 	lds	r24, 0x006E
     dfa:	8b 30       	cpi	r24, 0x0B	; 11
     dfc:	08 f0       	brcs	.+2      	; 0xe00 <line_follower+0x114>
     dfe:	a9 c0       	rjmp	.+338    	; 0xf52 <line_follower+0x266>
	{                                                                                                             //c1,l1,r0
		//flag=1; 
		velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel
     e00:	84 e1       	ldi	r24, 0x14	; 20
     e02:	6c e3       	ldi	r22, 0x3C	; 60
     e04:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
		left();
     e08:	0e 94 8d 05 	call	0xb1a	; 0xb1a <left>
     e0c:	9d c0       	rjmp	.+314    	; 0xf48 <line_follower+0x25c>
	else if(Center_white_line>THRESHOLDH && Left_white_line>THRESHOLDH && Right_white_line>THRESHOLDH)
	                                // if all Whiteline sensor are not within threshold limit                      //c1,l1,r1   
	{                       
		//flag=1;
		//velocity(VELOCITY_LOW,VELOCITY_LOW);      // stop the robot
		buzzer_beep();
     e0e:	0e 94 c8 00 	call	0x190	; 0x190 <buzzer_beep>
		
		stop_pos();   
     e12:	0e 94 41 03 	call	0x682	; 0x682 <stop_pos>
			forward();     // stop the robot
		_delay_ms(1300);*/
	//	lcd_print(2,1,path1.path[l],3);	
		//l++;
		
		if(stage==2)
     e16:	80 91 65 00 	lds	r24, 0x0065
     e1a:	82 30       	cpi	r24, 0x02	; 2
     e1c:	21 f4       	brne	.+8      	; 0xe26 <line_follower+0x13a>
			{	
				servo100();
     e1e:	0e 94 80 04 	call	0x900	; 0x900 <servo100>
				servo101();
     e22:	0e 94 dd 04 	call	0x9ba	; 0x9ba <servo101>
				//1000 1111		
			}
			
			if(stage==3)
     e26:	80 91 65 00 	lds	r24, 0x0065
     e2a:	83 30       	cpi	r24, 0x03	; 3
     e2c:	09 f0       	breq	.+2      	; 0xe30 <line_follower+0x144>
     e2e:	86 c0       	rjmp	.+268    	; 0xf3c <line_follower+0x250>
			{	unsigned char count=0;
				unsigned char i;
				if(path1.path[t]==46 )
     e30:	80 91 76 00 	lds	r24, 0x0076
     e34:	e8 ec       	ldi	r30, 0xC8	; 200
     e36:	f0 e0       	ldi	r31, 0x00	; 0
     e38:	e8 0f       	add	r30, r24
     e3a:	f1 1d       	adc	r31, r1
     e3c:	80 81       	ld	r24, Z
     e3e:	8e 32       	cpi	r24, 0x2E	; 46
     e40:	a9 f4       	brne	.+42     	; 0xe6c <line_follower+0x180>
				{	
					init_devices_pos();
     e42:	0e 94 1c 04 	call	0x838	; 0x838 <init_devices_pos>
					right_degrees(100);
     e46:	84 e6       	ldi	r24, 0x64	; 100
     e48:	90 e0       	ldi	r25, 0x00	; 0
     e4a:	0e 94 dd 03 	call	0x7ba	; 0x7ba <right_degrees>
					stop_pos();
     e4e:	0e 94 41 03 	call	0x682	; 0x682 <stop_pos>
     e52:	8f ef       	ldi	r24, 0xFF	; 255
     e54:	9f e3       	ldi	r25, 0x3F	; 63
     e56:	ab e0       	ldi	r26, 0x0B	; 11
     e58:	81 50       	subi	r24, 0x01	; 1
     e5a:	90 40       	sbci	r25, 0x00	; 0
     e5c:	a0 40       	sbci	r26, 0x00	; 0
     e5e:	e1 f7       	brne	.-8      	; 0xe58 <line_follower+0x16c>
     e60:	00 c0       	rjmp	.+0      	; 0xe62 <line_follower+0x176>
     e62:	00 00       	nop
					_delay_ms(500);
					dir=1;
     e64:	81 e0       	ldi	r24, 0x01	; 1
     e66:	80 93 66 00 	sts	0x0066, r24
     e6a:	1a c0       	rjmp	.+52     	; 0xea0 <line_follower+0x1b4>
					
				}	
				else if(path1.path[t]==2 )
     e6c:	82 30       	cpi	r24, 0x02	; 2
     e6e:	c1 f4       	brne	.+48     	; 0xea0 <line_follower+0x1b4>
				{
					
					init_devices_pos();
     e70:	0e 94 1c 04 	call	0x838	; 0x838 <init_devices_pos>
					
					if(des!=8)
     e74:	80 91 67 00 	lds	r24, 0x0067
     e78:	88 30       	cpi	r24, 0x08	; 8
     e7a:	91 f0       	breq	.+36     	; 0xea0 <line_follower+0x1b4>
					{
						left_degrees(100);
     e7c:	84 e6       	ldi	r24, 0x64	; 100
     e7e:	90 e0       	ldi	r25, 0x00	; 0
     e80:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <left_degrees>
						stop_pos();
     e84:	0e 94 41 03 	call	0x682	; 0x682 <stop_pos>
     e88:	8f ef       	ldi	r24, 0xFF	; 255
     e8a:	9f e3       	ldi	r25, 0x3F	; 63
     e8c:	ab e0       	ldi	r26, 0x0B	; 11
     e8e:	81 50       	subi	r24, 0x01	; 1
     e90:	90 40       	sbci	r25, 0x00	; 0
     e92:	a0 40       	sbci	r26, 0x00	; 0
     e94:	e1 f7       	brne	.-8      	; 0xe8e <line_follower+0x1a2>
     e96:	00 c0       	rjmp	.+0      	; 0xe98 <line_follower+0x1ac>
     e98:	00 00       	nop
						_delay_ms(500);
						dir=3;
     e9a:	83 e0       	ldi	r24, 0x03	; 3
     e9c:	80 93 66 00 	sts	0x0066, r24
					}
					
					
				}	
				
				for ( i=0;i<r;i++)
     ea0:	80 91 73 00 	lds	r24, 0x0073
     ea4:	88 23       	and	r24, r24
     ea6:	09 f4       	brne	.+2      	; 0xeaa <line_follower+0x1be>
     ea8:	52 c0       	rjmp	.+164    	; 0xf4e <line_follower+0x262>
				{
					
					if(path1.path[t]==red_nodes[i])
     eaa:	80 91 76 00 	lds	r24, 0x0076
     eae:	e8 ec       	ldi	r30, 0xC8	; 200
     eb0:	f0 e0       	ldi	r31, 0x00	; 0
     eb2:	e8 0f       	add	r30, r24
     eb4:	f1 1d       	adc	r31, r1
     eb6:	50 81       	ld	r21, Z
     eb8:	80 91 f3 00 	lds	r24, 0x00F3
     ebc:	58 17       	cp	r21, r24
     ebe:	69 f0       	breq	.+26     	; 0xeda <line_follower+0x1ee>
					}
					
					
				}	
				
				for ( i=0;i<r;i++)
     ec0:	c0 e0       	ldi	r28, 0x00	; 0
				{
					
					if(path1.path[t]==red_nodes[i])
     ec2:	23 ef       	ldi	r18, 0xF3	; 243
     ec4:	30 e0       	ldi	r19, 0x00	; 0
     ec6:	1b c0       	rjmp	.+54     	; 0xefe <line_follower+0x212>
     ec8:	8c 2f       	mov	r24, r28
     eca:	90 e0       	ldi	r25, 0x00	; 0
     ecc:	f9 01       	movw	r30, r18
     ece:	e8 0f       	add	r30, r24
     ed0:	f9 1f       	adc	r31, r25
     ed2:	40 81       	ld	r20, Z
     ed4:	54 17       	cp	r21, r20
     ed6:	99 f4       	brne	.+38     	; 0xefe <line_follower+0x212>
     ed8:	03 c0       	rjmp	.+6      	; 0xee0 <line_follower+0x1f4>
     eda:	80 e0       	ldi	r24, 0x00	; 0
     edc:	90 e0       	ldi	r25, 0x00	; 0
					}
					
					
				}	
				
				for ( i=0;i<r;i++)
     ede:	c0 e0       	ldi	r28, 0x00	; 0
				{
					
					if(path1.path[t]==red_nodes[i])
					{
						if (path1.path[t]==red_nodes[i+1])
     ee0:	8c 50       	subi	r24, 0x0C	; 12
     ee2:	9f 4f       	sbci	r25, 0xFF	; 255
     ee4:	dc 01       	movw	r26, r24
     ee6:	8c 91       	ld	r24, X
				servo101();
				//1000 1111		
			}
			
			if(stage==3)
			{	unsigned char count=0;
     ee8:	d1 e0       	ldi	r29, 0x01	; 1
     eea:	58 13       	cpse	r21, r24
     eec:	d0 e0       	ldi	r29, 0x00	; 0
						}
						count++;
						break;
					}
				}
				if (count>0)
     eee:	df 5f       	subi	r29, 0xFF	; 255
				{buzzer_beep();
     ef0:	0e 94 c8 00 	call	0x190	; 0x190 <buzzer_beep>
					buzzer_beep();
     ef4:	0e 94 c8 00 	call	0x190	; 0x190 <buzzer_beep>
					
				}
				if(count==1)
     ef8:	d1 30       	cpi	r29, 0x01	; 1
     efa:	41 f0       	breq	.+16     	; 0xf0c <line_follower+0x220>
     efc:	19 c0       	rjmp	.+50     	; 0xf30 <line_follower+0x244>
					}
					
					
				}	
				
				for ( i=0;i<r;i++)
     efe:	cf 5f       	subi	r28, 0xFF	; 255
     f00:	80 91 73 00 	lds	r24, 0x0073
     f04:	c8 17       	cp	r28, r24
     f06:	00 f3       	brcs	.-64     	; 0xec8 <line_follower+0x1dc>
     f08:	d0 e0       	ldi	r29, 0x00	; 0
     f0a:	12 c0       	rjmp	.+36     	; 0xf30 <line_follower+0x244>
					buzzer_beep();
					
				}
				if(count==1)
				{
					if(red_side[i]==100)
     f0c:	d0 e0       	ldi	r29, 0x00	; 0
     f0e:	fe 01       	movw	r30, r28
     f10:	e1 50       	subi	r30, 0x01	; 1
     f12:	ff 4f       	sbci	r31, 0xFF	; 255
     f14:	80 81       	ld	r24, Z
     f16:	84 36       	cpi	r24, 0x64	; 100
     f18:	19 f4       	brne	.+6      	; 0xf20 <line_follower+0x234>
					{
						servo100();
     f1a:	0e 94 80 04 	call	0x900	; 0x900 <servo100>
     f1e:	0e c0       	rjmp	.+28     	; 0xf3c <line_follower+0x250>
					}
					else if(red_side[i]==101)
     f20:	c1 50       	subi	r28, 0x01	; 1
     f22:	df 4f       	sbci	r29, 0xFF	; 255
     f24:	88 81       	ld	r24, Y
     f26:	85 36       	cpi	r24, 0x65	; 101
     f28:	49 f4       	brne	.+18     	; 0xf3c <line_follower+0x250>
					{
						servo101();
     f2a:	0e 94 dd 04 	call	0x9ba	; 0x9ba <servo101>
     f2e:	06 c0       	rjmp	.+12     	; 0xf3c <line_follower+0x250>
					}
					
				}
				if(count==2)
     f30:	d2 30       	cpi	r29, 0x02	; 2
     f32:	21 f4       	brne	.+8      	; 0xf3c <line_follower+0x250>
				{
					servo100();
     f34:	0e 94 80 04 	call	0x900	; 0x900 <servo100>
					servo101();
     f38:	0e 94 dd 04 	call	0x9ba	; 0x9ba <servo101>
				}
				count=0;
			}
			
			init_devices();
     f3c:	0e 94 6d 06 	call	0xcda	; 0xcda <init_devices>
			direction();
     f40:	0e 94 22 0a 	call	0x1444	; 0x1444 <direction>
		
		
		
		
		
		hard_stop();
     f44:	0e 94 95 05 	call	0xb2a	; 0xb2a <hard_stop>
		
	}
	

 
}
     f48:	df 91       	pop	r29
     f4a:	cf 91       	pop	r28
     f4c:	08 95       	ret
					}
					
					
				}	
				
				for ( i=0;i<r;i++)
     f4e:	d0 e0       	ldi	r29, 0x00	; 0
     f50:	ef cf       	rjmp	.-34     	; 0xf30 <line_follower+0x244>
		velocity(VELOCITY_MIN,VELOCITY_MAX);      // Run robot right wheel at max velocity and left wheel
		left();
		
	}
                
	else if(Center_white_line>THRESHOLDH && Left_white_line>THRESHOLDH && Right_white_line>THRESHOLDH)
     f52:	80 91 6e 00 	lds	r24, 0x006E
     f56:	85 31       	cpi	r24, 0x15	; 21
     f58:	b8 f3       	brcs	.-18     	; 0xf48 <line_follower+0x25c>
     f5a:	59 cf       	rjmp	.-334    	; 0xe0e <line_follower+0x122>

00000f5c <color_sensor_pin_config>:
Blue_led pc6
*/

void color_sensor_pin_config(void)
{
	DDRD  = DDRD & 0xBF;  //Set the direction of the PORTD 6 pin as input 1011 1111
     f5c:	8e 98       	cbi	0x11, 6	; 17
	PORTD = PORTD | 0x40; //pullup pd6 0100 0000
     f5e:	96 9a       	sbi	0x12, 6	; 18
}
     f60:	08 95       	ret

00000f62 <port_init_color>:
void port_init_color(void)
{
	
	color_sensor_pin_config();//color sensor pin configuration
     f62:	0e 94 ae 07 	call	0xf5c	; 0xf5c <color_sensor_pin_config>
}
     f66:	08 95       	ret

00000f68 <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
     f68:	f8 94       	cli
	//EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
	TCCR1A=0;
     f6a:	1f bc       	out	0x2f, r1	; 47
	TCCR1B=0x81;//falling edge,noise cancel, no prescale
     f6c:	81 e8       	ldi	r24, 0x81	; 129
     f6e:	8e bd       	out	0x2e, r24	; 46
	TIMSK=(1<<TICIE1);//ip capt and  NO overflow interrupt
     f70:	80 e2       	ldi	r24, 0x20	; 32
     f72:	89 bf       	out	0x39, r24	; 57
	//EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
	sei(); // Enables the global interrupt
     f74:	78 94       	sei
}
     f76:	08 95       	ret

00000f78 <__vector_5>:
ISR(TIMER1_CAPT_vect)
{
     f78:	1f 92       	push	r1
     f7a:	0f 92       	push	r0
     f7c:	0f b6       	in	r0, 0x3f	; 63
     f7e:	0f 92       	push	r0
     f80:	11 24       	eor	r1, r1
     f82:	8f 93       	push	r24
     f84:	9f 93       	push	r25
     f86:	af 93       	push	r26
     f88:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     f8a:	80 91 6a 00 	lds	r24, 0x006A
     f8e:	90 91 6b 00 	lds	r25, 0x006B
     f92:	a0 91 6c 00 	lds	r26, 0x006C
     f96:	b0 91 6d 00 	lds	r27, 0x006D
     f9a:	01 96       	adiw	r24, 0x01	; 1
     f9c:	a1 1d       	adc	r26, r1
     f9e:	b1 1d       	adc	r27, r1
     fa0:	80 93 6a 00 	sts	0x006A, r24
     fa4:	90 93 6b 00 	sts	0x006B, r25
     fa8:	a0 93 6c 00 	sts	0x006C, r26
     fac:	b0 93 6d 00 	sts	0x006D, r27
}
     fb0:	bf 91       	pop	r27
     fb2:	af 91       	pop	r26
     fb4:	9f 91       	pop	r25
     fb6:	8f 91       	pop	r24
     fb8:	0f 90       	pop	r0
     fba:	0f be       	out	0x3f, r0	; 63
     fbc:	0f 90       	pop	r0
     fbe:	1f 90       	pop	r1
     fc0:	18 95       	reti

00000fc2 <init_devices_color>:
void init_devices_color(void)
{
	cli(); //Clears the global interrupt
     fc2:	f8 94       	cli
	port_init_color();  //Initializes all the ports
     fc4:	0e 94 b1 07 	call	0xf62	; 0xf62 <port_init_color>
	color_sensor_pin_interrupt_init();
     fc8:	0e 94 b4 07 	call	0xf68	; 0xf68 <color_sensor_pin_interrupt_init>
	sei();   // Enables the global interrupt
     fcc:	78 94       	sei
}
     fce:	08 95       	ret

00000fd0 <filter_red>:
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	/*PORTC= PORTC & 0xFE; //set S2 low
	PORTC = PORTC & 0xF7; //set S37F lowpd2*/
	PORTC= PORTC & 0xFB; //set S2 low 1111 1011
     fd0:	aa 98       	cbi	0x15, 2	; 21
	PORTC = PORTC & 0x7F; //set S37F lowpd2 0111 1111
     fd2:	af 98       	cbi	0x15, 7	; 21
}
     fd4:	08 95       	ret

00000fd6 <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	
	PORTC = PORTC | 0x04; //set S2 High 0000 0100
     fd6:	aa 9a       	sbi	0x15, 2	; 21
	PORTC = PORTC | 0x80; //set S3 High 1000 0000
     fd8:	af 9a       	sbi	0x15, 7	; 21
}
     fda:	08 95       	ret

00000fdc <filter_blue>:
void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	/*PORTD = PORTD & 0xF7; //set S2 low
	PORTD = PORTD | 0x04; //set S3 High*/
	PORTC= PORTC & 0xFB; //set S2 low 1111 1011
     fdc:	aa 98       	cbi	0x15, 2	; 21
	PORTC = PORTC | 0x80; //set S3 High 1000 0000
     fde:	af 9a       	sbi	0x15, 7	; 21
}
     fe0:	08 95       	ret

00000fe2 <filter_clear>:
void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	/*PORTD = PORTD | 0x08; //set S2 High
	PORTD = PORTD & 0xFB; //set S3 Low*/
	PORTC = PORTC | 0x04;  //set S2 High 0000 0100
     fe2:	aa 9a       	sbi	0x15, 2	; 21
	PORTC = PORTC & 0x7F; //set S3 Low 0111 1111
     fe4:	af 98       	cbi	0x15, 7	; 21
}
     fe6:	08 95       	ret

00000fe8 <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xFE;
	PORTC = PORTC | 0x01; //set S0 high 0000 0001
     fe8:	a8 9a       	sbi	0x15, 0	; 21
	PORTC = PORTC & 0xFD; //set S1 low 1111 1101
     fea:	a9 98       	cbi	0x15, 1	; 21
	//PORTD = PORTD | 0x02; //set S1 high 
}
     fec:	08 95       	ret

00000fee <red_read>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
     fee:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <filter_red>
	pulse=0; //reset the count to 0
     ff2:	10 92 6a 00 	sts	0x006A, r1
     ff6:	10 92 6b 00 	sts	0x006B, r1
     ffa:	10 92 6c 00 	sts	0x006C, r1
     ffe:	10 92 6d 00 	sts	0x006D, r1
    1002:	8f ef       	ldi	r24, 0xFF	; 255
    1004:	9f e3       	ldi	r25, 0x3F	; 63
    1006:	a2 e0       	ldi	r26, 0x02	; 2
    1008:	81 50       	subi	r24, 0x01	; 1
    100a:	90 40       	sbci	r25, 0x00	; 0
    100c:	a0 40       	sbci	r26, 0x00	; 0
    100e:	e1 f7       	brne	.-8      	; 0x1008 <red_read+0x1a>
    1010:	00 c0       	rjmp	.+0      	; 0x1012 <red_read+0x24>
    1012:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
    1014:	80 91 6a 00 	lds	r24, 0x006A
    1018:	90 91 6b 00 	lds	r25, 0x006B
    101c:	a0 91 6c 00 	lds	r26, 0x006C
    1020:	b0 91 6d 00 	lds	r27, 0x006D
    1024:	80 93 c4 00 	sts	0x00C4, r24
    1028:	90 93 c5 00 	sts	0x00C5, r25
    102c:	a0 93 c6 00 	sts	0x00C6, r26
    1030:	b0 93 c7 00 	sts	0x00C7, r27
	lcd_string("Red Pulses"); // Display "Red Pulses" on LCD
	lcd_print(2,1,red,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD
	*/
}
    1034:	08 95       	ret

00001036 <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
    1036:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <filter_green>
	pulse=0; //reset the count to 0
    103a:	10 92 6a 00 	sts	0x006A, r1
    103e:	10 92 6b 00 	sts	0x006B, r1
    1042:	10 92 6c 00 	sts	0x006C, r1
    1046:	10 92 6d 00 	sts	0x006D, r1
    104a:	8f ef       	ldi	r24, 0xFF	; 255
    104c:	9f e3       	ldi	r25, 0x3F	; 63
    104e:	a2 e0       	ldi	r26, 0x02	; 2
    1050:	81 50       	subi	r24, 0x01	; 1
    1052:	90 40       	sbci	r25, 0x00	; 0
    1054:	a0 40       	sbci	r26, 0x00	; 0
    1056:	e1 f7       	brne	.-8      	; 0x1050 <green_read+0x1a>
    1058:	00 c0       	rjmp	.+0      	; 0x105a <green_read+0x24>
    105a:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
    105c:	80 91 6a 00 	lds	r24, 0x006A
    1060:	90 91 6b 00 	lds	r25, 0x006B
    1064:	a0 91 6c 00 	lds	r26, 0x006C
    1068:	b0 91 6d 00 	lds	r27, 0x006D
    106c:	80 93 c0 00 	sts	0x00C0, r24
    1070:	90 93 c1 00 	sts	0x00C1, r25
    1074:	a0 93 c2 00 	sts	0x00C2, r26
    1078:	b0 93 c3 00 	sts	0x00C3, r27
	lcd_string("Green Pulses"); // Display "Green Pulses" on LCD
	lcd_print(2,1,green,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD

*/}
    107c:	08 95       	ret

0000107e <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
    107e:	0e 94 ee 07 	call	0xfdc	; 0xfdc <filter_blue>
	pulse=0; //reset the count to 0
    1082:	10 92 6a 00 	sts	0x006A, r1
    1086:	10 92 6b 00 	sts	0x006B, r1
    108a:	10 92 6c 00 	sts	0x006C, r1
    108e:	10 92 6d 00 	sts	0x006D, r1
    1092:	8f ef       	ldi	r24, 0xFF	; 255
    1094:	9f e3       	ldi	r25, 0x3F	; 63
    1096:	a2 e0       	ldi	r26, 0x02	; 2
    1098:	81 50       	subi	r24, 0x01	; 1
    109a:	90 40       	sbci	r25, 0x00	; 0
    109c:	a0 40       	sbci	r26, 0x00	; 0
    109e:	e1 f7       	brne	.-8      	; 0x1098 <blue_read+0x1a>
    10a0:	00 c0       	rjmp	.+0      	; 0x10a2 <blue_read+0x24>
    10a2:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
    10a4:	80 91 6a 00 	lds	r24, 0x006A
    10a8:	90 91 6b 00 	lds	r25, 0x006B
    10ac:	a0 91 6c 00 	lds	r26, 0x006C
    10b0:	b0 91 6d 00 	lds	r27, 0x006D
    10b4:	80 93 9a 00 	sts	0x009A, r24
    10b8:	90 93 9b 00 	sts	0x009B, r25
    10bc:	a0 93 9c 00 	sts	0x009C, r26
    10c0:	b0 93 9d 00 	sts	0x009D, r27
	lcd_string("Blue Pulses"); // Display "Blue Pulses" on LCD
	lcd_print(2,1,blue,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD
	*/
}
    10c4:	08 95       	ret

000010c6 <colour>:
void colour(unsigned long int red_pulse, unsigned long int green_pulse,unsigned long int blue_pulse)
{	
    10c6:	8f 92       	push	r8
    10c8:	9f 92       	push	r9
    10ca:	af 92       	push	r10
    10cc:	bf 92       	push	r11
    10ce:	ef 92       	push	r14
    10d0:	ff 92       	push	r15
    10d2:	0f 93       	push	r16
    10d4:	1f 93       	push	r17
    10d6:	4b 01       	movw	r8, r22
    10d8:	5c 01       	movw	r10, r24
    10da:	da 01       	movw	r26, r20
    10dc:	c9 01       	movw	r24, r18
    10de:	b8 01       	movw	r22, r16
    10e0:	a7 01       	movw	r20, r14
	if(red_pulse>green_pulse && red_pulse>blue_pulse)
    10e2:	88 15       	cp	r24, r8
    10e4:	99 05       	cpc	r25, r9
    10e6:	aa 05       	cpc	r26, r10
    10e8:	bb 05       	cpc	r27, r11
    10ea:	68 f4       	brcc	.+26     	; 0x1106 <colour+0x40>
    10ec:	e8 14       	cp	r14, r8
    10ee:	f9 04       	cpc	r15, r9
    10f0:	0a 05       	cpc	r16, r10
    10f2:	1b 05       	cpc	r17, r11
    10f4:	40 f4       	brcc	.+16     	; 0x1106 <colour+0x40>
	{
		//red greatest
		PORTC=PORTC|(1<<PC4);
    10f6:	ac 9a       	sbi	0x15, 4	; 21
		PORTC=PORTC & 0x9F; //clear pc5 and pc6 1001 1111
    10f8:	85 b3       	in	r24, 0x15	; 21
    10fa:	8f 79       	andi	r24, 0x9F	; 159
    10fc:	85 bb       	out	0x15, r24	; 21
		task=1;
    10fe:	81 e0       	ldi	r24, 0x01	; 1
    1100:	80 93 75 00 	sts	0x0075, r24
    1104:	14 c0       	rjmp	.+40     	; 0x112e <colour+0x68>
	}
	else if(green_pulse>blue_pulse)
    1106:	48 17       	cp	r20, r24
    1108:	59 07       	cpc	r21, r25
    110a:	6a 07       	cpc	r22, r26
    110c:	7b 07       	cpc	r23, r27
    110e:	40 f4       	brcc	.+16     	; 0x1120 <colour+0x5a>
	{
		//green greatest
		PORTC=PORTC|(1<<PC5);
    1110:	ad 9a       	sbi	0x15, 5	; 21
		PORTC=PORTC & 0xAF; //clear pc4 and pc6 1010 1111
    1112:	85 b3       	in	r24, 0x15	; 21
    1114:	8f 7a       	andi	r24, 0xAF	; 175
    1116:	85 bb       	out	0x15, r24	; 21
		task=2;
    1118:	82 e0       	ldi	r24, 0x02	; 2
    111a:	80 93 75 00 	sts	0x0075, r24
    111e:	07 c0       	rjmp	.+14     	; 0x112e <colour+0x68>
		
	}
	else
	{
		//blue greatest
		PORTC=PORTC|(1<<PC6);
    1120:	ae 9a       	sbi	0x15, 6	; 21
		PORTC=PORTC & 0xCF; //clear pc5 and pc4 1100 1111
    1122:	85 b3       	in	r24, 0x15	; 21
    1124:	8f 7c       	andi	r24, 0xCF	; 207
    1126:	85 bb       	out	0x15, r24	; 21
		task=3;
    1128:	83 e0       	ldi	r24, 0x03	; 3
    112a:	80 93 75 00 	sts	0x0075, r24
	}
}
    112e:	1f 91       	pop	r17
    1130:	0f 91       	pop	r16
    1132:	ff 90       	pop	r15
    1134:	ef 90       	pop	r14
    1136:	bf 90       	pop	r11
    1138:	af 90       	pop	r10
    113a:	9f 90       	pop	r9
    113c:	8f 90       	pop	r8
    113e:	08 95       	ret

00001140 <color_sensor_work>:


void color_sensor_work()
{	
    1140:	ef 92       	push	r14
    1142:	ff 92       	push	r15
    1144:	0f 93       	push	r16
    1146:	1f 93       	push	r17
    1148:	cf 93       	push	r28
    114a:	df 93       	push	r29
	
	init_devices_color();
    114c:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <init_devices_color>
	DDRC = DDRC | 0xFF;//port c pins as output 
    1150:	84 b3       	in	r24, 0x14	; 20
    1152:	8f ef       	ldi	r24, 0xFF	; 255
    1154:	84 bb       	out	0x14, r24	; 20
	PORTC=0x00;
    1156:	15 ba       	out	0x15, r1	; 21
	color_sensor_scaling();
    1158:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <color_sensor_scaling>
	if(stage==2)
    115c:	80 91 65 00 	lds	r24, 0x0065
    1160:	82 30       	cpi	r24, 0x02	; 2
    1162:	71 f5       	brne	.+92     	; 0x11c0 <color_sensor_work+0x80>
    1164:	c5 e0       	ldi	r28, 0x05	; 5
    1166:	d0 e0       	ldi	r29, 0x00	; 0
	{
		for (int i=0;i<5;i++)
		{
			red_read(); //display the pulse count when red filter is selected
    1168:	0e 94 f7 07 	call	0xfee	; 0xfee <red_read>
			//_delay_ms(500);
			green_read(); //display the pulse count when green filter is selected
    116c:	0e 94 1b 08 	call	0x1036	; 0x1036 <green_read>
			//_delay_ms(500);
			blue_read(); //display the pulse count when blue filter is selected
    1170:	0e 94 3f 08 	call	0x107e	; 0x107e <blue_read>
			//_delay_ms(500);
			colour(red,green,blue);
    1174:	60 91 c4 00 	lds	r22, 0x00C4
    1178:	70 91 c5 00 	lds	r23, 0x00C5
    117c:	80 91 c6 00 	lds	r24, 0x00C6
    1180:	90 91 c7 00 	lds	r25, 0x00C7
    1184:	20 91 c0 00 	lds	r18, 0x00C0
    1188:	30 91 c1 00 	lds	r19, 0x00C1
    118c:	40 91 c2 00 	lds	r20, 0x00C2
    1190:	50 91 c3 00 	lds	r21, 0x00C3
    1194:	e0 90 9a 00 	lds	r14, 0x009A
    1198:	f0 90 9b 00 	lds	r15, 0x009B
    119c:	00 91 9c 00 	lds	r16, 0x009C
    11a0:	10 91 9d 00 	lds	r17, 0x009D
    11a4:	0e 94 63 08 	call	0x10c6	; 0x10c6 <colour>
    11a8:	8f ef       	ldi	r24, 0xFF	; 255
    11aa:	9f e3       	ldi	r25, 0x3F	; 63
    11ac:	ab e0       	ldi	r26, 0x0B	; 11
    11ae:	81 50       	subi	r24, 0x01	; 1
    11b0:	90 40       	sbci	r25, 0x00	; 0
    11b2:	a0 40       	sbci	r26, 0x00	; 0
    11b4:	e1 f7       	brne	.-8      	; 0x11ae <color_sensor_work+0x6e>
    11b6:	00 c0       	rjmp	.+0      	; 0x11b8 <color_sensor_work+0x78>
    11b8:	00 00       	nop
    11ba:	21 97       	sbiw	r28, 0x01	; 1
	DDRC = DDRC | 0xFF;//port c pins as output 
	PORTC=0x00;
	color_sensor_scaling();
	if(stage==2)
	{
		for (int i=0;i<5;i++)
    11bc:	a9 f6       	brne	.-86     	; 0x1168 <color_sensor_work+0x28>
    11be:	10 c0       	rjmp	.+32     	; 0x11e0 <color_sensor_work+0xa0>
		}
		
	}
	else
	{	//red greatest
		PORTC=PORTC|(1<<PC4);
    11c0:	ac 9a       	sbi	0x15, 4	; 21
		PORTC=PORTC & 0x9F; //clear pc5 and pc6 1001 1111
    11c2:	85 b3       	in	r24, 0x15	; 21
    11c4:	8f 79       	andi	r24, 0x9F	; 159
    11c6:	85 bb       	out	0x15, r24	; 21
		task=1;
    11c8:	81 e0       	ldi	r24, 0x01	; 1
    11ca:	80 93 75 00 	sts	0x0075, r24
    11ce:	8f ef       	ldi	r24, 0xFF	; 255
    11d0:	9f e3       	ldi	r25, 0x3F	; 63
    11d2:	ab e0       	ldi	r26, 0x0B	; 11
    11d4:	81 50       	subi	r24, 0x01	; 1
    11d6:	90 40       	sbci	r25, 0x00	; 0
    11d8:	a0 40       	sbci	r26, 0x00	; 0
    11da:	e1 f7       	brne	.-8      	; 0x11d4 <color_sensor_work+0x94>
    11dc:	00 c0       	rjmp	.+0      	; 0x11de <color_sensor_work+0x9e>
    11de:	00 00       	nop
		_delay_ms(500);
	}	
	//PORTC=PORTC& 0x8F;//1000 1111
    11e0:	df 91       	pop	r29
    11e2:	cf 91       	pop	r28
    11e4:	1f 91       	pop	r17
    11e6:	0f 91       	pop	r16
    11e8:	ff 90       	pop	r15
    11ea:	ef 90       	pop	r14
    11ec:	08 95       	ret

000011ee <buzzer_pin_config_zigbee>:
}
*/

void buzzer_pin_config_zigbee (void)
{
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as outpt
    11ee:	a3 9a       	sbi	0x14, 3	; 20
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
    11f0:	ab 98       	cbi	0x15, 3	; 21
}
    11f2:	08 95       	ret

000011f4 <port_init_zigbee>:

//Function to initialize ports
void port_init_zigbee()
{
 //motion_pin_config();
 buzzer_pin_config_zigbee();
    11f4:	0e 94 f7 08 	call	0x11ee	; 0x11ee <buzzer_pin_config_zigbee>
}
    11f8:	08 95       	ret

000011fa <uart0_init_zigbee>:
// actual: baud rate:9600 (0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init_zigbee(void)
{
 UCSRB = 0x00; //disable while setting baud rate
    11fa:	1a b8       	out	0x0a, r1	; 10
 UCSRA = 0x00;
    11fc:	1b b8       	out	0x0b, r1	; 11
 UCSRC = 0x86;
    11fe:	86 e8       	ldi	r24, 0x86	; 134
    1200:	80 bd       	out	0x20, r24	; 32
 UBRRL = 0x2F; //set baud rate lo  //67 is for 16MHz 9600 baudrate
    1202:	8f e2       	ldi	r24, 0x2F	; 47
    1204:	89 b9       	out	0x09, r24	; 9
 UBRRH = 0x00; //set baud rate hi
    1206:	10 bc       	out	0x20, r1	; 32
 UCSRB = 0x98; 
    1208:	88 e9       	ldi	r24, 0x98	; 152
    120a:	8a b9       	out	0x0a, r24	; 10
}
    120c:	08 95       	ret

0000120e <conversion>:
unsigned char conversion(unsigned char hex)
{	unsigned char node;	
	
	switch(hex)
    120e:	89 31       	cpi	r24, 0x19	; 25
    1210:	e9 f1       	breq	.+122    	; 0x128c <conversion+0x7e>
    1212:	8a 31       	cpi	r24, 0x1A	; 26
    1214:	90 f4       	brcc	.+36     	; 0x123a <conversion+0x2c>
    1216:	8b 30       	cpi	r24, 0x0B	; 11
    1218:	a9 f1       	breq	.+106    	; 0x1284 <conversion+0x76>
    121a:	8c 30       	cpi	r24, 0x0C	; 12
    121c:	38 f4       	brcc	.+14     	; 0x122c <conversion+0x1e>
    121e:	84 30       	cpi	r24, 0x04	; 4
    1220:	79 f1       	breq	.+94     	; 0x1280 <conversion+0x72>
    1222:	89 30       	cpi	r24, 0x09	; 9
    1224:	09 f1       	breq	.+66     	; 0x1268 <conversion+0x5a>
    1226:	82 30       	cpi	r24, 0x02	; 2
    1228:	f1 f5       	brne	.+124    	; 0x12a6 <conversion+0x98>
    122a:	3c c0       	rjmp	.+120    	; 0x12a4 <conversion+0x96>
    122c:	82 31       	cpi	r24, 0x12	; 18
    122e:	61 f1       	breq	.+88     	; 0x1288 <conversion+0x7a>
    1230:	87 31       	cpi	r24, 0x17	; 23
    1232:	f1 f0       	breq	.+60     	; 0x1270 <conversion+0x62>
    1234:	80 31       	cpi	r24, 0x10	; 16
    1236:	b9 f5       	brne	.+110    	; 0x12a6 <conversion+0x98>
    1238:	19 c0       	rjmp	.+50     	; 0x126c <conversion+0x5e>
    123a:	87 32       	cpi	r24, 0x27	; 39
    123c:	59 f1       	breq	.+86     	; 0x1294 <conversion+0x86>
    123e:	88 32       	cpi	r24, 0x28	; 40
    1240:	38 f4       	brcc	.+14     	; 0x1250 <conversion+0x42>
    1242:	80 32       	cpi	r24, 0x20	; 32
    1244:	29 f1       	breq	.+74     	; 0x1290 <conversion+0x82>
    1246:	85 32       	cpi	r24, 0x25	; 37
    1248:	b9 f0       	breq	.+46     	; 0x1278 <conversion+0x6a>
    124a:	8e 31       	cpi	r24, 0x1E	; 30
    124c:	61 f5       	brne	.+88     	; 0x12a6 <conversion+0x98>
    124e:	12 c0       	rjmp	.+36     	; 0x1274 <conversion+0x66>
    1250:	8e 32       	cpi	r24, 0x2E	; 46
    1252:	11 f1       	breq	.+68     	; 0x1298 <conversion+0x8a>
    1254:	8f 32       	cpi	r24, 0x2F	; 47
    1256:	18 f4       	brcc	.+6      	; 0x125e <conversion+0x50>
    1258:	8c 32       	cpi	r24, 0x2C	; 44
    125a:	29 f5       	brne	.+74     	; 0x12a6 <conversion+0x98>
    125c:	0f c0       	rjmp	.+30     	; 0x127c <conversion+0x6e>
    125e:	84 36       	cpi	r24, 0x64	; 100
    1260:	e9 f0       	breq	.+58     	; 0x129c <conversion+0x8e>
    1262:	85 36       	cpi	r24, 0x65	; 101
    1264:	01 f5       	brne	.+64     	; 0x12a6 <conversion+0x98>
    1266:	1c c0       	rjmp	.+56     	; 0x12a0 <conversion+0x92>
	{
		case 0x02:
		node=2;
		break;
		case 0x09:
		node=9;
    1268:	99 e0       	ldi	r25, 0x09	; 9
		break;
    126a:	1d c0       	rjmp	.+58     	; 0x12a6 <conversion+0x98>
		case 0x10:
		node=16;
    126c:	90 e1       	ldi	r25, 0x10	; 16
		break;
    126e:	1b c0       	rjmp	.+54     	; 0x12a6 <conversion+0x98>
		case 0x17:
		node=23;
    1270:	97 e1       	ldi	r25, 0x17	; 23
		break;
    1272:	19 c0       	rjmp	.+50     	; 0x12a6 <conversion+0x98>
		case 0x1E:
		node=30;
    1274:	9e e1       	ldi	r25, 0x1E	; 30
		break;
    1276:	17 c0       	rjmp	.+46     	; 0x12a6 <conversion+0x98>
		case 0x25:
		node=37;
    1278:	95 e2       	ldi	r25, 0x25	; 37
		break;
    127a:	15 c0       	rjmp	.+42     	; 0x12a6 <conversion+0x98>
		case 0x2C:
		node=44;
    127c:	9c e2       	ldi	r25, 0x2C	; 44
		break;
    127e:	13 c0       	rjmp	.+38     	; 0x12a6 <conversion+0x98>
		
		case 0x04:
		node=4;
    1280:	94 e0       	ldi	r25, 0x04	; 4
		break;
    1282:	11 c0       	rjmp	.+34     	; 0x12a6 <conversion+0x98>
		case 0x0B:
		node=11;
    1284:	9b e0       	ldi	r25, 0x0B	; 11
		break;
    1286:	0f c0       	rjmp	.+30     	; 0x12a6 <conversion+0x98>
		case 0x12:
		node=18;
    1288:	92 e1       	ldi	r25, 0x12	; 18
		break;
    128a:	0d c0       	rjmp	.+26     	; 0x12a6 <conversion+0x98>
		case 0x19:
		node=25;
    128c:	99 e1       	ldi	r25, 0x19	; 25
		break;
    128e:	0b c0       	rjmp	.+22     	; 0x12a6 <conversion+0x98>
		case 0x20:
		node=32;
    1290:	90 e2       	ldi	r25, 0x20	; 32
		break;
    1292:	09 c0       	rjmp	.+18     	; 0x12a6 <conversion+0x98>
		case 0x27:
		node=39;
    1294:	97 e2       	ldi	r25, 0x27	; 39
		break;
    1296:	07 c0       	rjmp	.+14     	; 0x12a6 <conversion+0x98>
		case 0x2E:
		node=46;
    1298:	9e e2       	ldi	r25, 0x2E	; 46
		break;
    129a:	05 c0       	rjmp	.+10     	; 0x12a6 <conversion+0x98>
		
		case 0x64:
		node=100;
    129c:	94 e6       	ldi	r25, 0x64	; 100
		break;
    129e:	03 c0       	rjmp	.+6      	; 0x12a6 <conversion+0x98>
		case 0x65:
		node=101;
    12a0:	95 e6       	ldi	r25, 0x65	; 101
		break;
    12a2:	01 c0       	rjmp	.+2      	; 0x12a6 <conversion+0x98>
{	unsigned char node;	
	
	switch(hex)
	{
		case 0x02:
		node=2;
    12a4:	92 e0       	ldi	r25, 0x02	; 2
		break;
			
	}
	
	return node;
}
    12a6:	89 2f       	mov	r24, r25
    12a8:	08 95       	ret

000012aa <buzzer_on_zigbee>:
}*/

void buzzer_on_zigbee (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
    12aa:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore | 0x08;
    12ac:	88 60       	ori	r24, 0x08	; 8
 PORTC = port_restore;
    12ae:	85 bb       	out	0x15, r24	; 21
}
    12b0:	08 95       	ret

000012b2 <buzzer_off_zigbee>:

void buzzer_off_zigbee (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
    12b2:	83 b3       	in	r24, 0x13	; 19
 port_restore = port_restore & 0xF7;
    12b4:	87 7f       	andi	r24, 0xF7	; 247
 PORTC = port_restore;
    12b6:	85 bb       	out	0x15, r24	; 21
}
    12b8:	08 95       	ret

000012ba <init_devices_zigbee>:

void init_devices_zigbee (void)
{
 cli();         //Clears the global interrupts
    12ba:	f8 94       	cli
 port_init_zigbee();
    12bc:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <port_init_zigbee>
 uart0_init_zigbee();
    12c0:	0e 94 fd 08 	call	0x11fa	; 0x11fa <uart0_init_zigbee>
 sei();         //Enables the global interrupts
    12c4:	78 94       	sei
}
    12c6:	08 95       	ret

000012c8 <__vector_11>:

SIGNAL(SIG_UART_RECV) 
{	//init_devices_buzzer();
    12c8:	1f 92       	push	r1
    12ca:	0f 92       	push	r0
    12cc:	0f b6       	in	r0, 0x3f	; 63
    12ce:	0f 92       	push	r0
    12d0:	11 24       	eor	r1, r1
    12d2:	0f 93       	push	r16
    12d4:	1f 93       	push	r17
    12d6:	2f 93       	push	r18
    12d8:	3f 93       	push	r19
    12da:	4f 93       	push	r20
    12dc:	5f 93       	push	r21
    12de:	6f 93       	push	r22
    12e0:	7f 93       	push	r23
    12e2:	8f 93       	push	r24
    12e4:	9f 93       	push	r25
    12e6:	af 93       	push	r26
    12e8:	bf 93       	push	r27
    12ea:	cf 93       	push	r28
    12ec:	ef 93       	push	r30
    12ee:	ff 93       	push	r31
	
	          
 unsigned char k;
 k=UDR;         // Echo the received data plus 1
    12f0:	cc b1       	in	r28, 0x0c	; 12
if(k==0x33)//51
    12f2:	c3 33       	cpi	r28, 0x33	; 51
    12f4:	d1 f4       	brne	.+52     	; 0x132a <__vector_11+0x62>
{
	mark=1;
    12f6:	81 e0       	ldi	r24, 0x01	; 1
    12f8:	80 93 60 00 	sts	0x0060, r24
	buzzer_on();
    12fc:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    1300:	8f ef       	ldi	r24, 0xFF	; 255
    1302:	9f eb       	ldi	r25, 0xBF	; 191
    1304:	a6 e0       	ldi	r26, 0x06	; 6
    1306:	81 50       	subi	r24, 0x01	; 1
    1308:	90 40       	sbci	r25, 0x00	; 0
    130a:	a0 40       	sbci	r26, 0x00	; 0
    130c:	e1 f7       	brne	.-8      	; 0x1306 <__vector_11+0x3e>
    130e:	00 c0       	rjmp	.+0      	; 0x1310 <__vector_11+0x48>
    1310:	00 00       	nop
	_delay_ms(300);
	buzzer_off();
    1312:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
    1316:	8f ef       	ldi	r24, 0xFF	; 255
    1318:	9f eb       	ldi	r25, 0xBF	; 191
    131a:	a6 e0       	ldi	r26, 0x06	; 6
    131c:	81 50       	subi	r24, 0x01	; 1
    131e:	90 40       	sbci	r25, 0x00	; 0
    1320:	a0 40       	sbci	r26, 0x00	; 0
    1322:	e1 f7       	brne	.-8      	; 0x131c <__vector_11+0x54>
    1324:	00 c0       	rjmp	.+0      	; 0x1326 <__vector_11+0x5e>
    1326:	00 00       	nop
    1328:	1f c0       	rjmp	.+62     	; 0x1368 <__vector_11+0xa0>
	_delay_ms(300);
}
if (k==0x34)//52
    132a:	c4 33       	cpi	r28, 0x34	; 52
    132c:	e9 f4       	brne	.+58     	; 0x1368 <__vector_11+0xa0>
{
	mark=0;
    132e:	10 92 60 00 	sts	0x0060, r1
	next++;
    1332:	80 91 71 00 	lds	r24, 0x0071
    1336:	8f 5f       	subi	r24, 0xFF	; 255
    1338:	80 93 71 00 	sts	0x0071, r24
	buzzer_on();
    133c:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    1340:	8f ef       	ldi	r24, 0xFF	; 255
    1342:	9f eb       	ldi	r25, 0xBF	; 191
    1344:	a6 e0       	ldi	r26, 0x06	; 6
    1346:	81 50       	subi	r24, 0x01	; 1
    1348:	90 40       	sbci	r25, 0x00	; 0
    134a:	a0 40       	sbci	r26, 0x00	; 0
    134c:	e1 f7       	brne	.-8      	; 0x1346 <__vector_11+0x7e>
    134e:	00 c0       	rjmp	.+0      	; 0x1350 <__vector_11+0x88>
    1350:	00 00       	nop
	_delay_ms(300);
	buzzer_off();
    1352:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
    1356:	8f ef       	ldi	r24, 0xFF	; 255
    1358:	9f eb       	ldi	r25, 0xBF	; 191
    135a:	a6 e0       	ldi	r26, 0x06	; 6
    135c:	81 50       	subi	r24, 0x01	; 1
    135e:	90 40       	sbci	r25, 0x00	; 0
    1360:	a0 40       	sbci	r26, 0x00	; 0
    1362:	e1 f7       	brne	.-8      	; 0x135c <__vector_11+0x94>
    1364:	00 c0       	rjmp	.+0      	; 0x1366 <__vector_11+0x9e>
    1366:	00 00       	nop
	_delay_ms(300);
}

	if (mark==1)
    1368:	80 91 60 00 	lds	r24, 0x0060
    136c:	81 30       	cpi	r24, 0x01	; 1
    136e:	09 f0       	breq	.+2      	; 0x1372 <__vector_11+0xaa>
    1370:	53 c0       	rjmp	.+166    	; 0x1418 <__vector_11+0x150>
	{
		if(k>0x00 && k<0x31)//0-49
    1372:	8c 2f       	mov	r24, r28
    1374:	81 50       	subi	r24, 0x01	; 1
    1376:	80 33       	cpi	r24, 0x30	; 48
    1378:	30 f5       	brcc	.+76     	; 0x13c6 <__vector_11+0xfe>
		{
			red_nodes[r]=conversion(k);
    137a:	00 91 73 00 	lds	r16, 0x0073
    137e:	10 e0       	ldi	r17, 0x00	; 0
    1380:	8c 2f       	mov	r24, r28
    1382:	0e 94 07 09 	call	0x120e	; 0x120e <conversion>
    1386:	f8 01       	movw	r30, r16
    1388:	ed 50       	subi	r30, 0x0D	; 13
    138a:	ff 4f       	sbci	r31, 0xFF	; 255
    138c:	80 83       	st	Z, r24
			
			r++;
    138e:	80 91 73 00 	lds	r24, 0x0073
    1392:	8f 5f       	subi	r24, 0xFF	; 255
    1394:	80 93 73 00 	sts	0x0073, r24
			buzzer_on();
    1398:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    139c:	8f ef       	ldi	r24, 0xFF	; 255
    139e:	9f eb       	ldi	r25, 0xBF	; 191
    13a0:	a6 e0       	ldi	r26, 0x06	; 6
    13a2:	81 50       	subi	r24, 0x01	; 1
    13a4:	90 40       	sbci	r25, 0x00	; 0
    13a6:	a0 40       	sbci	r26, 0x00	; 0
    13a8:	e1 f7       	brne	.-8      	; 0x13a2 <__vector_11+0xda>
    13aa:	00 c0       	rjmp	.+0      	; 0x13ac <__vector_11+0xe4>
    13ac:	00 00       	nop
			_delay_ms(300);
			buzzer_off();
    13ae:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
    13b2:	8f ef       	ldi	r24, 0xFF	; 255
    13b4:	9f eb       	ldi	r25, 0xBF	; 191
    13b6:	a6 e0       	ldi	r26, 0x06	; 6
    13b8:	81 50       	subi	r24, 0x01	; 1
    13ba:	90 40       	sbci	r25, 0x00	; 0
    13bc:	a0 40       	sbci	r26, 0x00	; 0
    13be:	e1 f7       	brne	.-8      	; 0x13b8 <__vector_11+0xf0>
    13c0:	00 c0       	rjmp	.+0      	; 0x13c2 <__vector_11+0xfa>
    13c2:	00 00       	nop
    13c4:	29 c0       	rjmp	.+82     	; 0x1418 <__vector_11+0x150>
			_delay_ms(300);
			
		}
		else if(k==0x64 || k==0x65)//100-101
    13c6:	8c 2f       	mov	r24, r28
    13c8:	84 56       	subi	r24, 0x64	; 100
    13ca:	82 30       	cpi	r24, 0x02	; 2
    13cc:	28 f5       	brcc	.+74     	; 0x1418 <__vector_11+0x150>
		{
			red_side[rs]=conversion(k);
    13ce:	00 91 72 00 	lds	r16, 0x0072
    13d2:	10 e0       	ldi	r17, 0x00	; 0
    13d4:	8c 2f       	mov	r24, r28
    13d6:	0e 94 07 09 	call	0x120e	; 0x120e <conversion>
    13da:	f8 01       	movw	r30, r16
    13dc:	e1 50       	subi	r30, 0x01	; 1
    13de:	ff 4f       	sbci	r31, 0xFF	; 255
    13e0:	80 83       	st	Z, r24
			rs++;
    13e2:	80 91 72 00 	lds	r24, 0x0072
    13e6:	8f 5f       	subi	r24, 0xFF	; 255
    13e8:	80 93 72 00 	sts	0x0072, r24
			buzzer_on();
    13ec:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    13f0:	8f ef       	ldi	r24, 0xFF	; 255
    13f2:	9f eb       	ldi	r25, 0xBF	; 191
    13f4:	a6 e0       	ldi	r26, 0x06	; 6
    13f6:	81 50       	subi	r24, 0x01	; 1
    13f8:	90 40       	sbci	r25, 0x00	; 0
    13fa:	a0 40       	sbci	r26, 0x00	; 0
    13fc:	e1 f7       	brne	.-8      	; 0x13f6 <__vector_11+0x12e>
    13fe:	00 c0       	rjmp	.+0      	; 0x1400 <__vector_11+0x138>
    1400:	00 00       	nop
			_delay_ms(300);
			buzzer_off();
    1402:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
    1406:	8f ef       	ldi	r24, 0xFF	; 255
    1408:	9f eb       	ldi	r25, 0xBF	; 191
    140a:	a6 e0       	ldi	r26, 0x06	; 6
    140c:	81 50       	subi	r24, 0x01	; 1
    140e:	90 40       	sbci	r25, 0x00	; 0
    1410:	a0 40       	sbci	r26, 0x00	; 0
    1412:	e1 f7       	brne	.-8      	; 0x140c <__vector_11+0x144>
    1414:	00 c0       	rjmp	.+0      	; 0x1416 <__vector_11+0x14e>
    1416:	00 00       	nop
			_delay_ms(300);
		}
	}		
 
}
    1418:	ff 91       	pop	r31
    141a:	ef 91       	pop	r30
    141c:	cf 91       	pop	r28
    141e:	bf 91       	pop	r27
    1420:	af 91       	pop	r26
    1422:	9f 91       	pop	r25
    1424:	8f 91       	pop	r24
    1426:	7f 91       	pop	r23
    1428:	6f 91       	pop	r22
    142a:	5f 91       	pop	r21
    142c:	4f 91       	pop	r20
    142e:	3f 91       	pop	r19
    1430:	2f 91       	pop	r18
    1432:	1f 91       	pop	r17
    1434:	0f 91       	pop	r16
    1436:	0f 90       	pop	r0
    1438:	0f be       	out	0x3f, r0	; 63
    143a:	0f 90       	pop	r0
    143c:	1f 90       	pop	r1
    143e:	18 95       	reti

00001440 <USARTWriteChar>:
		//Do nothing
	*/

	//Now write the data to USART buffer
  
	UDR=data;
    1440:	8c b9       	out	0x0c, r24	; 12
		
	
}
    1442:	08 95       	ret

00001444 <direction>:
	PORTC=PORTC& 0x8F;
	//buzzer_beep();
}

void direction(void)
{	init_devices_buzzer();
    1444:	0f 93       	push	r16
    1446:	1f 93       	push	r17
    1448:	cf 93       	push	r28
    144a:	df 93       	push	r29
    144c:	0e 94 df 00 	call	0x1be	; 0x1be <init_devices_buzzer>
	int w=0;
	if(t==max)
    1450:	90 91 76 00 	lds	r25, 0x0076
    1454:	80 91 80 00 	lds	r24, 0x0080
    1458:	98 17       	cp	r25, r24
    145a:	09 f0       	breq	.+2      	; 0x145e <direction+0x1a>
    145c:	67 c1       	rjmp	.+718    	; 0x172c <direction+0x2e8>
	{	if(stage==1)
    145e:	80 91 65 00 	lds	r24, 0x0065
    1462:	81 30       	cpi	r24, 0x01	; 1
    1464:	09 f0       	breq	.+2      	; 0x1468 <direction+0x24>
    1466:	4d c0       	rjmp	.+154    	; 0x1502 <direction+0xbe>
		{	init_devices_pos();
    1468:	0e 94 1c 04 	call	0x838	; 0x838 <init_devices_pos>
			if(dir==1)
    146c:	80 91 66 00 	lds	r24, 0x0066
    1470:	81 30       	cpi	r24, 0x01	; 1
    1472:	81 f4       	brne	.+32     	; 0x1494 <direction+0x50>
			
			{	
				//buzzer_beep();
				right_degrees(190);
    1474:	8e eb       	ldi	r24, 0xBE	; 190
    1476:	90 e0       	ldi	r25, 0x00	; 0
    1478:	0e 94 dd 03 	call	0x7ba	; 0x7ba <right_degrees>
				stop_pos();
    147c:	0e 94 41 03 	call	0x682	; 0x682 <stop_pos>
    1480:	8f ef       	ldi	r24, 0xFF	; 255
    1482:	9f e3       	ldi	r25, 0x3F	; 63
    1484:	ab e0       	ldi	r26, 0x0B	; 11
    1486:	81 50       	subi	r24, 0x01	; 1
    1488:	90 40       	sbci	r25, 0x00	; 0
    148a:	a0 40       	sbci	r26, 0x00	; 0
    148c:	e1 f7       	brne	.-8      	; 0x1486 <direction+0x42>
    148e:	00 c0       	rjmp	.+0      	; 0x1490 <direction+0x4c>
    1490:	00 00       	nop
    1492:	23 c0       	rjmp	.+70     	; 0x14da <direction+0x96>
				_delay_ms(500);
			}
			else if(dir==2)
    1494:	82 30       	cpi	r24, 0x02	; 2
    1496:	81 f4       	brne	.+32     	; 0x14b8 <direction+0x74>
			{
				right_degrees(100);
    1498:	84 e6       	ldi	r24, 0x64	; 100
    149a:	90 e0       	ldi	r25, 0x00	; 0
    149c:	0e 94 dd 03 	call	0x7ba	; 0x7ba <right_degrees>
				stop_pos();
    14a0:	0e 94 41 03 	call	0x682	; 0x682 <stop_pos>
    14a4:	8f ef       	ldi	r24, 0xFF	; 255
    14a6:	9f e3       	ldi	r25, 0x3F	; 63
    14a8:	ab e0       	ldi	r26, 0x0B	; 11
    14aa:	81 50       	subi	r24, 0x01	; 1
    14ac:	90 40       	sbci	r25, 0x00	; 0
    14ae:	a0 40       	sbci	r26, 0x00	; 0
    14b0:	e1 f7       	brne	.-8      	; 0x14aa <direction+0x66>
    14b2:	00 c0       	rjmp	.+0      	; 0x14b4 <direction+0x70>
    14b4:	00 00       	nop
    14b6:	11 c0       	rjmp	.+34     	; 0x14da <direction+0x96>
				_delay_ms(500);
			}
			else if(dir==4)
    14b8:	84 30       	cpi	r24, 0x04	; 4
    14ba:	79 f4       	brne	.+30     	; 0x14da <direction+0x96>
			{
				left_degrees(100);
    14bc:	84 e6       	ldi	r24, 0x64	; 100
    14be:	90 e0       	ldi	r25, 0x00	; 0
    14c0:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <left_degrees>
				stop_pos();
    14c4:	0e 94 41 03 	call	0x682	; 0x682 <stop_pos>
    14c8:	8f ef       	ldi	r24, 0xFF	; 255
    14ca:	9f e3       	ldi	r25, 0x3F	; 63
    14cc:	ab e0       	ldi	r26, 0x0B	; 11
    14ce:	81 50       	subi	r24, 0x01	; 1
    14d0:	90 40       	sbci	r25, 0x00	; 0
    14d2:	a0 40       	sbci	r26, 0x00	; 0
    14d4:	e1 f7       	brne	.-8      	; 0x14ce <direction+0x8a>
    14d6:	00 c0       	rjmp	.+0      	; 0x14d8 <direction+0x94>
    14d8:	00 00       	nop
				_delay_ms(500);
			}
			
			dir=3;
    14da:	83 e0       	ldi	r24, 0x03	; 3
    14dc:	80 93 66 00 	sts	0x0066, r24
    14e0:	8f ef       	ldi	r24, 0xFF	; 255
    14e2:	9f e7       	ldi	r25, 0x7F	; 127
    14e4:	a6 e1       	ldi	r26, 0x16	; 22
    14e6:	81 50       	subi	r24, 0x01	; 1
    14e8:	90 40       	sbci	r25, 0x00	; 0
    14ea:	a0 40       	sbci	r26, 0x00	; 0
    14ec:	e1 f7       	brne	.-8      	; 0x14e6 <direction+0xa2>
    14ee:	00 c0       	rjmp	.+0      	; 0x14f0 <direction+0xac>
    14f0:	00 00       	nop
		//	lcd_print(2,4,dir,3);
			_delay_ms(1000);
			g=1;
    14f2:	81 e0       	ldi	r24, 0x01	; 1
    14f4:	80 93 81 00 	sts	0x0081, r24
			buzzer_beep();
    14f8:	0e 94 c8 00 	call	0x190	; 0x190 <buzzer_beep>
			init_devices();
    14fc:	0e 94 6d 06 	call	0xcda	; 0xcda <init_devices>
    1500:	15 c1       	rjmp	.+554    	; 0x172c <direction+0x2e8>
		}
		else if(stage==2)
    1502:	82 30       	cpi	r24, 0x02	; 2
    1504:	09 f0       	breq	.+2      	; 0x1508 <direction+0xc4>
    1506:	07 c1       	rjmp	.+526    	; 0x1716 <direction+0x2d2>
    1508:	8f ef       	ldi	r24, 0xFF	; 255
    150a:	9f e3       	ldi	r25, 0x3F	; 63
    150c:	a2 e0       	ldi	r26, 0x02	; 2
    150e:	81 50       	subi	r24, 0x01	; 1
    1510:	90 40       	sbci	r25, 0x00	; 0
    1512:	a0 40       	sbci	r26, 0x00	; 0
    1514:	e1 f7       	brne	.-8      	; 0x150e <direction+0xca>
    1516:	00 c0       	rjmp	.+0      	; 0x1518 <direction+0xd4>
    1518:	00 00       	nop
			
			
			_delay_ms(100);
			while (1)
			{
				if(next>1)
    151a:	80 91 71 00 	lds	r24, 0x0071
    151e:	82 30       	cpi	r24, 0x02	; 2
    1520:	e0 f3       	brcs	.-8      	; 0x151a <direction+0xd6>
					break;
					
				}
			}
			
			green_nodes[0]=55;
    1522:	97 e3       	ldi	r25, 0x37	; 55
    1524:	90 93 82 00 	sts	0x0082, r25
			green_nodes[gn]=56;
    1528:	e0 91 62 00 	lds	r30, 0x0062
    152c:	f0 e0       	ldi	r31, 0x00	; 0
    152e:	ee 57       	subi	r30, 0x7E	; 126
    1530:	ff 4f       	sbci	r31, 0xFF	; 255
    1532:	88 e3       	ldi	r24, 0x38	; 56
    1534:	80 83       	st	Z, r24
			green_side[0]=55;
    1536:	90 93 a0 00 	sts	0x00A0, r25
			green_side[gs]=56;
    153a:	e0 91 61 00 	lds	r30, 0x0061
    153e:	f0 e0       	ldi	r31, 0x00	; 0
    1540:	e0 56       	subi	r30, 0x60	; 96
    1542:	ff 4f       	sbci	r31, 0xFF	; 255
    1544:	80 83       	st	Z, r24
			for(int i=0;i<=10;i++)
			{	if(green_nodes[i]==0)
    1546:	80 91 82 00 	lds	r24, 0x0082
    154a:	88 23       	and	r24, r24
    154c:	09 f0       	breq	.+2      	; 0x1550 <direction+0x10c>
    154e:	a5 c1       	rjmp	.+842    	; 0x189a <direction+0x456>
    1550:	19 c0       	rjmp	.+50     	; 0x1584 <direction+0x140>
    1552:	f8 01       	movw	r30, r16
    1554:	ec 0f       	add	r30, r28
    1556:	fd 1f       	adc	r31, r29
    1558:	80 81       	ld	r24, Z
    155a:	88 23       	and	r24, r24
    155c:	99 f0       	breq	.+38     	; 0x1584 <direction+0x140>
				{
					
					break;
					
				}
				USARTWriteChar(green_nodes[i]);
    155e:	f8 01       	movw	r30, r16
    1560:	ec 0f       	add	r30, r28
    1562:	fd 1f       	adc	r31, r29
    1564:	80 81       	ld	r24, Z
    1566:	0e 94 20 0a 	call	0x1440	; 0x1440 <USARTWriteChar>
    156a:	8f ef       	ldi	r24, 0xFF	; 255
    156c:	9f e7       	ldi	r25, 0x7F	; 127
    156e:	a6 e1       	ldi	r26, 0x16	; 22
    1570:	81 50       	subi	r24, 0x01	; 1
    1572:	90 40       	sbci	r25, 0x00	; 0
    1574:	a0 40       	sbci	r26, 0x00	; 0
    1576:	e1 f7       	brne	.-8      	; 0x1570 <direction+0x12c>
    1578:	00 c0       	rjmp	.+0      	; 0x157a <direction+0x136>
    157a:	00 00       	nop
			
			green_nodes[0]=55;
			green_nodes[gn]=56;
			green_side[0]=55;
			green_side[gs]=56;
			for(int i=0;i<=10;i++)
    157c:	21 96       	adiw	r28, 0x01	; 1
    157e:	cb 30       	cpi	r28, 0x0B	; 11
    1580:	d1 05       	cpc	r29, r1
    1582:	39 f7       	brne	.-50     	; 0x1552 <direction+0x10e>
				
				_delay_ms(1000);
				//buzzer_beep();
				
			}
			buzzer_on();
    1584:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    1588:	8f ef       	ldi	r24, 0xFF	; 255
    158a:	9f e7       	ldi	r25, 0x7F	; 127
    158c:	a6 e1       	ldi	r26, 0x16	; 22
    158e:	81 50       	subi	r24, 0x01	; 1
    1590:	90 40       	sbci	r25, 0x00	; 0
    1592:	a0 40       	sbci	r26, 0x00	; 0
    1594:	e1 f7       	brne	.-8      	; 0x158e <direction+0x14a>
    1596:	00 c0       	rjmp	.+0      	; 0x1598 <direction+0x154>
    1598:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    159a:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
			for(int i=0;i<10;i++)
			{	if(green_side[i]==0)
    159e:	80 91 a0 00 	lds	r24, 0x00A0
    15a2:	88 23       	and	r24, r24
    15a4:	09 f0       	breq	.+2      	; 0x15a8 <direction+0x164>
    15a6:	67 c1       	rjmp	.+718    	; 0x1876 <direction+0x432>
    15a8:	19 c0       	rjmp	.+50     	; 0x15dc <direction+0x198>
    15aa:	f8 01       	movw	r30, r16
    15ac:	ec 0f       	add	r30, r28
    15ae:	fd 1f       	adc	r31, r29
    15b0:	80 81       	ld	r24, Z
    15b2:	88 23       	and	r24, r24
    15b4:	99 f0       	breq	.+38     	; 0x15dc <direction+0x198>
				{
					break;
				}
				USARTWriteChar(green_side[i]);
    15b6:	f8 01       	movw	r30, r16
    15b8:	ec 0f       	add	r30, r28
    15ba:	fd 1f       	adc	r31, r29
    15bc:	80 81       	ld	r24, Z
    15be:	0e 94 20 0a 	call	0x1440	; 0x1440 <USARTWriteChar>
    15c2:	8f ef       	ldi	r24, 0xFF	; 255
    15c4:	9f e7       	ldi	r25, 0x7F	; 127
    15c6:	a6 e1       	ldi	r26, 0x16	; 22
    15c8:	81 50       	subi	r24, 0x01	; 1
    15ca:	90 40       	sbci	r25, 0x00	; 0
    15cc:	a0 40       	sbci	r26, 0x00	; 0
    15ce:	e1 f7       	brne	.-8      	; 0x15c8 <direction+0x184>
    15d0:	00 c0       	rjmp	.+0      	; 0x15d2 <direction+0x18e>
    15d2:	00 00       	nop
				
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    15d4:	21 96       	adiw	r28, 0x01	; 1
    15d6:	ca 30       	cpi	r28, 0x0A	; 10
    15d8:	d1 05       	cpc	r29, r1
    15da:	39 f7       	brne	.-50     	; 0x15aa <direction+0x166>
				}
				USARTWriteChar(green_side[i]);
				_delay_ms(1000);
				//buzzer_beep();
			}
			buzzer_on();
    15dc:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    15e0:	8f ef       	ldi	r24, 0xFF	; 255
    15e2:	9f e7       	ldi	r25, 0x7F	; 127
    15e4:	a6 e1       	ldi	r26, 0x16	; 22
    15e6:	81 50       	subi	r24, 0x01	; 1
    15e8:	90 40       	sbci	r25, 0x00	; 0
    15ea:	a0 40       	sbci	r26, 0x00	; 0
    15ec:	e1 f7       	brne	.-8      	; 0x15e6 <direction+0x1a2>
    15ee:	00 c0       	rjmp	.+0      	; 0x15f0 <direction+0x1ac>
    15f0:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    15f2:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
			blue_nodes[0]=53;
    15f6:	95 e3       	ldi	r25, 0x35	; 53
    15f8:	90 93 8e 00 	sts	0x008E, r25
			blue_nodes[b]=54;
    15fc:	e0 91 64 00 	lds	r30, 0x0064
    1600:	f0 e0       	ldi	r31, 0x00	; 0
    1602:	e2 57       	subi	r30, 0x72	; 114
    1604:	ff 4f       	sbci	r31, 0xFF	; 255
    1606:	86 e3       	ldi	r24, 0x36	; 54
    1608:	80 83       	st	Z, r24
			blue_side[0]=53;
    160a:	90 93 ac 00 	sts	0x00AC, r25
			blue_side[bs]=54;
    160e:	e0 91 63 00 	lds	r30, 0x0063
    1612:	f0 e0       	ldi	r31, 0x00	; 0
    1614:	e4 55       	subi	r30, 0x54	; 84
    1616:	ff 4f       	sbci	r31, 0xFF	; 255
    1618:	80 83       	st	Z, r24
			for(int i=0;i<=10;i++)
			{	if(blue_nodes[i]==0)
    161a:	80 91 8e 00 	lds	r24, 0x008E
    161e:	88 23       	and	r24, r24
    1620:	09 f0       	breq	.+2      	; 0x1624 <direction+0x1e0>
    1622:	16 c1       	rjmp	.+556    	; 0x1850 <direction+0x40c>
    1624:	1a c0       	rjmp	.+52     	; 0x165a <direction+0x216>
    1626:	f8 01       	movw	r30, r16
    1628:	ec 0f       	add	r30, r28
    162a:	fd 1f       	adc	r31, r29
    162c:	80 81       	ld	r24, Z
    162e:	88 23       	and	r24, r24
    1630:	a1 f0       	breq	.+40     	; 0x165a <direction+0x216>
				{
					
					break;
					
				}
				USARTWriteChar(blue_nodes[i]+7);
    1632:	f8 01       	movw	r30, r16
    1634:	ec 0f       	add	r30, r28
    1636:	fd 1f       	adc	r31, r29
    1638:	80 81       	ld	r24, Z
    163a:	89 5f       	subi	r24, 0xF9	; 249
    163c:	0e 94 20 0a 	call	0x1440	; 0x1440 <USARTWriteChar>
    1640:	8f ef       	ldi	r24, 0xFF	; 255
    1642:	9f e7       	ldi	r25, 0x7F	; 127
    1644:	a6 e1       	ldi	r26, 0x16	; 22
    1646:	81 50       	subi	r24, 0x01	; 1
    1648:	90 40       	sbci	r25, 0x00	; 0
    164a:	a0 40       	sbci	r26, 0x00	; 0
    164c:	e1 f7       	brne	.-8      	; 0x1646 <direction+0x202>
    164e:	00 c0       	rjmp	.+0      	; 0x1650 <direction+0x20c>
    1650:	00 00       	nop
			buzzer_off();
			blue_nodes[0]=53;
			blue_nodes[b]=54;
			blue_side[0]=53;
			blue_side[bs]=54;
			for(int i=0;i<=10;i++)
    1652:	21 96       	adiw	r28, 0x01	; 1
    1654:	cb 30       	cpi	r28, 0x0B	; 11
    1656:	d1 05       	cpc	r29, r1
    1658:	31 f7       	brne	.-52     	; 0x1626 <direction+0x1e2>
				
				_delay_ms(1000);
				//buzzer_beep();
				
			}
			buzzer_on();
    165a:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    165e:	8f ef       	ldi	r24, 0xFF	; 255
    1660:	9f e7       	ldi	r25, 0x7F	; 127
    1662:	a6 e1       	ldi	r26, 0x16	; 22
    1664:	81 50       	subi	r24, 0x01	; 1
    1666:	90 40       	sbci	r25, 0x00	; 0
    1668:	a0 40       	sbci	r26, 0x00	; 0
    166a:	e1 f7       	brne	.-8      	; 0x1664 <direction+0x220>
    166c:	00 c0       	rjmp	.+0      	; 0x166e <direction+0x22a>
    166e:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    1670:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
			for(int i=0;i<10;i++)
			{	if(blue_side[i]==0)
    1674:	80 91 ac 00 	lds	r24, 0x00AC
    1678:	88 23       	and	r24, r24
    167a:	a1 f1       	breq	.+104    	; 0x16e4 <direction+0x2a0>
				
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    167c:	c0 e0       	ldi	r28, 0x00	; 0
    167e:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(blue_side[i]==0)
				{
					break;
				}
				if(blue_side[i]==100)
    1680:	0c ea       	ldi	r16, 0xAC	; 172
    1682:	10 e0       	ldi	r17, 0x00	; 0
    1684:	06 c0       	rjmp	.+12     	; 0x1692 <direction+0x24e>
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
			{	if(blue_side[i]==0)
    1686:	f8 01       	movw	r30, r16
    1688:	ec 0f       	add	r30, r28
    168a:	fd 1f       	adc	r31, r29
    168c:	80 81       	ld	r24, Z
    168e:	88 23       	and	r24, r24
    1690:	49 f1       	breq	.+82     	; 0x16e4 <direction+0x2a0>
				{
					break;
				}
				if(blue_side[i]==100)
    1692:	f8 01       	movw	r30, r16
    1694:	ec 0f       	add	r30, r28
    1696:	fd 1f       	adc	r31, r29
    1698:	80 81       	ld	r24, Z
    169a:	84 36       	cpi	r24, 0x64	; 100
    169c:	69 f4       	brne	.+26     	; 0x16b8 <direction+0x274>
				{
					USARTWriteChar(101);
    169e:	85 e6       	ldi	r24, 0x65	; 101
    16a0:	0e 94 20 0a 	call	0x1440	; 0x1440 <USARTWriteChar>
    16a4:	8f ef       	ldi	r24, 0xFF	; 255
    16a6:	9f e7       	ldi	r25, 0x7F	; 127
    16a8:	a6 e1       	ldi	r26, 0x16	; 22
    16aa:	81 50       	subi	r24, 0x01	; 1
    16ac:	90 40       	sbci	r25, 0x00	; 0
    16ae:	a0 40       	sbci	r26, 0x00	; 0
    16b0:	e1 f7       	brne	.-8      	; 0x16aa <direction+0x266>
    16b2:	00 c0       	rjmp	.+0      	; 0x16b4 <direction+0x270>
    16b4:	00 00       	nop
    16b6:	12 c0       	rjmp	.+36     	; 0x16dc <direction+0x298>
					_delay_ms(1000);
				}
				else if(blue_side[i]==101)
    16b8:	f8 01       	movw	r30, r16
    16ba:	ec 0f       	add	r30, r28
    16bc:	fd 1f       	adc	r31, r29
    16be:	80 81       	ld	r24, Z
    16c0:	85 36       	cpi	r24, 0x65	; 101
    16c2:	61 f4       	brne	.+24     	; 0x16dc <direction+0x298>
				{
					USARTWriteChar(100);
    16c4:	84 e6       	ldi	r24, 0x64	; 100
    16c6:	0e 94 20 0a 	call	0x1440	; 0x1440 <USARTWriteChar>
    16ca:	8f ef       	ldi	r24, 0xFF	; 255
    16cc:	9f e7       	ldi	r25, 0x7F	; 127
    16ce:	a6 e1       	ldi	r26, 0x16	; 22
    16d0:	81 50       	subi	r24, 0x01	; 1
    16d2:	90 40       	sbci	r25, 0x00	; 0
    16d4:	a0 40       	sbci	r26, 0x00	; 0
    16d6:	e1 f7       	brne	.-8      	; 0x16d0 <direction+0x28c>
    16d8:	00 c0       	rjmp	.+0      	; 0x16da <direction+0x296>
    16da:	00 00       	nop
				
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    16dc:	21 96       	adiw	r28, 0x01	; 1
    16de:	ca 30       	cpi	r28, 0x0A	; 10
    16e0:	d1 05       	cpc	r29, r1
    16e2:	89 f6       	brne	.-94     	; 0x1686 <direction+0x242>
					_delay_ms(1000);
				}
				
				//buzzer_beep();
			}
			buzzer_on();
    16e4:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    16e8:	8f ef       	ldi	r24, 0xFF	; 255
    16ea:	9f e7       	ldi	r25, 0x7F	; 127
    16ec:	a6 e1       	ldi	r26, 0x16	; 22
    16ee:	81 50       	subi	r24, 0x01	; 1
    16f0:	90 40       	sbci	r25, 0x00	; 0
    16f2:	a0 40       	sbci	r26, 0x00	; 0
    16f4:	e1 f7       	brne	.-8      	; 0x16ee <direction+0x2aa>
    16f6:	00 c0       	rjmp	.+0      	; 0x16f8 <direction+0x2b4>
    16f8:	00 00       	nop
			_delay_ms(1000);
			buzzer_off();
    16fa:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
			while (1)
			{
				if(next>3)
    16fe:	80 91 71 00 	lds	r24, 0x0071
    1702:	84 30       	cpi	r24, 0x04	; 4
    1704:	e0 f3       	brcs	.-8      	; 0x16fe <direction+0x2ba>
				{	buzzer_beep();
    1706:	0e 94 c8 00 	call	0x190	; 0x190 <buzzer_beep>
					buzzer_beep();
    170a:	0e 94 c8 00 	call	0x190	; 0x190 <buzzer_beep>
					break;
				}
				
			}
			
			g=1;
    170e:	81 e0       	ldi	r24, 0x01	; 1
    1710:	80 93 81 00 	sts	0x0081, r24
    1714:	0b c0       	rjmp	.+22     	; 0x172c <direction+0x2e8>
			_delay_ms(1000);
			buzzer_off();*/
			
			
		}
		else if(stage==3)
    1716:	83 30       	cpi	r24, 0x03	; 3
    1718:	21 f4       	brne	.+8      	; 0x1722 <direction+0x2de>
		{
			g=1;
    171a:	81 e0       	ldi	r24, 0x01	; 1
    171c:	80 93 81 00 	sts	0x0081, r24
    1720:	05 c0       	rjmp	.+10     	; 0x172c <direction+0x2e8>
			/*buzzer_beep();
			buzzer_beep();
			buzzer_beep();*/
		
		}		
		else if(stage==4)
    1722:	84 30       	cpi	r24, 0x04	; 4
    1724:	19 f4       	brne	.+6      	; 0x172c <direction+0x2e8>
		{
			g=1;
    1726:	81 e0       	ldi	r24, 0x01	; 1
    1728:	80 93 81 00 	sts	0x0081, r24
		}		
		
		
		
	}
	if(t<max)
    172c:	20 91 76 00 	lds	r18, 0x0076
    1730:	80 91 80 00 	lds	r24, 0x0080
    1734:	28 17       	cp	r18, r24
    1736:	08 f0       	brcs	.+2      	; 0x173a <direction+0x2f6>
    1738:	c2 c0       	rjmp	.+388    	; 0x18be <direction+0x47a>
	{
		w=(path1.path[t]-path1.path[t+1]);
    173a:	e8 ec       	ldi	r30, 0xC8	; 200
    173c:	f0 e0       	ldi	r31, 0x00	; 0
    173e:	e2 0f       	add	r30, r18
    1740:	f1 1d       	adc	r31, r1
    1742:	80 81       	ld	r24, Z
    1744:	90 e0       	ldi	r25, 0x00	; 0
    1746:	31 81       	ldd	r19, Z+1	; 0x01
    1748:	83 1b       	sub	r24, r19
    174a:	91 09       	sbc	r25, r1
		t++;
    174c:	2f 5f       	subi	r18, 0xFF	; 255
    174e:	20 93 76 00 	sts	0x0076, r18
			lcd_init();
			
		
		lcd_print(2,1,w,3);
		_delay_ms(4000);*/
		switch (w)
    1752:	af ef       	ldi	r26, 0xFF	; 255
    1754:	8f 3f       	cpi	r24, 0xFF	; 255
    1756:	9a 07       	cpc	r25, r26
    1758:	69 f1       	breq	.+90     	; 0x17b4 <direction+0x370>
    175a:	bf ef       	ldi	r27, 0xFF	; 255
    175c:	8f 3f       	cpi	r24, 0xFF	; 255
    175e:	9b 07       	cpc	r25, r27
    1760:	09 f0       	breq	.+2      	; 0x1764 <direction+0x320>
    1762:	34 f4       	brge	.+12     	; 0x1770 <direction+0x32c>
    1764:	2f ef       	ldi	r18, 0xFF	; 255
    1766:	89 3f       	cpi	r24, 0xF9	; 249
    1768:	92 07       	cpc	r25, r18
    176a:	09 f0       	breq	.+2      	; 0x176e <direction+0x32a>
    176c:	a8 c0       	rjmp	.+336    	; 0x18be <direction+0x47a>
    176e:	56 c0       	rjmp	.+172    	; 0x181c <direction+0x3d8>
    1770:	81 30       	cpi	r24, 0x01	; 1
    1772:	91 05       	cpc	r25, r1
    1774:	29 f0       	breq	.+10     	; 0x1780 <direction+0x33c>
    1776:	87 30       	cpi	r24, 0x07	; 7
    1778:	91 05       	cpc	r25, r1
    177a:	09 f0       	breq	.+2      	; 0x177e <direction+0x33a>
    177c:	a0 c0       	rjmp	.+320    	; 0x18be <direction+0x47a>
    177e:	34 c0       	rjmp	.+104    	; 0x17e8 <direction+0x3a4>
		{ 
			case 1:
			
				if(dir==1)
    1780:	80 91 66 00 	lds	r24, 0x0066
    1784:	81 30       	cpi	r24, 0x01	; 1
    1786:	29 f4       	brne	.+10     	; 0x1792 <direction+0x34e>
				success(3);
    1788:	83 e0       	ldi	r24, 0x03	; 3
    178a:	90 e0       	ldi	r25, 0x00	; 0
    178c:	0e 94 aa 05 	call	0xb54	; 0xb54 <success>
    1790:	0d c0       	rjmp	.+26     	; 0x17ac <direction+0x368>
				else if(dir==3)
    1792:	83 30       	cpi	r24, 0x03	; 3
    1794:	29 f4       	brne	.+10     	; 0x17a0 <direction+0x35c>
				success(2);
    1796:	82 e0       	ldi	r24, 0x02	; 2
    1798:	90 e0       	ldi	r25, 0x00	; 0
    179a:	0e 94 aa 05 	call	0xb54	; 0xb54 <success>
    179e:	06 c0       	rjmp	.+12     	; 0x17ac <direction+0x368>
				else if(dir==4)
    17a0:	84 30       	cpi	r24, 0x04	; 4
    17a2:	21 f4       	brne	.+8      	; 0x17ac <direction+0x368>
				success(1);
    17a4:	81 e0       	ldi	r24, 0x01	; 1
    17a6:	90 e0       	ldi	r25, 0x00	; 0
    17a8:	0e 94 aa 05 	call	0xb54	; 0xb54 <success>
				
				dir=4;
    17ac:	84 e0       	ldi	r24, 0x04	; 4
    17ae:	80 93 66 00 	sts	0x0066, r24
				break;
    17b2:	85 c0       	rjmp	.+266    	; 0x18be <direction+0x47a>
			
			case (-1):
			
				if(dir==1)
    17b4:	80 91 66 00 	lds	r24, 0x0066
    17b8:	81 30       	cpi	r24, 0x01	; 1
    17ba:	29 f4       	brne	.+10     	; 0x17c6 <direction+0x382>
				success(2);
    17bc:	82 e0       	ldi	r24, 0x02	; 2
    17be:	90 e0       	ldi	r25, 0x00	; 0
    17c0:	0e 94 aa 05 	call	0xb54	; 0xb54 <success>
    17c4:	0d c0       	rjmp	.+26     	; 0x17e0 <direction+0x39c>
				else if(dir==2)
    17c6:	82 30       	cpi	r24, 0x02	; 2
    17c8:	29 f4       	brne	.+10     	; 0x17d4 <direction+0x390>
				success(1);
    17ca:	81 e0       	ldi	r24, 0x01	; 1
    17cc:	90 e0       	ldi	r25, 0x00	; 0
    17ce:	0e 94 aa 05 	call	0xb54	; 0xb54 <success>
    17d2:	06 c0       	rjmp	.+12     	; 0x17e0 <direction+0x39c>
				else if(dir==3)
    17d4:	83 30       	cpi	r24, 0x03	; 3
    17d6:	21 f4       	brne	.+8      	; 0x17e0 <direction+0x39c>
				success(3);
    17d8:	83 e0       	ldi	r24, 0x03	; 3
    17da:	90 e0       	ldi	r25, 0x00	; 0
    17dc:	0e 94 aa 05 	call	0xb54	; 0xb54 <success>
				
				dir=2;
    17e0:	82 e0       	ldi	r24, 0x02	; 2
    17e2:	80 93 66 00 	sts	0x0066, r24
				break;
    17e6:	6b c0       	rjmp	.+214    	; 0x18be <direction+0x47a>
				
			
			case (7):
			
				if(dir==1)
    17e8:	80 91 66 00 	lds	r24, 0x0066
    17ec:	81 30       	cpi	r24, 0x01	; 1
    17ee:	29 f4       	brne	.+10     	; 0x17fa <direction+0x3b6>
				success(1);
    17f0:	81 e0       	ldi	r24, 0x01	; 1
    17f2:	90 e0       	ldi	r25, 0x00	; 0
    17f4:	0e 94 aa 05 	call	0xb54	; 0xb54 <success>
    17f8:	0d c0       	rjmp	.+26     	; 0x1814 <direction+0x3d0>
				else if(dir==2)
    17fa:	82 30       	cpi	r24, 0x02	; 2
    17fc:	29 f4       	brne	.+10     	; 0x1808 <direction+0x3c4>
				success(3);
    17fe:	83 e0       	ldi	r24, 0x03	; 3
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	0e 94 aa 05 	call	0xb54	; 0xb54 <success>
    1806:	06 c0       	rjmp	.+12     	; 0x1814 <direction+0x3d0>
				else if(dir==4)
    1808:	84 30       	cpi	r24, 0x04	; 4
    180a:	21 f4       	brne	.+8      	; 0x1814 <direction+0x3d0>
				success(2);
    180c:	82 e0       	ldi	r24, 0x02	; 2
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	0e 94 aa 05 	call	0xb54	; 0xb54 <success>
				
				dir=1;
    1814:	81 e0       	ldi	r24, 0x01	; 1
    1816:	80 93 66 00 	sts	0x0066, r24
				break;
    181a:	51 c0       	rjmp	.+162    	; 0x18be <direction+0x47a>
				
			
			case (-7):
			
				if(dir==2)
    181c:	80 91 66 00 	lds	r24, 0x0066
    1820:	82 30       	cpi	r24, 0x02	; 2
    1822:	29 f4       	brne	.+10     	; 0x182e <direction+0x3ea>
				success(2);
    1824:	82 e0       	ldi	r24, 0x02	; 2
    1826:	90 e0       	ldi	r25, 0x00	; 0
    1828:	0e 94 aa 05 	call	0xb54	; 0xb54 <success>
    182c:	0d c0       	rjmp	.+26     	; 0x1848 <direction+0x404>
				else if(dir==3)
    182e:	83 30       	cpi	r24, 0x03	; 3
    1830:	29 f4       	brne	.+10     	; 0x183c <direction+0x3f8>
				success(1);
    1832:	81 e0       	ldi	r24, 0x01	; 1
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	0e 94 aa 05 	call	0xb54	; 0xb54 <success>
    183a:	06 c0       	rjmp	.+12     	; 0x1848 <direction+0x404>
				else if(dir==4)
    183c:	84 30       	cpi	r24, 0x04	; 4
    183e:	21 f4       	brne	.+8      	; 0x1848 <direction+0x404>
				success(3);
    1840:	83 e0       	ldi	r24, 0x03	; 3
    1842:	90 e0       	ldi	r25, 0x00	; 0
    1844:	0e 94 aa 05 	call	0xb54	; 0xb54 <success>
				
				dir=3;
    1848:	83 e0       	ldi	r24, 0x03	; 3
    184a:	80 93 66 00 	sts	0x0066, r24
				break;
    184e:	37 c0       	rjmp	.+110    	; 0x18be <direction+0x47a>
				{
					
					break;
					
				}
				USARTWriteChar(blue_nodes[i]+7);
    1850:	80 91 8e 00 	lds	r24, 0x008E
    1854:	89 5f       	subi	r24, 0xF9	; 249
    1856:	0e 94 20 0a 	call	0x1440	; 0x1440 <USARTWriteChar>
    185a:	8f ef       	ldi	r24, 0xFF	; 255
    185c:	9f e7       	ldi	r25, 0x7F	; 127
    185e:	a6 e1       	ldi	r26, 0x16	; 22
    1860:	81 50       	subi	r24, 0x01	; 1
    1862:	90 40       	sbci	r25, 0x00	; 0
    1864:	a0 40       	sbci	r26, 0x00	; 0
    1866:	e1 f7       	brne	.-8      	; 0x1860 <direction+0x41c>
    1868:	00 c0       	rjmp	.+0      	; 0x186a <direction+0x426>
    186a:	00 00       	nop
			buzzer_off();
			blue_nodes[0]=53;
			blue_nodes[b]=54;
			blue_side[0]=53;
			blue_side[bs]=54;
			for(int i=0;i<=10;i++)
    186c:	c1 e0       	ldi	r28, 0x01	; 1
    186e:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(blue_nodes[i]==0)
    1870:	0e e8       	ldi	r16, 0x8E	; 142
    1872:	10 e0       	ldi	r17, 0x00	; 0
    1874:	d8 ce       	rjmp	.-592    	; 0x1626 <direction+0x1e2>
			for(int i=0;i<10;i++)
			{	if(green_side[i]==0)
				{
					break;
				}
				USARTWriteChar(green_side[i]);
    1876:	80 91 a0 00 	lds	r24, 0x00A0
    187a:	0e 94 20 0a 	call	0x1440	; 0x1440 <USARTWriteChar>
    187e:	8f ef       	ldi	r24, 0xFF	; 255
    1880:	9f e7       	ldi	r25, 0x7F	; 127
    1882:	a6 e1       	ldi	r26, 0x16	; 22
    1884:	81 50       	subi	r24, 0x01	; 1
    1886:	90 40       	sbci	r25, 0x00	; 0
    1888:	a0 40       	sbci	r26, 0x00	; 0
    188a:	e1 f7       	brne	.-8      	; 0x1884 <direction+0x440>
    188c:	00 c0       	rjmp	.+0      	; 0x188e <direction+0x44a>
    188e:	00 00       	nop
				
			}
			buzzer_on();
			_delay_ms(1000);
			buzzer_off();
			for(int i=0;i<10;i++)
    1890:	c1 e0       	ldi	r28, 0x01	; 1
    1892:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(green_side[i]==0)
    1894:	00 ea       	ldi	r16, 0xA0	; 160
    1896:	10 e0       	ldi	r17, 0x00	; 0
    1898:	88 ce       	rjmp	.-752    	; 0x15aa <direction+0x166>
				{
					
					break;
					
				}
				USARTWriteChar(green_nodes[i]);
    189a:	80 91 82 00 	lds	r24, 0x0082
    189e:	0e 94 20 0a 	call	0x1440	; 0x1440 <USARTWriteChar>
    18a2:	8f ef       	ldi	r24, 0xFF	; 255
    18a4:	9f e7       	ldi	r25, 0x7F	; 127
    18a6:	a6 e1       	ldi	r26, 0x16	; 22
    18a8:	81 50       	subi	r24, 0x01	; 1
    18aa:	90 40       	sbci	r25, 0x00	; 0
    18ac:	a0 40       	sbci	r26, 0x00	; 0
    18ae:	e1 f7       	brne	.-8      	; 0x18a8 <direction+0x464>
    18b0:	00 c0       	rjmp	.+0      	; 0x18b2 <direction+0x46e>
    18b2:	00 00       	nop
			
			green_nodes[0]=55;
			green_nodes[gn]=56;
			green_side[0]=55;
			green_side[gs]=56;
			for(int i=0;i<=10;i++)
    18b4:	c1 e0       	ldi	r28, 0x01	; 1
    18b6:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(green_nodes[i]==0)
    18b8:	02 e8       	ldi	r16, 0x82	; 130
    18ba:	10 e0       	ldi	r17, 0x00	; 0
    18bc:	4a ce       	rjmp	.-876    	; 0x1552 <direction+0x10e>
			
			
		}
//		lcd_print(2,5,dir,2);
	}
}
    18be:	df 91       	pop	r29
    18c0:	cf 91       	pop	r28
    18c2:	1f 91       	pop	r17
    18c4:	0f 91       	pop	r16
    18c6:	08 95       	ret

000018c8 <array_init>:


void array_init()
{
	for(int i=0;i<=10;i++)
    18c8:	80 e0       	ldi	r24, 0x00	; 0
    18ca:	90 e0       	ldi	r25, 0x00	; 0
	{
		blue_nodes[i]=0;
    18cc:	2e e8       	ldi	r18, 0x8E	; 142
    18ce:	30 e0       	ldi	r19, 0x00	; 0
		green_nodes[i]=0;
    18d0:	42 e8       	ldi	r20, 0x82	; 130
    18d2:	50 e0       	ldi	r21, 0x00	; 0

void array_init()
{
	for(int i=0;i<=10;i++)
	{
		blue_nodes[i]=0;
    18d4:	f9 01       	movw	r30, r18
    18d6:	e8 0f       	add	r30, r24
    18d8:	f9 1f       	adc	r31, r25
    18da:	10 82       	st	Z, r1
		green_nodes[i]=0;
    18dc:	fa 01       	movw	r30, r20
    18de:	e8 0f       	add	r30, r24
    18e0:	f9 1f       	adc	r31, r25
    18e2:	10 82       	st	Z, r1


void array_init()
{
	for(int i=0;i<=10;i++)
    18e4:	01 96       	adiw	r24, 0x01	; 1
    18e6:	8b 30       	cpi	r24, 0x0B	; 11
    18e8:	91 05       	cpc	r25, r1
    18ea:	a1 f7       	brne	.-24     	; 0x18d4 <array_init+0xc>
    18ec:	80 e0       	ldi	r24, 0x00	; 0
    18ee:	90 e0       	ldi	r25, 0x00	; 0
		blue_nodes[i]=0;
		green_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
	{
		blue_side[i]=0;
    18f0:	2c ea       	ldi	r18, 0xAC	; 172
    18f2:	30 e0       	ldi	r19, 0x00	; 0
		green_side[i]=0;
    18f4:	40 ea       	ldi	r20, 0xA0	; 160
    18f6:	50 e0       	ldi	r21, 0x00	; 0
		blue_nodes[i]=0;
		green_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
	{
		blue_side[i]=0;
    18f8:	f9 01       	movw	r30, r18
    18fa:	e8 0f       	add	r30, r24
    18fc:	f9 1f       	adc	r31, r25
    18fe:	10 82       	st	Z, r1
		green_side[i]=0;
    1900:	fa 01       	movw	r30, r20
    1902:	e8 0f       	add	r30, r24
    1904:	f9 1f       	adc	r31, r25
    1906:	10 82       	st	Z, r1
	for(int i=0;i<=10;i++)
	{
		blue_nodes[i]=0;
		green_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
    1908:	01 96       	adiw	r24, 0x01	; 1
    190a:	85 31       	cpi	r24, 0x15	; 21
    190c:	91 05       	cpc	r25, r1
    190e:	a1 f7       	brne	.-24     	; 0x18f8 <array_init+0x30>
	{
		blue_side[i]=0;
		green_side[i]=0;
	}
}
    1910:	08 95       	ret

00001912 <ReachDestinationAvoidingNode>:
#include "direction.h"
//#include "adjsrc4.h"


void ReachDestinationAvoidingNode(unsigned char Xd,unsigned char Yd)
{
    1912:	cf 93       	push	r28
    1914:	df 93       	push	r29
    1916:	cd b7       	in	r28, 0x3d	; 61
    1918:	de b7       	in	r29, 0x3e	; 62
    191a:	2f 97       	sbiw	r28, 0x0f	; 15
    191c:	0f b6       	in	r0, 0x3f	; 63
    191e:	f8 94       	cli
    1920:	de bf       	out	0x3e, r29	; 62
    1922:	0f be       	out	0x3f, r0	; 63
    1924:	cd bf       	out	0x3d, r28	; 61
	
	

	path1 = main_function7( start,des);
    1926:	ce 01       	movw	r24, r28
    1928:	01 96       	adiw	r24, 0x01	; 1
    192a:	60 91 68 00 	lds	r22, 0x0068
    192e:	40 91 67 00 	lds	r20, 0x0067
    1932:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <main_function7>
    1936:	a8 ec       	ldi	r26, 0xC8	; 200
    1938:	b0 e0       	ldi	r27, 0x00	; 0
    193a:	fe 01       	movw	r30, r28
    193c:	31 96       	adiw	r30, 0x01	; 1
    193e:	8f e0       	ldi	r24, 0x0F	; 15
    1940:	01 90       	ld	r0, Z+
    1942:	0d 92       	st	X+, r0
    1944:	81 50       	subi	r24, 0x01	; 1
    1946:	e1 f7       	brne	.-8      	; 0x1940 <ReachDestinationAvoidingNode+0x2e>
	
	
	

	init_devices();
    1948:	0e 94 6d 06 	call	0xcda	; 0xcda <init_devices>

	

	while(1)
	{
		line_follower();
    194c:	0e 94 76 06 	call	0xcec	; 0xcec <line_follower>
		if (g==1)
    1950:	80 91 81 00 	lds	r24, 0x0081
    1954:	81 30       	cpi	r24, 0x01	; 1
    1956:	d1 f7       	brne	.-12     	; 0x194c <ReachDestinationAvoidingNode+0x3a>
			
		
		
	}
	
	g=0;
    1958:	10 92 81 00 	sts	0x0081, r1
	l=0;
    195c:	10 92 77 00 	sts	0x0077, r1
	t=0;
    1960:	10 92 76 00 	sts	0x0076, r1
	back();
    1964:	0e 94 89 05 	call	0xb12	; 0xb12 <back>
	velocity(100,100);
    1968:	84 e6       	ldi	r24, 0x64	; 100
    196a:	64 e6       	ldi	r22, 0x64	; 100
    196c:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
    1970:	8f ef       	ldi	r24, 0xFF	; 255
    1972:	9f eb       	ldi	r25, 0xBF	; 191
    1974:	a1 e2       	ldi	r26, 0x21	; 33
    1976:	81 50       	subi	r24, 0x01	; 1
    1978:	90 40       	sbci	r25, 0x00	; 0
    197a:	a0 40       	sbci	r26, 0x00	; 0
    197c:	e1 f7       	brne	.-8      	; 0x1976 <ReachDestinationAvoidingNode+0x64>
    197e:	00 c0       	rjmp	.+0      	; 0x1980 <ReachDestinationAvoidingNode+0x6e>
    1980:	00 00       	nop
	
	_delay_ms(1500);
	start=des;
    1982:	80 91 67 00 	lds	r24, 0x0067
    1986:	80 93 68 00 	sts	0x0068, r24
}
    198a:	2f 96       	adiw	r28, 0x0f	; 15
    198c:	0f b6       	in	r0, 0x3f	; 63
    198e:	f8 94       	cli
    1990:	de bf       	out	0x3e, r29	; 62
    1992:	0f be       	out	0x3f, r0	; 63
    1994:	cd bf       	out	0x3d, r28	; 61
    1996:	df 91       	pop	r29
    1998:	cf 91       	pop	r28
    199a:	08 95       	ret

0000199c <main>:


//Do not make changes in main function

int main(void)
{   DDRB=0x20; 
    199c:	80 e2       	ldi	r24, 0x20	; 32
    199e:	87 bb       	out	0x17, r24	; 23
	init_devices_zigbee();
    19a0:	0e 94 5d 09 	call	0x12ba	; 0x12ba <init_devices_zigbee>
	
	stage=1;
    19a4:	81 e0       	ldi	r24, 0x01	; 1
    19a6:	80 93 65 00 	sts	0x0065, r24
	t=0;
    19aa:	10 92 76 00 	sts	0x0076, r1
     ReachDestinationAvoidingNode(start,des);//22-6
    19ae:	80 91 68 00 	lds	r24, 0x0068
    19b2:	60 91 67 00 	lds	r22, 0x0067
    19b6:	0e 94 89 0c 	call	0x1912	; 0x1912 <ReachDestinationAvoidingNode>
	 buzzer_on();
    19ba:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    19be:	8f ef       	ldi	r24, 0xFF	; 255
    19c0:	9f e7       	ldi	r25, 0x7F	; 127
    19c2:	a6 e1       	ldi	r26, 0x16	; 22
    19c4:	81 50       	subi	r24, 0x01	; 1
    19c6:	90 40       	sbci	r25, 0x00	; 0
    19c8:	a0 40       	sbci	r26, 0x00	; 0
    19ca:	e1 f7       	brne	.-8      	; 0x19c4 <main+0x28>
    19cc:	00 c0       	rjmp	.+0      	; 0x19ce <main+0x32>
    19ce:	00 00       	nop
	   _delay_ms(1000);
	   buzzer_off();
    19d0:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
	stage=2;
    19d4:	82 e0       	ldi	r24, 0x02	; 2
    19d6:	80 93 65 00 	sts	0x0065, r24
	//start=5;
	des=48;
    19da:	80 e3       	ldi	r24, 0x30	; 48
    19dc:	80 93 67 00 	sts	0x0067, r24
	array_init();
    19e0:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <array_init>
		ReachDestinationAvoidingNode(start,des);//6-48
    19e4:	80 91 68 00 	lds	r24, 0x0068
    19e8:	60 91 67 00 	lds	r22, 0x0067
    19ec:	0e 94 89 0c 	call	0x1912	; 0x1912 <ReachDestinationAvoidingNode>
		buzzer_on();
    19f0:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    19f4:	8f ef       	ldi	r24, 0xFF	; 255
    19f6:	9f e7       	ldi	r25, 0x7F	; 127
    19f8:	a6 e1       	ldi	r26, 0x16	; 22
    19fa:	81 50       	subi	r24, 0x01	; 1
    19fc:	90 40       	sbci	r25, 0x00	; 0
    19fe:	a0 40       	sbci	r26, 0x00	; 0
    1a00:	e1 f7       	brne	.-8      	; 0x19fa <main+0x5e>
    1a02:	00 c0       	rjmp	.+0      	; 0x1a04 <main+0x68>
    1a04:	00 00       	nop
		_delay_ms(1000);
		buzzer_off();
    1a06:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
	//stage=4;
	//des=2;
	//ReachDestinationAvoidingNode(start,des);//4-2
	
 	stage=3;
    1a0a:	83 e0       	ldi	r24, 0x03	; 3
    1a0c:	80 93 65 00 	sts	0x0065, r24
	//start=2;////////
	/////////////stage==3/////start=4///
	des=4;
    1a10:	84 e0       	ldi	r24, 0x04	; 4
    1a12:	80 93 67 00 	sts	0x0067, r24
	ReachDestinationAvoidingNode(start,des);///48-4
    1a16:	80 91 68 00 	lds	r24, 0x0068
    1a1a:	64 e0       	ldi	r22, 0x04	; 4
    1a1c:	0e 94 89 0c 	call	0x1912	; 0x1912 <ReachDestinationAvoidingNode>
	buzzer_on();
    1a20:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    1a24:	8f ef       	ldi	r24, 0xFF	; 255
    1a26:	9f e7       	ldi	r25, 0x7F	; 127
    1a28:	a6 e1       	ldi	r26, 0x16	; 22
    1a2a:	81 50       	subi	r24, 0x01	; 1
    1a2c:	90 40       	sbci	r25, 0x00	; 0
    1a2e:	a0 40       	sbci	r26, 0x00	; 0
    1a30:	e1 f7       	brne	.-8      	; 0x1a2a <main+0x8e>
    1a32:	00 c0       	rjmp	.+0      	; 0x1a34 <main+0x98>
    1a34:	00 00       	nop
	_delay_ms(1000);
	buzzer_off();
    1a36:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
    1a3a:	60 91 67 00 	lds	r22, 0x0067
    1a3e:	80 e0       	ldi	r24, 0x00	; 0
    1a40:	90 e0       	ldi	r25, 0x00	; 0
	
	//stage=4;
	//des=48;
	_Bool red_des_count=0;
    1a42:	40 e0       	ldi	r20, 0x00	; 0
	for (unsigned char i=0;i<=10;i++)
	{
		switch (red_nodes[i])
    1a44:	23 ef       	ldi	r18, 0xF3	; 243
    1a46:	30 e0       	ldi	r19, 0x00	; 0
			case 9:
			des=9;
			red_des_count=1;
			break;
			case 16:
			des=16;
    1a48:	10 e1       	ldi	r17, 0x10	; 16
			red_des_count=1;
    1a4a:	71 e0       	ldi	r23, 0x01	; 1
			case 23:
			des=23;
			red_des_count=1;
			break;
			case 30:
			des=30;
    1a4c:	de e1       	ldi	r29, 0x1E	; 30
			case 16:
			des=16;
			red_des_count=1;
			break;
			case 23:
			des=23;
    1a4e:	c7 e1       	ldi	r28, 0x17	; 23
	for (unsigned char i=0;i<=10;i++)
	{
		switch (red_nodes[i])
		{
			case 2:
			des=2;
    1a50:	b2 e0       	ldi	r27, 0x02	; 2
			red_des_count=1;
			break;
			case 9:
			des=9;
    1a52:	a9 e0       	ldi	r26, 0x09	; 9
	//stage=4;
	//des=48;
	_Bool red_des_count=0;
	for (unsigned char i=0;i<=10;i++)
	{
		switch (red_nodes[i])
    1a54:	f9 01       	movw	r30, r18
    1a56:	e8 0f       	add	r30, r24
    1a58:	f9 1f       	adc	r31, r25
    1a5a:	50 81       	ld	r21, Z
    1a5c:	50 31       	cpi	r21, 0x10	; 16
    1a5e:	a1 f0       	breq	.+40     	; 0x1a88 <main+0xec>
    1a60:	51 31       	cpi	r21, 0x11	; 17
    1a62:	28 f4       	brcc	.+10     	; 0x1a6e <main+0xd2>
    1a64:	52 30       	cpi	r21, 0x02	; 2
    1a66:	51 f0       	breq	.+20     	; 0x1a7c <main+0xe0>
    1a68:	59 30       	cpi	r21, 0x09	; 9
    1a6a:	c9 f4       	brne	.+50     	; 0x1a9e <main+0x102>
    1a6c:	0a c0       	rjmp	.+20     	; 0x1a82 <main+0xe6>
    1a6e:	5e 31       	cpi	r21, 0x1E	; 30
    1a70:	89 f0       	breq	.+34     	; 0x1a94 <main+0xf8>
    1a72:	55 32       	cpi	r21, 0x25	; 37
    1a74:	91 f0       	breq	.+36     	; 0x1a9a <main+0xfe>
    1a76:	57 31       	cpi	r21, 0x17	; 23
    1a78:	91 f4       	brne	.+36     	; 0x1a9e <main+0x102>
    1a7a:	09 c0       	rjmp	.+18     	; 0x1a8e <main+0xf2>
		{
			case 2:
			des=2;
    1a7c:	6b 2f       	mov	r22, r27
			red_des_count=1;
    1a7e:	47 2f       	mov	r20, r23
			break;
    1a80:	0e c0       	rjmp	.+28     	; 0x1a9e <main+0x102>
			case 9:
			des=9;
    1a82:	6a 2f       	mov	r22, r26
			red_des_count=1;
    1a84:	47 2f       	mov	r20, r23
			break;
    1a86:	0b c0       	rjmp	.+22     	; 0x1a9e <main+0x102>
			case 16:
			des=16;
    1a88:	61 2f       	mov	r22, r17
			red_des_count=1;
    1a8a:	47 2f       	mov	r20, r23
			break;
    1a8c:	08 c0       	rjmp	.+16     	; 0x1a9e <main+0x102>
			case 23:
			des=23;
    1a8e:	6c 2f       	mov	r22, r28
			red_des_count=1;
    1a90:	47 2f       	mov	r20, r23
			break;
    1a92:	05 c0       	rjmp	.+10     	; 0x1a9e <main+0x102>
			case 30:
			des=30;
    1a94:	6d 2f       	mov	r22, r29
			red_des_count=1;
    1a96:	47 2f       	mov	r20, r23
			break;
    1a98:	02 c0       	rjmp	.+4      	; 0x1a9e <main+0x102>
			case 37:
			des=37;
    1a9a:	65 e2       	ldi	r22, 0x25	; 37
			red_des_count=1;
    1a9c:	47 2f       	mov	r20, r23
			break;
    1a9e:	01 96       	adiw	r24, 0x01	; 1
	buzzer_off();
	
	//stage=4;
	//des=48;
	_Bool red_des_count=0;
	for (unsigned char i=0;i<=10;i++)
    1aa0:	8b 30       	cpi	r24, 0x0B	; 11
    1aa2:	91 05       	cpc	r25, r1
    1aa4:	b9 f6       	brne	.-82     	; 0x1a54 <main+0xb8>
    1aa6:	60 93 67 00 	sts	0x0067, r22
			break;
			
			
		}
	}
	if (red_des_count==1)
    1aaa:	44 23       	and	r20, r20
    1aac:	09 f4       	brne	.+2      	; 0x1ab0 <main+0x114>
    1aae:	46 c0       	rjmp	.+140    	; 0x1b3c <main+0x1a0>
	{
		ReachDestinationAvoidingNode(start,des);//4-X
    1ab0:	80 91 68 00 	lds	r24, 0x0068
    1ab4:	0e 94 89 0c 	call	0x1912	; 0x1912 <ReachDestinationAvoidingNode>
		buzzer_on();
    1ab8:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    1abc:	8f ef       	ldi	r24, 0xFF	; 255
    1abe:	9f e7       	ldi	r25, 0x7F	; 127
    1ac0:	a6 e1       	ldi	r26, 0x16	; 22
    1ac2:	81 50       	subi	r24, 0x01	; 1
    1ac4:	90 40       	sbci	r25, 0x00	; 0
    1ac6:	a0 40       	sbci	r26, 0x00	; 0
    1ac8:	e1 f7       	brne	.-8      	; 0x1ac2 <main+0x126>
    1aca:	00 c0       	rjmp	.+0      	; 0x1acc <main+0x130>
    1acc:	00 00       	nop
		_delay_ms(1000);
		buzzer_off();
    1ace:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
		des=8;
    1ad2:	88 e0       	ldi	r24, 0x08	; 8
    1ad4:	80 93 67 00 	sts	0x0067, r24
		ReachDestinationAvoidingNode(start,des);//X-8
    1ad8:	80 91 68 00 	lds	r24, 0x0068
    1adc:	68 e0       	ldi	r22, 0x08	; 8
    1ade:	0e 94 89 0c 	call	0x1912	; 0x1912 <ReachDestinationAvoidingNode>
		buzzer_on();
    1ae2:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    1ae6:	8f ef       	ldi	r24, 0xFF	; 255
    1ae8:	9f e3       	ldi	r25, 0x3F	; 63
    1aea:	ab e0       	ldi	r26, 0x0B	; 11
    1aec:	81 50       	subi	r24, 0x01	; 1
    1aee:	90 40       	sbci	r25, 0x00	; 0
    1af0:	a0 40       	sbci	r26, 0x00	; 0
    1af2:	e1 f7       	brne	.-8      	; 0x1aec <main+0x150>
    1af4:	00 c0       	rjmp	.+0      	; 0x1af6 <main+0x15a>
    1af6:	00 00       	nop
		_delay_ms(500);
		buzzer_off();
    1af8:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
    1afc:	8f ef       	ldi	r24, 0xFF	; 255
    1afe:	9f e3       	ldi	r25, 0x3F	; 63
    1b00:	ab e0       	ldi	r26, 0x0B	; 11
    1b02:	81 50       	subi	r24, 0x01	; 1
    1b04:	90 40       	sbci	r25, 0x00	; 0
    1b06:	a0 40       	sbci	r26, 0x00	; 0
    1b08:	e1 f7       	brne	.-8      	; 0x1b02 <main+0x166>
    1b0a:	00 c0       	rjmp	.+0      	; 0x1b0c <main+0x170>
    1b0c:	00 00       	nop
		_delay_ms(500);
		buzzer_on();
    1b0e:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    1b12:	8f ef       	ldi	r24, 0xFF	; 255
    1b14:	9f e3       	ldi	r25, 0x3F	; 63
    1b16:	ab e0       	ldi	r26, 0x0B	; 11
    1b18:	81 50       	subi	r24, 0x01	; 1
    1b1a:	90 40       	sbci	r25, 0x00	; 0
    1b1c:	a0 40       	sbci	r26, 0x00	; 0
    1b1e:	e1 f7       	brne	.-8      	; 0x1b18 <main+0x17c>
    1b20:	00 c0       	rjmp	.+0      	; 0x1b22 <main+0x186>
    1b22:	00 00       	nop
		_delay_ms(500);
		buzzer_off();
    1b24:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
    1b28:	8f ef       	ldi	r24, 0xFF	; 255
    1b2a:	9f e3       	ldi	r25, 0x3F	; 63
    1b2c:	ab e0       	ldi	r26, 0x0B	; 11
    1b2e:	81 50       	subi	r24, 0x01	; 1
    1b30:	90 40       	sbci	r25, 0x00	; 0
    1b32:	a0 40       	sbci	r26, 0x00	; 0
    1b34:	e1 f7       	brne	.-8      	; 0x1b2e <main+0x192>
    1b36:	00 c0       	rjmp	.+0      	; 0x1b38 <main+0x19c>
    1b38:	00 00       	nop
    1b3a:	34 c0       	rjmp	.+104    	; 0x1ba4 <main+0x208>
		_delay_ms(500);
	}
	else if (red_des_count==0)
	{	des=8;
    1b3c:	88 e0       	ldi	r24, 0x08	; 8
    1b3e:	80 93 67 00 	sts	0x0067, r24
		ReachDestinationAvoidingNode(start,des);//4-8
    1b42:	80 91 68 00 	lds	r24, 0x0068
    1b46:	68 e0       	ldi	r22, 0x08	; 8
    1b48:	0e 94 89 0c 	call	0x1912	; 0x1912 <ReachDestinationAvoidingNode>
		buzzer_on();
    1b4c:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    1b50:	8f ef       	ldi	r24, 0xFF	; 255
    1b52:	9f e3       	ldi	r25, 0x3F	; 63
    1b54:	ab e0       	ldi	r26, 0x0B	; 11
    1b56:	81 50       	subi	r24, 0x01	; 1
    1b58:	90 40       	sbci	r25, 0x00	; 0
    1b5a:	a0 40       	sbci	r26, 0x00	; 0
    1b5c:	e1 f7       	brne	.-8      	; 0x1b56 <main+0x1ba>
    1b5e:	00 c0       	rjmp	.+0      	; 0x1b60 <main+0x1c4>
    1b60:	00 00       	nop
		_delay_ms(500);
		buzzer_off();
    1b62:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
    1b66:	8f ef       	ldi	r24, 0xFF	; 255
    1b68:	9f e3       	ldi	r25, 0x3F	; 63
    1b6a:	ab e0       	ldi	r26, 0x0B	; 11
    1b6c:	81 50       	subi	r24, 0x01	; 1
    1b6e:	90 40       	sbci	r25, 0x00	; 0
    1b70:	a0 40       	sbci	r26, 0x00	; 0
    1b72:	e1 f7       	brne	.-8      	; 0x1b6c <main+0x1d0>
    1b74:	00 c0       	rjmp	.+0      	; 0x1b76 <main+0x1da>
    1b76:	00 00       	nop
		_delay_ms(500);
		
		buzzer_on();
    1b78:	0e 94 c0 00 	call	0x180	; 0x180 <buzzer_on>
    1b7c:	8f ef       	ldi	r24, 0xFF	; 255
    1b7e:	9f e3       	ldi	r25, 0x3F	; 63
    1b80:	ab e0       	ldi	r26, 0x0B	; 11
    1b82:	81 50       	subi	r24, 0x01	; 1
    1b84:	90 40       	sbci	r25, 0x00	; 0
    1b86:	a0 40       	sbci	r26, 0x00	; 0
    1b88:	e1 f7       	brne	.-8      	; 0x1b82 <main+0x1e6>
    1b8a:	00 c0       	rjmp	.+0      	; 0x1b8c <main+0x1f0>
    1b8c:	00 00       	nop
		_delay_ms(500);
		buzzer_off();
    1b8e:	0e 94 c4 00 	call	0x188	; 0x188 <buzzer_off>
    1b92:	8f ef       	ldi	r24, 0xFF	; 255
    1b94:	9f e3       	ldi	r25, 0x3F	; 63
    1b96:	ab e0       	ldi	r26, 0x0B	; 11
    1b98:	81 50       	subi	r24, 0x01	; 1
    1b9a:	90 40       	sbci	r25, 0x00	; 0
    1b9c:	a0 40       	sbci	r26, 0x00	; 0
    1b9e:	e1 f7       	brne	.-8      	; 0x1b98 <main+0x1fc>
    1ba0:	00 c0       	rjmp	.+0      	; 0x1ba2 <main+0x206>
    1ba2:	00 00       	nop
	
	
	
	
	
	forward();
    1ba4:	0e 94 85 05 	call	0xb0a	; 0xb0a <forward>
	velocity(0,0);
    1ba8:	80 e0       	ldi	r24, 0x00	; 0
    1baa:	60 e0       	ldi	r22, 0x00	; 0
    1bac:	0e 94 a5 05 	call	0xb4a	; 0xb4a <velocity>
    1bb0:	ff cf       	rjmp	.-2      	; 0x1bb0 <main+0x214>

00001bb2 <__subsf3>:
    1bb2:	50 58       	subi	r21, 0x80	; 128

00001bb4 <__addsf3>:
    1bb4:	bb 27       	eor	r27, r27
    1bb6:	aa 27       	eor	r26, r26
    1bb8:	0e d0       	rcall	.+28     	; 0x1bd6 <__addsf3x>
    1bba:	48 c1       	rjmp	.+656    	; 0x1e4c <__fp_round>
    1bbc:	39 d1       	rcall	.+626    	; 0x1e30 <__fp_pscA>
    1bbe:	30 f0       	brcs	.+12     	; 0x1bcc <__addsf3+0x18>
    1bc0:	3e d1       	rcall	.+636    	; 0x1e3e <__fp_pscB>
    1bc2:	20 f0       	brcs	.+8      	; 0x1bcc <__addsf3+0x18>
    1bc4:	31 f4       	brne	.+12     	; 0x1bd2 <__addsf3+0x1e>
    1bc6:	9f 3f       	cpi	r25, 0xFF	; 255
    1bc8:	11 f4       	brne	.+4      	; 0x1bce <__addsf3+0x1a>
    1bca:	1e f4       	brtc	.+6      	; 0x1bd2 <__addsf3+0x1e>
    1bcc:	2e c1       	rjmp	.+604    	; 0x1e2a <__fp_nan>
    1bce:	0e f4       	brtc	.+2      	; 0x1bd2 <__addsf3+0x1e>
    1bd0:	e0 95       	com	r30
    1bd2:	e7 fb       	bst	r30, 7
    1bd4:	24 c1       	rjmp	.+584    	; 0x1e1e <__fp_inf>

00001bd6 <__addsf3x>:
    1bd6:	e9 2f       	mov	r30, r25
    1bd8:	4a d1       	rcall	.+660    	; 0x1e6e <__fp_split3>
    1bda:	80 f3       	brcs	.-32     	; 0x1bbc <__addsf3+0x8>
    1bdc:	ba 17       	cp	r27, r26
    1bde:	62 07       	cpc	r22, r18
    1be0:	73 07       	cpc	r23, r19
    1be2:	84 07       	cpc	r24, r20
    1be4:	95 07       	cpc	r25, r21
    1be6:	18 f0       	brcs	.+6      	; 0x1bee <__addsf3x+0x18>
    1be8:	71 f4       	brne	.+28     	; 0x1c06 <__addsf3x+0x30>
    1bea:	9e f5       	brtc	.+102    	; 0x1c52 <__addsf3x+0x7c>
    1bec:	62 c1       	rjmp	.+708    	; 0x1eb2 <__fp_zero>
    1bee:	0e f4       	brtc	.+2      	; 0x1bf2 <__addsf3x+0x1c>
    1bf0:	e0 95       	com	r30
    1bf2:	0b 2e       	mov	r0, r27
    1bf4:	ba 2f       	mov	r27, r26
    1bf6:	a0 2d       	mov	r26, r0
    1bf8:	0b 01       	movw	r0, r22
    1bfa:	b9 01       	movw	r22, r18
    1bfc:	90 01       	movw	r18, r0
    1bfe:	0c 01       	movw	r0, r24
    1c00:	ca 01       	movw	r24, r20
    1c02:	a0 01       	movw	r20, r0
    1c04:	11 24       	eor	r1, r1
    1c06:	ff 27       	eor	r31, r31
    1c08:	59 1b       	sub	r21, r25
    1c0a:	99 f0       	breq	.+38     	; 0x1c32 <__addsf3x+0x5c>
    1c0c:	59 3f       	cpi	r21, 0xF9	; 249
    1c0e:	50 f4       	brcc	.+20     	; 0x1c24 <__addsf3x+0x4e>
    1c10:	50 3e       	cpi	r21, 0xE0	; 224
    1c12:	68 f1       	brcs	.+90     	; 0x1c6e <__addsf3x+0x98>
    1c14:	1a 16       	cp	r1, r26
    1c16:	f0 40       	sbci	r31, 0x00	; 0
    1c18:	a2 2f       	mov	r26, r18
    1c1a:	23 2f       	mov	r18, r19
    1c1c:	34 2f       	mov	r19, r20
    1c1e:	44 27       	eor	r20, r20
    1c20:	58 5f       	subi	r21, 0xF8	; 248
    1c22:	f3 cf       	rjmp	.-26     	; 0x1c0a <__addsf3x+0x34>
    1c24:	46 95       	lsr	r20
    1c26:	37 95       	ror	r19
    1c28:	27 95       	ror	r18
    1c2a:	a7 95       	ror	r26
    1c2c:	f0 40       	sbci	r31, 0x00	; 0
    1c2e:	53 95       	inc	r21
    1c30:	c9 f7       	brne	.-14     	; 0x1c24 <__addsf3x+0x4e>
    1c32:	7e f4       	brtc	.+30     	; 0x1c52 <__addsf3x+0x7c>
    1c34:	1f 16       	cp	r1, r31
    1c36:	ba 0b       	sbc	r27, r26
    1c38:	62 0b       	sbc	r22, r18
    1c3a:	73 0b       	sbc	r23, r19
    1c3c:	84 0b       	sbc	r24, r20
    1c3e:	ba f0       	brmi	.+46     	; 0x1c6e <__addsf3x+0x98>
    1c40:	91 50       	subi	r25, 0x01	; 1
    1c42:	a1 f0       	breq	.+40     	; 0x1c6c <__addsf3x+0x96>
    1c44:	ff 0f       	add	r31, r31
    1c46:	bb 1f       	adc	r27, r27
    1c48:	66 1f       	adc	r22, r22
    1c4a:	77 1f       	adc	r23, r23
    1c4c:	88 1f       	adc	r24, r24
    1c4e:	c2 f7       	brpl	.-16     	; 0x1c40 <__addsf3x+0x6a>
    1c50:	0e c0       	rjmp	.+28     	; 0x1c6e <__addsf3x+0x98>
    1c52:	ba 0f       	add	r27, r26
    1c54:	62 1f       	adc	r22, r18
    1c56:	73 1f       	adc	r23, r19
    1c58:	84 1f       	adc	r24, r20
    1c5a:	48 f4       	brcc	.+18     	; 0x1c6e <__addsf3x+0x98>
    1c5c:	87 95       	ror	r24
    1c5e:	77 95       	ror	r23
    1c60:	67 95       	ror	r22
    1c62:	b7 95       	ror	r27
    1c64:	f7 95       	ror	r31
    1c66:	9e 3f       	cpi	r25, 0xFE	; 254
    1c68:	08 f0       	brcs	.+2      	; 0x1c6c <__addsf3x+0x96>
    1c6a:	b3 cf       	rjmp	.-154    	; 0x1bd2 <__addsf3+0x1e>
    1c6c:	93 95       	inc	r25
    1c6e:	88 0f       	add	r24, r24
    1c70:	08 f0       	brcs	.+2      	; 0x1c74 <__addsf3x+0x9e>
    1c72:	99 27       	eor	r25, r25
    1c74:	ee 0f       	add	r30, r30
    1c76:	97 95       	ror	r25
    1c78:	87 95       	ror	r24
    1c7a:	08 95       	ret

00001c7c <__divsf3>:
    1c7c:	0c d0       	rcall	.+24     	; 0x1c96 <__divsf3x>
    1c7e:	e6 c0       	rjmp	.+460    	; 0x1e4c <__fp_round>
    1c80:	de d0       	rcall	.+444    	; 0x1e3e <__fp_pscB>
    1c82:	40 f0       	brcs	.+16     	; 0x1c94 <__divsf3+0x18>
    1c84:	d5 d0       	rcall	.+426    	; 0x1e30 <__fp_pscA>
    1c86:	30 f0       	brcs	.+12     	; 0x1c94 <__divsf3+0x18>
    1c88:	21 f4       	brne	.+8      	; 0x1c92 <__divsf3+0x16>
    1c8a:	5f 3f       	cpi	r21, 0xFF	; 255
    1c8c:	19 f0       	breq	.+6      	; 0x1c94 <__divsf3+0x18>
    1c8e:	c7 c0       	rjmp	.+398    	; 0x1e1e <__fp_inf>
    1c90:	51 11       	cpse	r21, r1
    1c92:	10 c1       	rjmp	.+544    	; 0x1eb4 <__fp_szero>
    1c94:	ca c0       	rjmp	.+404    	; 0x1e2a <__fp_nan>

00001c96 <__divsf3x>:
    1c96:	eb d0       	rcall	.+470    	; 0x1e6e <__fp_split3>
    1c98:	98 f3       	brcs	.-26     	; 0x1c80 <__divsf3+0x4>

00001c9a <__divsf3_pse>:
    1c9a:	99 23       	and	r25, r25
    1c9c:	c9 f3       	breq	.-14     	; 0x1c90 <__divsf3+0x14>
    1c9e:	55 23       	and	r21, r21
    1ca0:	b1 f3       	breq	.-20     	; 0x1c8e <__divsf3+0x12>
    1ca2:	95 1b       	sub	r25, r21
    1ca4:	55 0b       	sbc	r21, r21
    1ca6:	bb 27       	eor	r27, r27
    1ca8:	aa 27       	eor	r26, r26
    1caa:	62 17       	cp	r22, r18
    1cac:	73 07       	cpc	r23, r19
    1cae:	84 07       	cpc	r24, r20
    1cb0:	38 f0       	brcs	.+14     	; 0x1cc0 <__divsf3_pse+0x26>
    1cb2:	9f 5f       	subi	r25, 0xFF	; 255
    1cb4:	5f 4f       	sbci	r21, 0xFF	; 255
    1cb6:	22 0f       	add	r18, r18
    1cb8:	33 1f       	adc	r19, r19
    1cba:	44 1f       	adc	r20, r20
    1cbc:	aa 1f       	adc	r26, r26
    1cbe:	a9 f3       	breq	.-22     	; 0x1caa <__divsf3_pse+0x10>
    1cc0:	33 d0       	rcall	.+102    	; 0x1d28 <__divsf3_pse+0x8e>
    1cc2:	0e 2e       	mov	r0, r30
    1cc4:	3a f0       	brmi	.+14     	; 0x1cd4 <__divsf3_pse+0x3a>
    1cc6:	e0 e8       	ldi	r30, 0x80	; 128
    1cc8:	30 d0       	rcall	.+96     	; 0x1d2a <__divsf3_pse+0x90>
    1cca:	91 50       	subi	r25, 0x01	; 1
    1ccc:	50 40       	sbci	r21, 0x00	; 0
    1cce:	e6 95       	lsr	r30
    1cd0:	00 1c       	adc	r0, r0
    1cd2:	ca f7       	brpl	.-14     	; 0x1cc6 <__divsf3_pse+0x2c>
    1cd4:	29 d0       	rcall	.+82     	; 0x1d28 <__divsf3_pse+0x8e>
    1cd6:	fe 2f       	mov	r31, r30
    1cd8:	27 d0       	rcall	.+78     	; 0x1d28 <__divsf3_pse+0x8e>
    1cda:	66 0f       	add	r22, r22
    1cdc:	77 1f       	adc	r23, r23
    1cde:	88 1f       	adc	r24, r24
    1ce0:	bb 1f       	adc	r27, r27
    1ce2:	26 17       	cp	r18, r22
    1ce4:	37 07       	cpc	r19, r23
    1ce6:	48 07       	cpc	r20, r24
    1ce8:	ab 07       	cpc	r26, r27
    1cea:	b0 e8       	ldi	r27, 0x80	; 128
    1cec:	09 f0       	breq	.+2      	; 0x1cf0 <__divsf3_pse+0x56>
    1cee:	bb 0b       	sbc	r27, r27
    1cf0:	80 2d       	mov	r24, r0
    1cf2:	bf 01       	movw	r22, r30
    1cf4:	ff 27       	eor	r31, r31
    1cf6:	93 58       	subi	r25, 0x83	; 131
    1cf8:	5f 4f       	sbci	r21, 0xFF	; 255
    1cfa:	2a f0       	brmi	.+10     	; 0x1d06 <__divsf3_pse+0x6c>
    1cfc:	9e 3f       	cpi	r25, 0xFE	; 254
    1cfe:	51 05       	cpc	r21, r1
    1d00:	68 f0       	brcs	.+26     	; 0x1d1c <__divsf3_pse+0x82>
    1d02:	8d c0       	rjmp	.+282    	; 0x1e1e <__fp_inf>
    1d04:	d7 c0       	rjmp	.+430    	; 0x1eb4 <__fp_szero>
    1d06:	5f 3f       	cpi	r21, 0xFF	; 255
    1d08:	ec f3       	brlt	.-6      	; 0x1d04 <__divsf3_pse+0x6a>
    1d0a:	98 3e       	cpi	r25, 0xE8	; 232
    1d0c:	dc f3       	brlt	.-10     	; 0x1d04 <__divsf3_pse+0x6a>
    1d0e:	86 95       	lsr	r24
    1d10:	77 95       	ror	r23
    1d12:	67 95       	ror	r22
    1d14:	b7 95       	ror	r27
    1d16:	f7 95       	ror	r31
    1d18:	9f 5f       	subi	r25, 0xFF	; 255
    1d1a:	c9 f7       	brne	.-14     	; 0x1d0e <__divsf3_pse+0x74>
    1d1c:	88 0f       	add	r24, r24
    1d1e:	91 1d       	adc	r25, r1
    1d20:	96 95       	lsr	r25
    1d22:	87 95       	ror	r24
    1d24:	97 f9       	bld	r25, 7
    1d26:	08 95       	ret
    1d28:	e1 e0       	ldi	r30, 0x01	; 1
    1d2a:	66 0f       	add	r22, r22
    1d2c:	77 1f       	adc	r23, r23
    1d2e:	88 1f       	adc	r24, r24
    1d30:	bb 1f       	adc	r27, r27
    1d32:	62 17       	cp	r22, r18
    1d34:	73 07       	cpc	r23, r19
    1d36:	84 07       	cpc	r24, r20
    1d38:	ba 07       	cpc	r27, r26
    1d3a:	20 f0       	brcs	.+8      	; 0x1d44 <__divsf3_pse+0xaa>
    1d3c:	62 1b       	sub	r22, r18
    1d3e:	73 0b       	sbc	r23, r19
    1d40:	84 0b       	sbc	r24, r20
    1d42:	ba 0b       	sbc	r27, r26
    1d44:	ee 1f       	adc	r30, r30
    1d46:	88 f7       	brcc	.-30     	; 0x1d2a <__divsf3_pse+0x90>
    1d48:	e0 95       	com	r30
    1d4a:	08 95       	ret

00001d4c <__fixunssfsi>:
    1d4c:	98 d0       	rcall	.+304    	; 0x1e7e <__fp_splitA>
    1d4e:	88 f0       	brcs	.+34     	; 0x1d72 <__fixunssfsi+0x26>
    1d50:	9f 57       	subi	r25, 0x7F	; 127
    1d52:	90 f0       	brcs	.+36     	; 0x1d78 <__fixunssfsi+0x2c>
    1d54:	b9 2f       	mov	r27, r25
    1d56:	99 27       	eor	r25, r25
    1d58:	b7 51       	subi	r27, 0x17	; 23
    1d5a:	a0 f0       	brcs	.+40     	; 0x1d84 <__fixunssfsi+0x38>
    1d5c:	d1 f0       	breq	.+52     	; 0x1d92 <__fixunssfsi+0x46>
    1d5e:	66 0f       	add	r22, r22
    1d60:	77 1f       	adc	r23, r23
    1d62:	88 1f       	adc	r24, r24
    1d64:	99 1f       	adc	r25, r25
    1d66:	1a f0       	brmi	.+6      	; 0x1d6e <__fixunssfsi+0x22>
    1d68:	ba 95       	dec	r27
    1d6a:	c9 f7       	brne	.-14     	; 0x1d5e <__fixunssfsi+0x12>
    1d6c:	12 c0       	rjmp	.+36     	; 0x1d92 <__fixunssfsi+0x46>
    1d6e:	b1 30       	cpi	r27, 0x01	; 1
    1d70:	81 f0       	breq	.+32     	; 0x1d92 <__fixunssfsi+0x46>
    1d72:	9f d0       	rcall	.+318    	; 0x1eb2 <__fp_zero>
    1d74:	b1 e0       	ldi	r27, 0x01	; 1
    1d76:	08 95       	ret
    1d78:	9c c0       	rjmp	.+312    	; 0x1eb2 <__fp_zero>
    1d7a:	67 2f       	mov	r22, r23
    1d7c:	78 2f       	mov	r23, r24
    1d7e:	88 27       	eor	r24, r24
    1d80:	b8 5f       	subi	r27, 0xF8	; 248
    1d82:	39 f0       	breq	.+14     	; 0x1d92 <__fixunssfsi+0x46>
    1d84:	b9 3f       	cpi	r27, 0xF9	; 249
    1d86:	cc f3       	brlt	.-14     	; 0x1d7a <__fixunssfsi+0x2e>
    1d88:	86 95       	lsr	r24
    1d8a:	77 95       	ror	r23
    1d8c:	67 95       	ror	r22
    1d8e:	b3 95       	inc	r27
    1d90:	d9 f7       	brne	.-10     	; 0x1d88 <__fixunssfsi+0x3c>
    1d92:	3e f4       	brtc	.+14     	; 0x1da2 <__fixunssfsi+0x56>
    1d94:	90 95       	com	r25
    1d96:	80 95       	com	r24
    1d98:	70 95       	com	r23
    1d9a:	61 95       	neg	r22
    1d9c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d9e:	8f 4f       	sbci	r24, 0xFF	; 255
    1da0:	9f 4f       	sbci	r25, 0xFF	; 255
    1da2:	08 95       	ret

00001da4 <__floatunsisf>:
    1da4:	e8 94       	clt
    1da6:	09 c0       	rjmp	.+18     	; 0x1dba <__floatsisf+0x12>

00001da8 <__floatsisf>:
    1da8:	97 fb       	bst	r25, 7
    1daa:	3e f4       	brtc	.+14     	; 0x1dba <__floatsisf+0x12>
    1dac:	90 95       	com	r25
    1dae:	80 95       	com	r24
    1db0:	70 95       	com	r23
    1db2:	61 95       	neg	r22
    1db4:	7f 4f       	sbci	r23, 0xFF	; 255
    1db6:	8f 4f       	sbci	r24, 0xFF	; 255
    1db8:	9f 4f       	sbci	r25, 0xFF	; 255
    1dba:	99 23       	and	r25, r25
    1dbc:	a9 f0       	breq	.+42     	; 0x1de8 <__floatsisf+0x40>
    1dbe:	f9 2f       	mov	r31, r25
    1dc0:	96 e9       	ldi	r25, 0x96	; 150
    1dc2:	bb 27       	eor	r27, r27
    1dc4:	93 95       	inc	r25
    1dc6:	f6 95       	lsr	r31
    1dc8:	87 95       	ror	r24
    1dca:	77 95       	ror	r23
    1dcc:	67 95       	ror	r22
    1dce:	b7 95       	ror	r27
    1dd0:	f1 11       	cpse	r31, r1
    1dd2:	f8 cf       	rjmp	.-16     	; 0x1dc4 <__floatsisf+0x1c>
    1dd4:	fa f4       	brpl	.+62     	; 0x1e14 <__floatsisf+0x6c>
    1dd6:	bb 0f       	add	r27, r27
    1dd8:	11 f4       	brne	.+4      	; 0x1dde <__floatsisf+0x36>
    1dda:	60 ff       	sbrs	r22, 0
    1ddc:	1b c0       	rjmp	.+54     	; 0x1e14 <__floatsisf+0x6c>
    1dde:	6f 5f       	subi	r22, 0xFF	; 255
    1de0:	7f 4f       	sbci	r23, 0xFF	; 255
    1de2:	8f 4f       	sbci	r24, 0xFF	; 255
    1de4:	9f 4f       	sbci	r25, 0xFF	; 255
    1de6:	16 c0       	rjmp	.+44     	; 0x1e14 <__floatsisf+0x6c>
    1de8:	88 23       	and	r24, r24
    1dea:	11 f0       	breq	.+4      	; 0x1df0 <__floatsisf+0x48>
    1dec:	96 e9       	ldi	r25, 0x96	; 150
    1dee:	11 c0       	rjmp	.+34     	; 0x1e12 <__floatsisf+0x6a>
    1df0:	77 23       	and	r23, r23
    1df2:	21 f0       	breq	.+8      	; 0x1dfc <__floatsisf+0x54>
    1df4:	9e e8       	ldi	r25, 0x8E	; 142
    1df6:	87 2f       	mov	r24, r23
    1df8:	76 2f       	mov	r23, r22
    1dfa:	05 c0       	rjmp	.+10     	; 0x1e06 <__floatsisf+0x5e>
    1dfc:	66 23       	and	r22, r22
    1dfe:	71 f0       	breq	.+28     	; 0x1e1c <__floatsisf+0x74>
    1e00:	96 e8       	ldi	r25, 0x86	; 134
    1e02:	86 2f       	mov	r24, r22
    1e04:	70 e0       	ldi	r23, 0x00	; 0
    1e06:	60 e0       	ldi	r22, 0x00	; 0
    1e08:	2a f0       	brmi	.+10     	; 0x1e14 <__floatsisf+0x6c>
    1e0a:	9a 95       	dec	r25
    1e0c:	66 0f       	add	r22, r22
    1e0e:	77 1f       	adc	r23, r23
    1e10:	88 1f       	adc	r24, r24
    1e12:	da f7       	brpl	.-10     	; 0x1e0a <__floatsisf+0x62>
    1e14:	88 0f       	add	r24, r24
    1e16:	96 95       	lsr	r25
    1e18:	87 95       	ror	r24
    1e1a:	97 f9       	bld	r25, 7
    1e1c:	08 95       	ret

00001e1e <__fp_inf>:
    1e1e:	97 f9       	bld	r25, 7
    1e20:	9f 67       	ori	r25, 0x7F	; 127
    1e22:	80 e8       	ldi	r24, 0x80	; 128
    1e24:	70 e0       	ldi	r23, 0x00	; 0
    1e26:	60 e0       	ldi	r22, 0x00	; 0
    1e28:	08 95       	ret

00001e2a <__fp_nan>:
    1e2a:	9f ef       	ldi	r25, 0xFF	; 255
    1e2c:	80 ec       	ldi	r24, 0xC0	; 192
    1e2e:	08 95       	ret

00001e30 <__fp_pscA>:
    1e30:	00 24       	eor	r0, r0
    1e32:	0a 94       	dec	r0
    1e34:	16 16       	cp	r1, r22
    1e36:	17 06       	cpc	r1, r23
    1e38:	18 06       	cpc	r1, r24
    1e3a:	09 06       	cpc	r0, r25
    1e3c:	08 95       	ret

00001e3e <__fp_pscB>:
    1e3e:	00 24       	eor	r0, r0
    1e40:	0a 94       	dec	r0
    1e42:	12 16       	cp	r1, r18
    1e44:	13 06       	cpc	r1, r19
    1e46:	14 06       	cpc	r1, r20
    1e48:	05 06       	cpc	r0, r21
    1e4a:	08 95       	ret

00001e4c <__fp_round>:
    1e4c:	09 2e       	mov	r0, r25
    1e4e:	03 94       	inc	r0
    1e50:	00 0c       	add	r0, r0
    1e52:	11 f4       	brne	.+4      	; 0x1e58 <__fp_round+0xc>
    1e54:	88 23       	and	r24, r24
    1e56:	52 f0       	brmi	.+20     	; 0x1e6c <__fp_round+0x20>
    1e58:	bb 0f       	add	r27, r27
    1e5a:	40 f4       	brcc	.+16     	; 0x1e6c <__fp_round+0x20>
    1e5c:	bf 2b       	or	r27, r31
    1e5e:	11 f4       	brne	.+4      	; 0x1e64 <__fp_round+0x18>
    1e60:	60 ff       	sbrs	r22, 0
    1e62:	04 c0       	rjmp	.+8      	; 0x1e6c <__fp_round+0x20>
    1e64:	6f 5f       	subi	r22, 0xFF	; 255
    1e66:	7f 4f       	sbci	r23, 0xFF	; 255
    1e68:	8f 4f       	sbci	r24, 0xFF	; 255
    1e6a:	9f 4f       	sbci	r25, 0xFF	; 255
    1e6c:	08 95       	ret

00001e6e <__fp_split3>:
    1e6e:	57 fd       	sbrc	r21, 7
    1e70:	90 58       	subi	r25, 0x80	; 128
    1e72:	44 0f       	add	r20, r20
    1e74:	55 1f       	adc	r21, r21
    1e76:	59 f0       	breq	.+22     	; 0x1e8e <__fp_splitA+0x10>
    1e78:	5f 3f       	cpi	r21, 0xFF	; 255
    1e7a:	71 f0       	breq	.+28     	; 0x1e98 <__fp_splitA+0x1a>
    1e7c:	47 95       	ror	r20

00001e7e <__fp_splitA>:
    1e7e:	88 0f       	add	r24, r24
    1e80:	97 fb       	bst	r25, 7
    1e82:	99 1f       	adc	r25, r25
    1e84:	61 f0       	breq	.+24     	; 0x1e9e <__fp_splitA+0x20>
    1e86:	9f 3f       	cpi	r25, 0xFF	; 255
    1e88:	79 f0       	breq	.+30     	; 0x1ea8 <__fp_splitA+0x2a>
    1e8a:	87 95       	ror	r24
    1e8c:	08 95       	ret
    1e8e:	12 16       	cp	r1, r18
    1e90:	13 06       	cpc	r1, r19
    1e92:	14 06       	cpc	r1, r20
    1e94:	55 1f       	adc	r21, r21
    1e96:	f2 cf       	rjmp	.-28     	; 0x1e7c <__fp_split3+0xe>
    1e98:	46 95       	lsr	r20
    1e9a:	f1 df       	rcall	.-30     	; 0x1e7e <__fp_splitA>
    1e9c:	08 c0       	rjmp	.+16     	; 0x1eae <__fp_splitA+0x30>
    1e9e:	16 16       	cp	r1, r22
    1ea0:	17 06       	cpc	r1, r23
    1ea2:	18 06       	cpc	r1, r24
    1ea4:	99 1f       	adc	r25, r25
    1ea6:	f1 cf       	rjmp	.-30     	; 0x1e8a <__fp_splitA+0xc>
    1ea8:	86 95       	lsr	r24
    1eaa:	71 05       	cpc	r23, r1
    1eac:	61 05       	cpc	r22, r1
    1eae:	08 94       	sec
    1eb0:	08 95       	ret

00001eb2 <__fp_zero>:
    1eb2:	e8 94       	clt

00001eb4 <__fp_szero>:
    1eb4:	bb 27       	eor	r27, r27
    1eb6:	66 27       	eor	r22, r22
    1eb8:	77 27       	eor	r23, r23
    1eba:	cb 01       	movw	r24, r22
    1ebc:	97 f9       	bld	r25, 7
    1ebe:	08 95       	ret

00001ec0 <__divmodhi4>:
    1ec0:	97 fb       	bst	r25, 7
    1ec2:	09 2e       	mov	r0, r25
    1ec4:	07 26       	eor	r0, r23
    1ec6:	0a d0       	rcall	.+20     	; 0x1edc <__divmodhi4_neg1>
    1ec8:	77 fd       	sbrc	r23, 7
    1eca:	04 d0       	rcall	.+8      	; 0x1ed4 <__divmodhi4_neg2>
    1ecc:	0c d0       	rcall	.+24     	; 0x1ee6 <__udivmodhi4>
    1ece:	06 d0       	rcall	.+12     	; 0x1edc <__divmodhi4_neg1>
    1ed0:	00 20       	and	r0, r0
    1ed2:	1a f4       	brpl	.+6      	; 0x1eda <__divmodhi4_exit>

00001ed4 <__divmodhi4_neg2>:
    1ed4:	70 95       	com	r23
    1ed6:	61 95       	neg	r22
    1ed8:	7f 4f       	sbci	r23, 0xFF	; 255

00001eda <__divmodhi4_exit>:
    1eda:	08 95       	ret

00001edc <__divmodhi4_neg1>:
    1edc:	f6 f7       	brtc	.-4      	; 0x1eda <__divmodhi4_exit>
    1ede:	90 95       	com	r25
    1ee0:	81 95       	neg	r24
    1ee2:	9f 4f       	sbci	r25, 0xFF	; 255
    1ee4:	08 95       	ret

00001ee6 <__udivmodhi4>:
    1ee6:	aa 1b       	sub	r26, r26
    1ee8:	bb 1b       	sub	r27, r27
    1eea:	51 e1       	ldi	r21, 0x11	; 17
    1eec:	07 c0       	rjmp	.+14     	; 0x1efc <__udivmodhi4_ep>

00001eee <__udivmodhi4_loop>:
    1eee:	aa 1f       	adc	r26, r26
    1ef0:	bb 1f       	adc	r27, r27
    1ef2:	a6 17       	cp	r26, r22
    1ef4:	b7 07       	cpc	r27, r23
    1ef6:	10 f0       	brcs	.+4      	; 0x1efc <__udivmodhi4_ep>
    1ef8:	a6 1b       	sub	r26, r22
    1efa:	b7 0b       	sbc	r27, r23

00001efc <__udivmodhi4_ep>:
    1efc:	88 1f       	adc	r24, r24
    1efe:	99 1f       	adc	r25, r25
    1f00:	5a 95       	dec	r21
    1f02:	a9 f7       	brne	.-22     	; 0x1eee <__udivmodhi4_loop>
    1f04:	80 95       	com	r24
    1f06:	90 95       	com	r25
    1f08:	bc 01       	movw	r22, r24
    1f0a:	cd 01       	movw	r24, r26
    1f0c:	08 95       	ret

00001f0e <_exit>:
    1f0e:	f8 94       	cli

00001f10 <__stop_program>:
    1f10:	ff cf       	rjmp	.-2      	; 0x1f10 <__stop_program>
