/*
 * spark_color_sure_this_will_work.c
 *
 * Created: 29-01-2018 17:01:32
 *  Author: Swathi S
 */ 


#define F_CPU 7372800
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <math.h> //included to support power function


volatile unsigned long int pulse = 0; //to keep the track of the number of pulses generated by the color sensor
volatile unsigned long int red;       // variable to store the pulse count when read_red function is called
volatile unsigned long int blue;      // variable to store the pulse count when read_blue function is called
volatile unsigned long int green;     // variable to store the pulse count when read_green function is called

/*s0=PD4 PC0
S1=PD5 pc1
S2=PD3 pc2
S3=PD2 pc3(buzzer) pc7
OUT PD6
gnd 1
vcc 2 from left
red_led PC4
Green_led pc5
Blue_led pc6
*/

void color_sensor_pin_config(void)
{
	DDRD  = DDRD & 0xBF;  //Set the direction of the PORTD 6 pin as input 1011 1111
	PORTD = PORTD | 0x40; //pullup pd6 0100 0000
}
void port_init_color(void)
{
	
	color_sensor_pin_config();//color sensor pin configuration
}

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
	//EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
	TCCR1A=0;
	TCCR1B=0x81;//falling edge,noise cancel, no prescale
	TIMSK=(1<<TICIE1);//ip capt and  NO overflow interrupt
	//EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
	sei(); // Enables the global interrupt
}
ISR(TIMER1_CAPT_vect)
{
	pulse++; //increment on receiving pulse from the color sensor
}
void init_devices_color(void)
{
	cli(); //Clears the global interrupt
	port_init_color();  //Initializes all the ports
	color_sensor_pin_interrupt_init();
	sei();   // Enables the global interrupt
}
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	/*PORTC= PORTC & 0xFE; //set S2 low
	PORTC = PORTC & 0xF7; //set S37F lowpd2*/
	PORTC= PORTC & 0xFB; //set S2 low 1111 1011
	PORTC = PORTC & 0x7F; //set S37F lowpd2 0111 1111
}

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	
	PORTC = PORTC | 0x04; //set S2 High 0000 0100
	PORTC = PORTC | 0x80; //set S3 High 1000 0000
}

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	/*PORTD = PORTD & 0xF7; //set S2 low
	PORTD = PORTD | 0x04; //set S3 High*/
	PORTC= PORTC & 0xFB; //set S2 low 1111 1011
	PORTC = PORTC | 0x80; //set S3 High 1000 0000
}

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	/*PORTD = PORTD | 0x08; //set S2 High
	PORTD = PORTD & 0xFB; //set S3 Low*/
	PORTC = PORTC | 0x04;  //set S2 High 0000 0100
	PORTC = PORTC & 0x7F; //set S3 Low 0111 1111
}

//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xFE;
	PORTC = PORTC | 0x01; //set S0 high 0000 0001
	PORTC = PORTC & 0xFD; //set S1 low 1111 1101
	//PORTD = PORTD | 0x02; //set S1 high 
}

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
	/*lcd_wr_command(0x80);
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
	lcd_string("Red Pulses"); // Display "Red Pulses" on LCD
	lcd_print(2,1,red,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD
	*/
}

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
	/*lcd_wr_command(0x80);
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
	lcd_string("Green Pulses"); // Display "Green Pulses" on LCD
	lcd_print(2,1,green,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD

*/}

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
	/*lcd_wr_command(0x80);
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
	lcd_string("Blue Pulses"); // Display "Blue Pulses" on LCD
	lcd_print(2,1,blue,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	//lcd_wr_command(0x01); //Clear the LCD
	*/
}
void colour(unsigned long int red_pulse, unsigned long int green_pulse,unsigned long int blue_pulse)
{	
	if(red_pulse>green_pulse && red_pulse>blue_pulse)
	{
		//red greatest
		PORTC=PORTC|(1<<PC4);
		PORTC=PORTC & 0x9F; //clear pc5 and pc6 1001 1111
		task=1;
	}
	else if(green_pulse>blue_pulse)
	{
		//green greatest
		PORTC=PORTC|(1<<PC5);
		PORTC=PORTC & 0xAF; //clear pc4 and pc6 1010 1111
		task=2;
		
	}
	else
	{
		//blue greatest
		PORTC=PORTC|(1<<PC6);
		PORTC=PORTC & 0xCF; //clear pc5 and pc4 1100 1111
		task=3;
	}
}


void color_sensor_work()
{	
	
	init_devices_color();
	DDRC = DDRC | 0xFF;//port c pins as output 
	PORTC=0x00;
	color_sensor_scaling();
	if(stage==2)
	{
		for (int i=0;i<5;i++)
		{
			red_read(); //display the pulse count when red filter is selected
			//_delay_ms(500);
			green_read(); //display the pulse count when green filter is selected
			//_delay_ms(500);
			blue_read(); //display the pulse count when blue filter is selected
			//_delay_ms(500);
			colour(red,green,blue);
			_delay_ms(500);
			
		}
		
	}
	else
	{	//red greatest
		PORTC=PORTC|(1<<PC4);
		PORTC=PORTC & 0x9F; //clear pc5 and pc6 1001 1111
		task=1;
		_delay_ms(500);
	}	
	//PORTC=PORTC& 0x8F;//1000 1111
}