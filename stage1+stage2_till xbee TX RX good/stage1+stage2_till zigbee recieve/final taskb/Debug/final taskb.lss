
final taskb.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800200  00002784  00002818  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002784  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000fc  0080020e  0080020e  00002826  2**0
                  ALLOC
  3 .stab         000033fc  00000000  00000000  00002828  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009aa  00000000  00000000  00005c24  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  000065d0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002ad2  00000000  00000000  00006690  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000401  00000000  00000000  00009162  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d21  00000000  00000000  00009563  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000008bc  00000000  00000000  0000a284  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000008fa  00000000  00000000  0000ab40  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001e1f  00000000  00000000  0000b43a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001a0  00000000  00000000  0000d259  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 6f 0a 	jmp	0x14de	; 0x14de <__vector_1>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 ed 03 	jmp	0x7da	; 0x7da <__vector_5>
      18:	0c 94 c8 03 	jmp	0x790	; 0x790 <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 1e 0c 	jmp	0x183c	; 0x183c <__vector_25>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	lds	r29, 0x78
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	sts	0xb8, r17
      f2:	ba ab       	sts	0x5a, r27
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	sts	0x9b, r26
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	sts	0x5e, r27
     126:	aa aa       	sts	0x9a, r26
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	sts	0x41, r30
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <linear_distance_mm+0x4c>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e4 e8       	ldi	r30, 0x84	; 132
     17e:	f7 e2       	ldi	r31, 0x27	; 39
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	ae 30       	cpi	r26, 0x0E	; 14
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	13 e0       	ldi	r17, 0x03	; 3
     192:	ae e0       	ldi	r26, 0x0E	; 14
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	aa 30       	cpi	r26, 0x0A	; 10
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <main>
     1a4:	0c 94 c0 13 	jmp	0x2780	; 0x2780 <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <do_task>:
	}
}

void do_task()
{	
	if(task==1)
     1ac:	80 91 1e 02 	lds	r24, 0x021E
     1b0:	81 30       	cpi	r24, 0x01	; 1
     1b2:	01 f5       	brne	.+64     	; 0x1f4 <do_task+0x48>
	{	
		red_nodes[r]=path1.path[t];
     1b4:	90 91 06 02 	lds	r25, 0x0206
     1b8:	e0 91 0e 02 	lds	r30, 0x020E
     1bc:	f0 91 0f 02 	lds	r31, 0x020F
     1c0:	ee 0f       	add	r30, r30
     1c2:	ff 1f       	adc	r31, r31
     1c4:	e5 58       	subi	r30, 0x85	; 133
     1c6:	fd 4f       	sbci	r31, 0xFD	; 253
     1c8:	80 81       	ld	r24, Z
     1ca:	e3 ee       	ldi	r30, 0xE3	; 227
     1cc:	f2 e0       	ldi	r31, 0x02	; 2
     1ce:	e9 0f       	add	r30, r25
     1d0:	f1 1d       	adc	r31, r1
     1d2:	80 83       	st	Z, r24
		red_side[rs]=side;
     1d4:	80 91 04 02 	lds	r24, 0x0204
     1d8:	20 91 1d 02 	lds	r18, 0x021D
     1dc:	e4 ef       	ldi	r30, 0xF4	; 244
     1de:	f2 e0       	ldi	r31, 0x02	; 2
     1e0:	e8 0f       	add	r30, r24
     1e2:	f1 1d       	adc	r31, r1
     1e4:	20 83       	st	Z, r18
		r++;
     1e6:	9f 5f       	subi	r25, 0xFF	; 255
     1e8:	90 93 06 02 	sts	0x0206, r25
		rs++;
     1ec:	8f 5f       	subi	r24, 0xFF	; 255
     1ee:	80 93 04 02 	sts	0x0204, r24
     1f2:	21 c0       	rjmp	.+66     	; 0x236 <do_task+0x8a>
		
	}
	else if(task==3)
     1f4:	83 30       	cpi	r24, 0x03	; 3
     1f6:	f9 f4       	brne	.+62     	; 0x236 <do_task+0x8a>
	{
		blue_nodes[b]=path1.path[t];
     1f8:	90 91 05 02 	lds	r25, 0x0205
     1fc:	e0 91 0e 02 	lds	r30, 0x020E
     200:	f0 91 0f 02 	lds	r31, 0x020F
     204:	ee 0f       	add	r30, r30
     206:	ff 1f       	adc	r31, r31
     208:	e5 58       	subi	r30, 0x85	; 133
     20a:	fd 4f       	sbci	r31, 0xFD	; 253
     20c:	80 81       	ld	r24, Z
     20e:	e7 e3       	ldi	r30, 0x37	; 55
     210:	f2 e0       	ldi	r31, 0x02	; 2
     212:	e9 0f       	add	r30, r25
     214:	f1 1d       	adc	r31, r1
     216:	80 83       	st	Z, r24
		blue_side[bs]=side;
     218:	80 91 03 02 	lds	r24, 0x0203
     21c:	20 91 1d 02 	lds	r18, 0x021D
     220:	ec e5       	ldi	r30, 0x5C	; 92
     222:	f2 e0       	ldi	r31, 0x02	; 2
     224:	e8 0f       	add	r30, r24
     226:	f1 1d       	adc	r31, r1
     228:	20 83       	st	Z, r18
		b++;
     22a:	9f 5f       	subi	r25, 0xFF	; 255
     22c:	90 93 05 02 	sts	0x0205, r25
		bs++;
     230:	8f 5f       	subi	r24, 0xFF	; 255
     232:	80 93 03 02 	sts	0x0203, r24
	}
	if(red_side[0]==1 && red_side[1]==1)
	{
		buzzer_beep();
	}*/
	task=0;
     236:	10 92 1e 02 	sts	0x021E, r1
	side=0;
     23a:	10 92 1d 02 	sts	0x021D, r1
	//buzzer_beep();
}
     23e:	08 95       	ret

00000240 <buzzer_pin_config>:
Logic: Setting PORTC3 as output which is the pin connected to the buzzer
Example Call: buzzer_pin_config()
*/
void buzzer_pin_config(void)
{
	DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     240:	3b 9a       	sbi	0x07, 3	; 7
	PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     242:	43 98       	cbi	0x08, 3	; 8
}
     244:	08 95       	ret

00000246 <buzzer_on>:
Example Call: buzzer_on ()
*/
void buzzer_on(void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
     246:	86 b1       	in	r24, 0x06	; 6
	port_restore = port_restore | 0x08;
     248:	88 60       	ori	r24, 0x08	; 8
	PORTC = port_restore;
     24a:	88 b9       	out	0x08, r24	; 8
}
     24c:	08 95       	ret

0000024e <buzzer_off>:
Example Call: buzzer_off()
*/
void buzzer_off(void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
     24e:	86 b1       	in	r24, 0x06	; 6
	port_restore = port_restore & 0xF7;
     250:	87 7f       	andi	r24, 0xF7	; 247
	PORTC = port_restore;
     252:	88 b9       	out	0x08, r24	; 8
}
     254:	08 95       	ret

00000256 <buzzer_beep>:
Logic: Turns the buzzer on and off by writing 1 & 0 to PC3
Example Call: buzzer_beep()
*/
void buzzer_beep()
{
	buzzer_on();
     256:	0e 94 23 01 	call	0x246	; 0x246 <buzzer_on>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     25a:	8f ef       	ldi	r24, 0xFF	; 255
     25c:	9f ef       	ldi	r25, 0xFF	; 255
     25e:	a8 e0       	ldi	r26, 0x08	; 8
     260:	81 50       	subi	r24, 0x01	; 1
     262:	90 40       	sbci	r25, 0x00	; 0
     264:	a0 40       	sbci	r26, 0x00	; 0
     266:	e1 f7       	brne	.-8      	; 0x260 <buzzer_beep+0xa>
     268:	00 c0       	rjmp	.+0      	; 0x26a <buzzer_beep+0x14>
     26a:	00 00       	nop
	_delay_ms(200);
	buzzer_off();
     26c:	0e 94 27 01 	call	0x24e	; 0x24e <buzzer_off>
     270:	8f ef       	ldi	r24, 0xFF	; 255
     272:	9f ef       	ldi	r25, 0xFF	; 255
     274:	a8 e0       	ldi	r26, 0x08	; 8
     276:	81 50       	subi	r24, 0x01	; 1
     278:	90 40       	sbci	r25, 0x00	; 0
     27a:	a0 40       	sbci	r26, 0x00	; 0
     27c:	e1 f7       	brne	.-8      	; 0x276 <buzzer_beep+0x20>
     27e:	00 c0       	rjmp	.+0      	; 0x280 <buzzer_beep+0x2a>
     280:	00 00       	nop
	_delay_ms(200);
}
     282:	08 95       	ret

00000284 <main_function7>:
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
{
     284:	af 92       	push	r10
     286:	bf 92       	push	r11
     288:	cf 92       	push	r12
     28a:	df 92       	push	r13
     28c:	ef 92       	push	r14
     28e:	ff 92       	push	r15
     290:	0f 93       	push	r16
     292:	1f 93       	push	r17
     294:	cf 93       	push	r28
     296:	df 93       	push	r29
     298:	cd b7       	in	r28, 0x3d	; 61
     29a:	de b7       	in	r29, 0x3e	; 62
     29c:	e2 97       	sbiw	r28, 0x32	; 50
     29e:	0f b6       	in	r0, 0x3f	; 63
     2a0:	f8 94       	cli
     2a2:	de bf       	out	0x3e, r29	; 62
     2a4:	0f be       	out	0x3f, r0	; 63
     2a6:	cd bf       	out	0x3d, r28	; 61
     2a8:	c8 2e       	mov	r12, r24
     2aa:	b9 2e       	mov	r11, r25
     2ac:	26 2f       	mov	r18, r22
	struct Path_Array path;
unsigned char friend; 
signed char k =(((start-1)/7)-((finish-1)/7));
     2ae:	e4 2e       	mov	r14, r20
     2b0:	ff 24       	eor	r15, r15
     2b2:	86 2f       	mov	r24, r22
     2b4:	90 e0       	ldi	r25, 0x00	; 0
     2b6:	01 97       	sbiw	r24, 0x01	; 1
     2b8:	e7 e0       	ldi	r30, 0x07	; 7
     2ba:	f0 e0       	ldi	r31, 0x00	; 0
     2bc:	bf 01       	movw	r22, r30
     2be:	0e 94 ad 13 	call	0x275a	; 0x275a <__divmodhi4>
     2c2:	36 2f       	mov	r19, r22
     2c4:	c7 01       	movw	r24, r14
     2c6:	01 97       	sbiw	r24, 0x01	; 1
     2c8:	bf 01       	movw	r22, r30
     2ca:	0e 94 ad 13 	call	0x275a	; 0x275a <__divmodhi4>
     2ce:	83 2f       	mov	r24, r19
     2d0:	86 1b       	sub	r24, r22
     2d2:	38 2f       	mov	r19, r24
if(k>0)
     2d4:	18 16       	cp	r1, r24
     2d6:	3c f4       	brge	.+14     	; 0x2e6 <main_function7+0x62>
{
	friend=((k*7)+finish);
     2d8:	d8 2e       	mov	r13, r24
     2da:	dd 0c       	add	r13, r13
     2dc:	dd 0c       	add	r13, r13
     2de:	dd 0c       	add	r13, r13
     2e0:	d8 1a       	sub	r13, r24
     2e2:	d4 0e       	add	r13, r20
     2e4:	06 c0       	rjmp	.+12     	; 0x2f2 <main_function7+0x6e>
}
else
{
	friend=(finish-(k*(-1))*7);
     2e6:	d8 2e       	mov	r13, r24
     2e8:	dd 0c       	add	r13, r13
     2ea:	dd 0c       	add	r13, r13
     2ec:	dd 0c       	add	r13, r13
     2ee:	d8 1a       	sub	r13, r24
     2f0:	d4 0e       	add	r13, r20
}
signed char l=0;
unsigned char m=0;
 unsigned char st =start;
l=(friend - start);
     2f2:	ed 2d       	mov	r30, r13
     2f4:	e2 1b       	sub	r30, r18
     2f6:	ae 2e       	mov	r10, r30

if(l>0)
     2f8:	1e 16       	cp	r1, r30
     2fa:	0c f0       	brlt	.+2      	; 0x2fe <main_function7+0x7a>
     2fc:	eb c0       	rjmp	.+470    	; 0x4d4 <main_function7+0x250>
{
	for(unsigned char i = 0;i<=l;i++)
     2fe:	ff 27       	eor	r31, r31
     300:	e7 fd       	sbrc	r30, 7
     302:	f0 95       	com	r31
     304:	ff 23       	and	r31, r31
     306:	c4 f0       	brlt	.+48     	; 0x338 <main_function7+0xb4>
     308:	80 e0       	ldi	r24, 0x00	; 0
     30a:	90 e0       	ldi	r25, 0x00	; 0
     30c:	50 e0       	ldi	r21, 0x00	; 0
	{path.path[i]=st;
     30e:	dc 01       	movw	r26, r24
     310:	aa 0f       	add	r26, r26
     312:	bb 1f       	adc	r27, r27
     314:	81 e0       	ldi	r24, 0x01	; 1
     316:	90 e0       	ldi	r25, 0x00	; 0
     318:	8c 0f       	add	r24, r28
     31a:	9d 1f       	adc	r25, r29
     31c:	a8 0f       	add	r26, r24
     31e:	b9 1f       	adc	r27, r25
     320:	85 2f       	mov	r24, r21
     322:	82 0f       	add	r24, r18
     324:	8c 93       	st	X, r24
     326:	11 96       	adiw	r26, 0x01	; 1
     328:	1c 92       	st	X, r1
     32a:	11 97       	sbiw	r26, 0x01	; 1
 unsigned char st =start;
l=(friend - start);

if(l>0)
{
	for(unsigned char i = 0;i<=l;i++)
     32c:	5f 5f       	subi	r21, 0xFF	; 255
     32e:	85 2f       	mov	r24, r21
     330:	90 e0       	ldi	r25, 0x00	; 0
     332:	e8 17       	cp	r30, r24
     334:	f9 07       	cpc	r31, r25
     336:	5c f7       	brge	.-42     	; 0x30e <main_function7+0x8a>
	{path.path[i]=st;
	st++;
	}
	if(k>0)	
     338:	13 16       	cp	r1, r19
     33a:	0c f0       	brlt	.+2      	; 0x33e <main_function7+0xba>
     33c:	64 c0       	rjmp	.+200    	; 0x406 <main_function7+0x182>
	{   
		if(friend > finish)
     33e:	4d 15       	cp	r20, r13
     340:	90 f5       	brcc	.+100    	; 0x3a6 <main_function7+0x122>
		{
			m=((friend-finish)/7);
     342:	2d 2d       	mov	r18, r13
     344:	30 e0       	ldi	r19, 0x00	; 0
     346:	c9 01       	movw	r24, r18
     348:	8e 19       	sub	r24, r14
     34a:	9f 09       	sbc	r25, r15
     34c:	67 e0       	ldi	r22, 0x07	; 7
     34e:	70 e0       	ldi	r23, 0x00	; 0
     350:	0e 94 ad 13 	call	0x275a	; 0x275a <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     354:	66 23       	and	r22, r22
     356:	09 f4       	brne	.+2      	; 0x35a <main_function7+0xd6>
     358:	b2 c1       	rjmp	.+868    	; 0x6be <main_function7+0x43a>
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     35a:	a9 01       	movw	r20, r18
     35c:	47 50       	subi	r20, 0x07	; 7
     35e:	50 40       	sbci	r21, 0x00	; 0
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     360:	31 96       	adiw	r30, 0x01	; 1
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     362:	ee 0f       	add	r30, r30
     364:	ff 1f       	adc	r31, r31
     366:	81 e0       	ldi	r24, 0x01	; 1
     368:	90 e0       	ldi	r25, 0x00	; 0
     36a:	8c 0f       	add	r24, r28
     36c:	9d 1f       	adc	r25, r29
     36e:	e8 0f       	add	r30, r24
     370:	f9 1f       	adc	r31, r25
     372:	c9 01       	movw	r24, r18
     374:	dc 01       	movw	r26, r24
     376:	1e 97       	sbiw	r26, 0x0e	; 14
     378:	86 2f       	mov	r24, r22
     37a:	81 50       	subi	r24, 0x01	; 1
     37c:	90 e0       	ldi	r25, 0x00	; 0
     37e:	9c 01       	movw	r18, r24
     380:	22 0f       	add	r18, r18
     382:	33 1f       	adc	r19, r19
     384:	22 0f       	add	r18, r18
     386:	33 1f       	adc	r19, r19
     388:	22 0f       	add	r18, r18
     38a:	33 1f       	adc	r19, r19
     38c:	28 1b       	sub	r18, r24
     38e:	39 0b       	sbc	r19, r25
     390:	cd 01       	movw	r24, r26
     392:	82 1b       	sub	r24, r18
     394:	93 0b       	sbc	r25, r19
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     396:	41 93       	st	Z+, r20
     398:	51 93       	st	Z+, r21
     39a:	47 50       	subi	r20, 0x07	; 7
     39c:	50 40       	sbci	r21, 0x00	; 0
	if(k>0)	
	{   
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     39e:	48 17       	cp	r20, r24
     3a0:	59 07       	cpc	r21, r25
     3a2:	c9 f7       	brne	.-14     	; 0x396 <main_function7+0x112>
     3a4:	8c c1       	rjmp	.+792    	; 0x6be <main_function7+0x43a>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     3a6:	2d 2d       	mov	r18, r13
     3a8:	30 e0       	ldi	r19, 0x00	; 0
     3aa:	c7 01       	movw	r24, r14
     3ac:	82 1b       	sub	r24, r18
     3ae:	93 0b       	sbc	r25, r19
     3b0:	67 e0       	ldi	r22, 0x07	; 7
     3b2:	70 e0       	ldi	r23, 0x00	; 0
     3b4:	0e 94 ad 13 	call	0x275a	; 0x275a <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     3b8:	66 23       	and	r22, r22
     3ba:	09 f4       	brne	.+2      	; 0x3be <main_function7+0x13a>
     3bc:	80 c1       	rjmp	.+768    	; 0x6be <main_function7+0x43a>
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     3be:	a9 01       	movw	r20, r18
     3c0:	49 5f       	subi	r20, 0xF9	; 249
     3c2:	5f 4f       	sbci	r21, 0xFF	; 255
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     3c4:	31 96       	adiw	r30, 0x01	; 1
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     3c6:	ee 0f       	add	r30, r30
     3c8:	ff 1f       	adc	r31, r31
     3ca:	81 e0       	ldi	r24, 0x01	; 1
     3cc:	90 e0       	ldi	r25, 0x00	; 0
     3ce:	8c 0f       	add	r24, r28
     3d0:	9d 1f       	adc	r25, r29
     3d2:	e8 0f       	add	r30, r24
     3d4:	f9 1f       	adc	r31, r25
     3d6:	d9 01       	movw	r26, r18
     3d8:	1e 96       	adiw	r26, 0x0e	; 14
     3da:	86 2f       	mov	r24, r22
     3dc:	81 50       	subi	r24, 0x01	; 1
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	9c 01       	movw	r18, r24
     3e2:	22 0f       	add	r18, r18
     3e4:	33 1f       	adc	r19, r19
     3e6:	22 0f       	add	r18, r18
     3e8:	33 1f       	adc	r19, r19
     3ea:	22 0f       	add	r18, r18
     3ec:	33 1f       	adc	r19, r19
     3ee:	28 1b       	sub	r18, r24
     3f0:	39 0b       	sbc	r19, r25
     3f2:	2a 0f       	add	r18, r26
     3f4:	3b 1f       	adc	r19, r27
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     3f6:	41 93       	st	Z+, r20
     3f8:	51 93       	st	Z+, r21
     3fa:	49 5f       	subi	r20, 0xF9	; 249
     3fc:	5f 4f       	sbci	r21, 0xFF	; 255
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     3fe:	42 17       	cp	r20, r18
     400:	53 07       	cpc	r21, r19
     402:	c9 f7       	brne	.-14     	; 0x3f6 <main_function7+0x172>
     404:	5c c1       	rjmp	.+696    	; 0x6be <main_function7+0x43a>
				path.path[l+i+1]=friend+((7*i)+7);
			}
		}
		
	}
	else if(k<0)
     406:	33 23       	and	r19, r19
     408:	0c f0       	brlt	.+2      	; 0x40c <main_function7+0x188>
     40a:	56 c1       	rjmp	.+684    	; 0x6b8 <main_function7+0x434>
	{ if(friend > finish)
     40c:	4d 15       	cp	r20, r13
     40e:	90 f5       	brcc	.+100    	; 0x474 <main_function7+0x1f0>
		{	
			m=((friend-finish)/7);
     410:	2d 2d       	mov	r18, r13
     412:	30 e0       	ldi	r19, 0x00	; 0
     414:	c9 01       	movw	r24, r18
     416:	8e 19       	sub	r24, r14
     418:	9f 09       	sbc	r25, r15
     41a:	67 e0       	ldi	r22, 0x07	; 7
     41c:	70 e0       	ldi	r23, 0x00	; 0
     41e:	0e 94 ad 13 	call	0x275a	; 0x275a <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     422:	66 23       	and	r22, r22
     424:	09 f4       	brne	.+2      	; 0x428 <main_function7+0x1a4>
     426:	4b c1       	rjmp	.+662    	; 0x6be <main_function7+0x43a>
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     428:	a9 01       	movw	r20, r18
     42a:	47 50       	subi	r20, 0x07	; 7
     42c:	50 40       	sbci	r21, 0x00	; 0
	{ if(friend > finish)
		{	
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     42e:	31 96       	adiw	r30, 0x01	; 1
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     430:	ee 0f       	add	r30, r30
     432:	ff 1f       	adc	r31, r31
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	8c 0f       	add	r24, r28
     43a:	9d 1f       	adc	r25, r29
     43c:	e8 0f       	add	r30, r24
     43e:	f9 1f       	adc	r31, r25
     440:	c9 01       	movw	r24, r18
     442:	dc 01       	movw	r26, r24
     444:	1e 97       	sbiw	r26, 0x0e	; 14
     446:	86 2f       	mov	r24, r22
     448:	81 50       	subi	r24, 0x01	; 1
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	9c 01       	movw	r18, r24
     44e:	22 0f       	add	r18, r18
     450:	33 1f       	adc	r19, r19
     452:	22 0f       	add	r18, r18
     454:	33 1f       	adc	r19, r19
     456:	22 0f       	add	r18, r18
     458:	33 1f       	adc	r19, r19
     45a:	28 1b       	sub	r18, r24
     45c:	39 0b       	sbc	r19, r25
     45e:	cd 01       	movw	r24, r26
     460:	82 1b       	sub	r24, r18
     462:	93 0b       	sbc	r25, r19
	{ if(friend > finish)
		{	
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     464:	41 93       	st	Z+, r20
     466:	51 93       	st	Z+, r21
     468:	47 50       	subi	r20, 0x07	; 7
     46a:	50 40       	sbci	r21, 0x00	; 0
	}
	else if(k<0)
	{ if(friend > finish)
		{	
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     46c:	48 17       	cp	r20, r24
     46e:	59 07       	cpc	r21, r25
     470:	c9 f7       	brne	.-14     	; 0x464 <main_function7+0x1e0>
     472:	25 c1       	rjmp	.+586    	; 0x6be <main_function7+0x43a>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     474:	2d 2d       	mov	r18, r13
     476:	30 e0       	ldi	r19, 0x00	; 0
     478:	c7 01       	movw	r24, r14
     47a:	82 1b       	sub	r24, r18
     47c:	93 0b       	sbc	r25, r19
     47e:	67 e0       	ldi	r22, 0x07	; 7
     480:	70 e0       	ldi	r23, 0x00	; 0
     482:	0e 94 ad 13 	call	0x275a	; 0x275a <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     486:	66 23       	and	r22, r22
     488:	09 f4       	brne	.+2      	; 0x48c <main_function7+0x208>
     48a:	19 c1       	rjmp	.+562    	; 0x6be <main_function7+0x43a>
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     48c:	a9 01       	movw	r20, r18
     48e:	49 5f       	subi	r20, 0xF9	; 249
     490:	5f 4f       	sbci	r21, 0xFF	; 255
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     492:	31 96       	adiw	r30, 0x01	; 1
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     494:	ee 0f       	add	r30, r30
     496:	ff 1f       	adc	r31, r31
     498:	81 e0       	ldi	r24, 0x01	; 1
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	8c 0f       	add	r24, r28
     49e:	9d 1f       	adc	r25, r29
     4a0:	e8 0f       	add	r30, r24
     4a2:	f9 1f       	adc	r31, r25
     4a4:	d9 01       	movw	r26, r18
     4a6:	1e 96       	adiw	r26, 0x0e	; 14
     4a8:	86 2f       	mov	r24, r22
     4aa:	81 50       	subi	r24, 0x01	; 1
     4ac:	90 e0       	ldi	r25, 0x00	; 0
     4ae:	9c 01       	movw	r18, r24
     4b0:	22 0f       	add	r18, r18
     4b2:	33 1f       	adc	r19, r19
     4b4:	22 0f       	add	r18, r18
     4b6:	33 1f       	adc	r19, r19
     4b8:	22 0f       	add	r18, r18
     4ba:	33 1f       	adc	r19, r19
     4bc:	28 1b       	sub	r18, r24
     4be:	39 0b       	sbc	r19, r25
     4c0:	2a 0f       	add	r18, r26
     4c2:	3b 1f       	adc	r19, r27
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     4c4:	41 93       	st	Z+, r20
     4c6:	51 93       	st	Z+, r21
     4c8:	49 5f       	subi	r20, 0xF9	; 249
     4ca:	5f 4f       	sbci	r21, 0xFF	; 255
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     4cc:	42 17       	cp	r20, r18
     4ce:	53 07       	cpc	r21, r19
     4d0:	c9 f7       	brne	.-14     	; 0x4c4 <main_function7+0x240>
     4d2:	f5 c0       	rjmp	.+490    	; 0x6be <main_function7+0x43a>
		
	}
	
}
else
{ l=(l*(-1));
     4d4:	ae 2e       	mov	r10, r30
     4d6:	a1 94       	neg	r10
	for(unsigned char i = 0;i<=(l);i++)
     4d8:	0a 2d       	mov	r16, r10
     4da:	11 27       	eor	r17, r17
     4dc:	07 fd       	sbrc	r16, 7
     4de:	10 95       	com	r17
     4e0:	11 23       	and	r17, r17
     4e2:	b4 f0       	brlt	.+44     	; 0x510 <main_function7+0x28c>
     4e4:	80 e0       	ldi	r24, 0x00	; 0
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	50 e0       	ldi	r21, 0x00	; 0
	{path.path[i]=st;
     4ea:	fc 01       	movw	r30, r24
     4ec:	ee 0f       	add	r30, r30
     4ee:	ff 1f       	adc	r31, r31
     4f0:	81 e0       	ldi	r24, 0x01	; 1
     4f2:	90 e0       	ldi	r25, 0x00	; 0
     4f4:	8c 0f       	add	r24, r28
     4f6:	9d 1f       	adc	r25, r29
     4f8:	e8 0f       	add	r30, r24
     4fa:	f9 1f       	adc	r31, r25
     4fc:	82 2f       	mov	r24, r18
     4fe:	85 1b       	sub	r24, r21
     500:	80 83       	st	Z, r24
     502:	11 82       	std	Z+1, r1	; 0x01
	}
	
}
else
{ l=(l*(-1));
	for(unsigned char i = 0;i<=(l);i++)
     504:	5f 5f       	subi	r21, 0xFF	; 255
     506:	85 2f       	mov	r24, r21
     508:	90 e0       	ldi	r25, 0x00	; 0
     50a:	08 17       	cp	r16, r24
     50c:	19 07       	cpc	r17, r25
     50e:	6c f7       	brge	.-38     	; 0x4ea <main_function7+0x266>
	{path.path[i]=st;
		st--;
	}
	if(k>0)
     510:	13 16       	cp	r1, r19
     512:	0c f0       	brlt	.+2      	; 0x516 <main_function7+0x292>
     514:	68 c0       	rjmp	.+208    	; 0x5e6 <main_function7+0x362>
	{  
		if(friend > finish)
     516:	4d 15       	cp	r20, r13
     518:	a0 f5       	brcc	.+104    	; 0x582 <main_function7+0x2fe>
		{
			m=((friend-finish)/7);
     51a:	2d 2d       	mov	r18, r13
     51c:	30 e0       	ldi	r19, 0x00	; 0
     51e:	c9 01       	movw	r24, r18
     520:	8e 19       	sub	r24, r14
     522:	9f 09       	sbc	r25, r15
     524:	67 e0       	ldi	r22, 0x07	; 7
     526:	70 e0       	ldi	r23, 0x00	; 0
     528:	0e 94 ad 13 	call	0x275a	; 0x275a <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     52c:	66 23       	and	r22, r22
     52e:	09 f4       	brne	.+2      	; 0x532 <main_function7+0x2ae>
     530:	c6 c0       	rjmp	.+396    	; 0x6be <main_function7+0x43a>
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     532:	a9 01       	movw	r20, r18
     534:	47 50       	subi	r20, 0x07	; 7
     536:	50 40       	sbci	r21, 0x00	; 0
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     538:	0f 5f       	subi	r16, 0xFF	; 255
     53a:	1f 4f       	sbci	r17, 0xFF	; 255
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     53c:	f8 01       	movw	r30, r16
     53e:	ee 0f       	add	r30, r30
     540:	ff 1f       	adc	r31, r31
     542:	81 e0       	ldi	r24, 0x01	; 1
     544:	90 e0       	ldi	r25, 0x00	; 0
     546:	8c 0f       	add	r24, r28
     548:	9d 1f       	adc	r25, r29
     54a:	e8 0f       	add	r30, r24
     54c:	f9 1f       	adc	r31, r25
     54e:	c9 01       	movw	r24, r18
     550:	dc 01       	movw	r26, r24
     552:	1e 97       	sbiw	r26, 0x0e	; 14
     554:	86 2f       	mov	r24, r22
     556:	81 50       	subi	r24, 0x01	; 1
     558:	90 e0       	ldi	r25, 0x00	; 0
     55a:	9c 01       	movw	r18, r24
     55c:	22 0f       	add	r18, r18
     55e:	33 1f       	adc	r19, r19
     560:	22 0f       	add	r18, r18
     562:	33 1f       	adc	r19, r19
     564:	22 0f       	add	r18, r18
     566:	33 1f       	adc	r19, r19
     568:	28 1b       	sub	r18, r24
     56a:	39 0b       	sbc	r19, r25
     56c:	cd 01       	movw	r24, r26
     56e:	82 1b       	sub	r24, r18
     570:	93 0b       	sbc	r25, r19
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     572:	41 93       	st	Z+, r20
     574:	51 93       	st	Z+, r21
     576:	47 50       	subi	r20, 0x07	; 7
     578:	50 40       	sbci	r21, 0x00	; 0
	if(k>0)
	{  
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     57a:	48 17       	cp	r20, r24
     57c:	59 07       	cpc	r21, r25
     57e:	c9 f7       	brne	.-14     	; 0x572 <main_function7+0x2ee>
     580:	9e c0       	rjmp	.+316    	; 0x6be <main_function7+0x43a>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     582:	2d 2d       	mov	r18, r13
     584:	30 e0       	ldi	r19, 0x00	; 0
     586:	c7 01       	movw	r24, r14
     588:	82 1b       	sub	r24, r18
     58a:	93 0b       	sbc	r25, r19
     58c:	67 e0       	ldi	r22, 0x07	; 7
     58e:	70 e0       	ldi	r23, 0x00	; 0
     590:	0e 94 ad 13 	call	0x275a	; 0x275a <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     594:	66 23       	and	r22, r22
     596:	09 f4       	brne	.+2      	; 0x59a <main_function7+0x316>
     598:	92 c0       	rjmp	.+292    	; 0x6be <main_function7+0x43a>
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     59a:	a9 01       	movw	r20, r18
     59c:	49 5f       	subi	r20, 0xF9	; 249
     59e:	5f 4f       	sbci	r21, 0xFF	; 255
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     5a0:	0f 5f       	subi	r16, 0xFF	; 255
     5a2:	1f 4f       	sbci	r17, 0xFF	; 255
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     5a4:	f8 01       	movw	r30, r16
     5a6:	ee 0f       	add	r30, r30
     5a8:	ff 1f       	adc	r31, r31
     5aa:	81 e0       	ldi	r24, 0x01	; 1
     5ac:	90 e0       	ldi	r25, 0x00	; 0
     5ae:	8c 0f       	add	r24, r28
     5b0:	9d 1f       	adc	r25, r29
     5b2:	e8 0f       	add	r30, r24
     5b4:	f9 1f       	adc	r31, r25
     5b6:	d9 01       	movw	r26, r18
     5b8:	1e 96       	adiw	r26, 0x0e	; 14
     5ba:	86 2f       	mov	r24, r22
     5bc:	81 50       	subi	r24, 0x01	; 1
     5be:	90 e0       	ldi	r25, 0x00	; 0
     5c0:	9c 01       	movw	r18, r24
     5c2:	22 0f       	add	r18, r18
     5c4:	33 1f       	adc	r19, r19
     5c6:	22 0f       	add	r18, r18
     5c8:	33 1f       	adc	r19, r19
     5ca:	22 0f       	add	r18, r18
     5cc:	33 1f       	adc	r19, r19
     5ce:	28 1b       	sub	r18, r24
     5d0:	39 0b       	sbc	r19, r25
     5d2:	2a 0f       	add	r18, r26
     5d4:	3b 1f       	adc	r19, r27
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     5d6:	41 93       	st	Z+, r20
     5d8:	51 93       	st	Z+, r21
     5da:	49 5f       	subi	r20, 0xF9	; 249
     5dc:	5f 4f       	sbci	r21, 0xFF	; 255
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     5de:	42 17       	cp	r20, r18
     5e0:	53 07       	cpc	r21, r19
     5e2:	c9 f7       	brne	.-14     	; 0x5d6 <main_function7+0x352>
     5e4:	6c c0       	rjmp	.+216    	; 0x6be <main_function7+0x43a>
			{
				path.path[l+i+1]=friend+((7*i)+7);
			}
		}
	}
	else  if(k<0)
     5e6:	33 23       	and	r19, r19
     5e8:	0c f0       	brlt	.+2      	; 0x5ec <main_function7+0x368>
     5ea:	68 c0       	rjmp	.+208    	; 0x6bc <main_function7+0x438>
	{
		if(friend > finish)
     5ec:	4d 15       	cp	r20, r13
     5ee:	98 f5       	brcc	.+102    	; 0x656 <main_function7+0x3d2>
		{
			m=((friend-finish)/7);
     5f0:	2d 2d       	mov	r18, r13
     5f2:	30 e0       	ldi	r19, 0x00	; 0
     5f4:	c9 01       	movw	r24, r18
     5f6:	8e 19       	sub	r24, r14
     5f8:	9f 09       	sbc	r25, r15
     5fa:	67 e0       	ldi	r22, 0x07	; 7
     5fc:	70 e0       	ldi	r23, 0x00	; 0
     5fe:	0e 94 ad 13 	call	0x275a	; 0x275a <__divmodhi4>
			for(unsigned char i=0;i<m;i++)
     602:	66 23       	and	r22, r22
     604:	09 f4       	brne	.+2      	; 0x608 <main_function7+0x384>
     606:	5b c0       	rjmp	.+182    	; 0x6be <main_function7+0x43a>
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     608:	a9 01       	movw	r20, r18
     60a:	47 50       	subi	r20, 0x07	; 7
     60c:	50 40       	sbci	r21, 0x00	; 0
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     60e:	c8 01       	movw	r24, r16
     610:	01 96       	adiw	r24, 0x01	; 1
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     612:	88 0f       	add	r24, r24
     614:	99 1f       	adc	r25, r25
     616:	e1 e0       	ldi	r30, 0x01	; 1
     618:	f0 e0       	ldi	r31, 0x00	; 0
     61a:	ec 0f       	add	r30, r28
     61c:	fd 1f       	adc	r31, r29
     61e:	e8 0f       	add	r30, r24
     620:	f9 1f       	adc	r31, r25
     622:	c9 01       	movw	r24, r18
     624:	dc 01       	movw	r26, r24
     626:	1e 97       	sbiw	r26, 0x0e	; 14
     628:	86 2f       	mov	r24, r22
     62a:	81 50       	subi	r24, 0x01	; 1
     62c:	90 e0       	ldi	r25, 0x00	; 0
     62e:	9c 01       	movw	r18, r24
     630:	22 0f       	add	r18, r18
     632:	33 1f       	adc	r19, r19
     634:	22 0f       	add	r18, r18
     636:	33 1f       	adc	r19, r19
     638:	22 0f       	add	r18, r18
     63a:	33 1f       	adc	r19, r19
     63c:	28 1b       	sub	r18, r24
     63e:	39 0b       	sbc	r19, r25
     640:	cd 01       	movw	r24, r26
     642:	82 1b       	sub	r24, r18
     644:	93 0b       	sbc	r25, r19
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
			{
				path.path[l+i+1]=friend-((7*i)+7);
     646:	41 93       	st	Z+, r20
     648:	51 93       	st	Z+, r21
     64a:	47 50       	subi	r20, 0x07	; 7
     64c:	50 40       	sbci	r21, 0x00	; 0
	else  if(k<0)
	{
		if(friend > finish)
		{
			m=((friend-finish)/7);
			for(unsigned char i=0;i<m;i++)
     64e:	48 17       	cp	r20, r24
     650:	59 07       	cpc	r21, r25
     652:	c9 f7       	brne	.-14     	; 0x646 <main_function7+0x3c2>
     654:	34 c0       	rjmp	.+104    	; 0x6be <main_function7+0x43a>
		}
		
		else
		
		{
			m=((finish-friend)/7);
     656:	2d 2d       	mov	r18, r13
     658:	30 e0       	ldi	r19, 0x00	; 0
     65a:	c7 01       	movw	r24, r14
     65c:	82 1b       	sub	r24, r18
     65e:	93 0b       	sbc	r25, r19
     660:	67 e0       	ldi	r22, 0x07	; 7
     662:	70 e0       	ldi	r23, 0x00	; 0
     664:	0e 94 ad 13 	call	0x275a	; 0x275a <__divmodhi4>
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     668:	66 23       	and	r22, r22
     66a:	49 f1       	breq	.+82     	; 0x6be <main_function7+0x43a>
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     66c:	a9 01       	movw	r20, r18
     66e:	49 5f       	subi	r20, 0xF9	; 249
     670:	5f 4f       	sbci	r21, 0xFF	; 255
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     672:	c8 01       	movw	r24, r16
     674:	01 96       	adiw	r24, 0x01	; 1
	int path[X];
};
struct Path_Array path1;


struct Path_Array main_function7(unsigned char start, unsigned char finish)
     676:	88 0f       	add	r24, r24
     678:	99 1f       	adc	r25, r25
     67a:	e1 e0       	ldi	r30, 0x01	; 1
     67c:	f0 e0       	ldi	r31, 0x00	; 0
     67e:	ec 0f       	add	r30, r28
     680:	fd 1f       	adc	r31, r29
     682:	e8 0f       	add	r30, r24
     684:	f9 1f       	adc	r31, r25
     686:	c9 01       	movw	r24, r18
     688:	dc 01       	movw	r26, r24
     68a:	1e 96       	adiw	r26, 0x0e	; 14
     68c:	86 2f       	mov	r24, r22
     68e:	81 50       	subi	r24, 0x01	; 1
     690:	90 e0       	ldi	r25, 0x00	; 0
     692:	9c 01       	movw	r18, r24
     694:	22 0f       	add	r18, r18
     696:	33 1f       	adc	r19, r19
     698:	22 0f       	add	r18, r18
     69a:	33 1f       	adc	r19, r19
     69c:	22 0f       	add	r18, r18
     69e:	33 1f       	adc	r19, r19
     6a0:	28 1b       	sub	r18, r24
     6a2:	39 0b       	sbc	r19, r25
     6a4:	2a 0f       	add	r18, r26
     6a6:	3b 1f       	adc	r19, r27
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
			{
				path.path[l+i+1]=friend+((7*i)+7);
     6a8:	41 93       	st	Z+, r20
     6aa:	51 93       	st	Z+, r21
     6ac:	49 5f       	subi	r20, 0xF9	; 249
     6ae:	5f 4f       	sbci	r21, 0xFF	; 255
		else
		
		{
			m=((finish-friend)/7);
			//m =((friend-1)/7);
			for(unsigned char i=0;i<(m) ;i++)
     6b0:	42 17       	cp	r20, r18
     6b2:	53 07       	cpc	r21, r19
     6b4:	c9 f7       	brne	.-14     	; 0x6a8 <main_function7+0x424>
     6b6:	03 c0       	rjmp	.+6      	; 0x6be <main_function7+0x43a>
else
{
	friend=(finish-(k*(-1))*7);
}
signed char l=0;
unsigned char m=0;
     6b8:	60 e0       	ldi	r22, 0x00	; 0
     6ba:	01 c0       	rjmp	.+2      	; 0x6be <main_function7+0x43a>
     6bc:	60 e0       	ldi	r22, 0x00	; 0
		}
		
	}
	
}
 max = l+m;
     6be:	8a 2d       	mov	r24, r10
     6c0:	99 27       	eor	r25, r25
     6c2:	87 fd       	sbrc	r24, 7
     6c4:	90 95       	com	r25
     6c6:	86 0f       	add	r24, r22
     6c8:	91 1d       	adc	r25, r1
     6ca:	90 93 28 02 	sts	0x0228, r25
     6ce:	80 93 27 02 	sts	0x0227, r24
 for(unsigned char i=(l+m+1);i<15;i++)
     6d2:	6f 5f       	subi	r22, 0xFF	; 255
     6d4:	6a 0d       	add	r22, r10
     6d6:	6f 30       	cpi	r22, 0x0F	; 15
     6d8:	78 f4       	brcc	.+30     	; 0x6f8 <main_function7+0x474>
 {
	 path.path[i]=0;
     6da:	e6 2f       	mov	r30, r22
     6dc:	f0 e0       	ldi	r31, 0x00	; 0
     6de:	ee 0f       	add	r30, r30
     6e0:	ff 1f       	adc	r31, r31
     6e2:	81 e0       	ldi	r24, 0x01	; 1
     6e4:	90 e0       	ldi	r25, 0x00	; 0
     6e6:	8c 0f       	add	r24, r28
     6e8:	9d 1f       	adc	r25, r29
     6ea:	e8 0f       	add	r30, r24
     6ec:	f9 1f       	adc	r31, r25
     6ee:	11 82       	std	Z+1, r1	; 0x01
     6f0:	10 82       	st	Z, r1
		
	}
	
}
 max = l+m;
 for(unsigned char i=(l+m+1);i<15;i++)
     6f2:	6f 5f       	subi	r22, 0xFF	; 255
     6f4:	6f 30       	cpi	r22, 0x0F	; 15
     6f6:	89 f7       	brne	.-30     	; 0x6da <main_function7+0x456>
	/*struct Graph adjacency_matrix = buildGraph(maze);
	

	struct Path_Array path = findPath(adjacency_matrix, start, finish);*/

	return path;
     6f8:	ec 2d       	mov	r30, r12
     6fa:	fb 2d       	mov	r31, r11
     6fc:	de 01       	movw	r26, r28
     6fe:	11 96       	adiw	r26, 0x01	; 1
     700:	82 e3       	ldi	r24, 0x32	; 50
     702:	0d 90       	ld	r0, X+
     704:	01 92       	st	Z+, r0
     706:	81 50       	subi	r24, 0x01	; 1
     708:	e1 f7       	brne	.-8      	; 0x702 <main_function7+0x47e>
     70a:	8c 2d       	mov	r24, r12
     70c:	9b 2d       	mov	r25, r11
     70e:	e2 96       	adiw	r28, 0x32	; 50
     710:	0f b6       	in	r0, 0x3f	; 63
     712:	f8 94       	cli
     714:	de bf       	out	0x3e, r29	; 62
     716:	0f be       	out	0x3f, r0	; 63
     718:	cd bf       	out	0x3d, r28	; 61
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	1f 91       	pop	r17
     720:	0f 91       	pop	r16
     722:	ff 90       	pop	r15
     724:	ef 90       	pop	r14
     726:	df 90       	pop	r13
     728:	cf 90       	pop	r12
     72a:	bf 90       	pop	r11
     72c:	af 90       	pop	r10
     72e:	08 95       	ret

00000730 <motion_pin_config1>:
unsigned int Degrees; //to accept angle in degrees for turning

//Function to configure ports to enable robot's motion
void motion_pin_config1 (void)
{
	DDRA = DDRA | 0x0F;
     730:	81 b1       	in	r24, 0x01	; 1
     732:	8f 60       	ori	r24, 0x0F	; 15
     734:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA & 0xF0;
     736:	82 b1       	in	r24, 0x02	; 2
     738:	80 7f       	andi	r24, 0xF0	; 240
     73a:	82 b9       	out	0x02, r24	; 2
	DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
     73c:	ea e0       	ldi	r30, 0x0A	; 10
     73e:	f1 e0       	ldi	r31, 0x01	; 1
     740:	80 81       	ld	r24, Z
     742:	88 61       	ori	r24, 0x18	; 24
     744:	80 83       	st	Z, r24
	PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
     746:	eb e0       	ldi	r30, 0x0B	; 11
     748:	f1 e0       	ldi	r31, 0x01	; 1
     74a:	80 81       	ld	r24, Z
     74c:	88 61       	ori	r24, 0x18	; 24
     74e:	80 83       	st	Z, r24
}
     750:	08 95       	ret

00000752 <left_encoder_pin_config>:

//Function to configure INT4 (PORTE 4) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     752:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     754:	74 9a       	sbi	0x0e, 4	; 14
}
     756:	08 95       	ret

00000758 <right_encoder_pin_config>:

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
     758:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     75a:	75 9a       	sbi	0x0e, 5	; 14
}
     75c:	08 95       	ret

0000075e <port_init1>:

//Function to initialize ports
void port_init1()
{
	motion_pin_config1(); //robot motion pins config
     75e:	0e 94 98 03 	call	0x730	; 0x730 <motion_pin_config1>
	left_encoder_pin_config(); //left encoder pin config
     762:	0e 94 a9 03 	call	0x752	; 0x752 <left_encoder_pin_config>
	right_encoder_pin_config(); //right encoder pin config
     766:	0e 94 ac 03 	call	0x758	; 0x758 <right_encoder_pin_config>
}
     76a:	08 95       	ret

0000076c <left_position_encoder_interrupt_init>:

void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli(); //Clears the global interrupt
     76c:	f8 94       	cli
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     76e:	ea e6       	ldi	r30, 0x6A	; 106
     770:	f0 e0       	ldi	r31, 0x00	; 0
     772:	80 81       	ld	r24, Z
     774:	82 60       	ori	r24, 0x02	; 2
     776:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     778:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
     77a:	78 94       	sei
}
     77c:	08 95       	ret

0000077e <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
     77e:	f8 94       	cli
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     780:	ea e6       	ldi	r30, 0x6A	; 106
     782:	f0 e0       	ldi	r31, 0x00	; 0
     784:	80 81       	ld	r24, Z
     786:	88 60       	ori	r24, 0x08	; 8
     788:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     78a:	ed 9a       	sbi	0x1d, 5	; 29
	sei();   // Enables the global interrupt
     78c:	78 94       	sei
}
     78e:	08 95       	ret

00000790 <__vector_6>:

//ISR for right position encoder
ISR(INT5_vect)
{
     790:	1f 92       	push	r1
     792:	0f 92       	push	r0
     794:	0f b6       	in	r0, 0x3f	; 63
     796:	0f 92       	push	r0
     798:	11 24       	eor	r1, r1
     79a:	8f 93       	push	r24
     79c:	9f 93       	push	r25
     79e:	af 93       	push	r26
     7a0:	bf 93       	push	r27
	ShaftCountRight++;  //increment right shaft position count
     7a2:	80 91 1f 02 	lds	r24, 0x021F
     7a6:	90 91 20 02 	lds	r25, 0x0220
     7aa:	a0 91 21 02 	lds	r26, 0x0221
     7ae:	b0 91 22 02 	lds	r27, 0x0222
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	a1 1d       	adc	r26, r1
     7b6:	b1 1d       	adc	r27, r1
     7b8:	80 93 1f 02 	sts	0x021F, r24
     7bc:	90 93 20 02 	sts	0x0220, r25
     7c0:	a0 93 21 02 	sts	0x0221, r26
     7c4:	b0 93 22 02 	sts	0x0222, r27
}
     7c8:	bf 91       	pop	r27
     7ca:	af 91       	pop	r26
     7cc:	9f 91       	pop	r25
     7ce:	8f 91       	pop	r24
     7d0:	0f 90       	pop	r0
     7d2:	0f be       	out	0x3f, r0	; 63
     7d4:	0f 90       	pop	r0
     7d6:	1f 90       	pop	r1
     7d8:	18 95       	reti

000007da <__vector_5>:


//ISR for left position encoder
ISR(INT4_vect)
{
     7da:	1f 92       	push	r1
     7dc:	0f 92       	push	r0
     7de:	0f b6       	in	r0, 0x3f	; 63
     7e0:	0f 92       	push	r0
     7e2:	11 24       	eor	r1, r1
     7e4:	8f 93       	push	r24
     7e6:	9f 93       	push	r25
     7e8:	af 93       	push	r26
     7ea:	bf 93       	push	r27
	ShaftCountLeft++;  //increment left shaft position count
     7ec:	80 91 23 02 	lds	r24, 0x0223
     7f0:	90 91 24 02 	lds	r25, 0x0224
     7f4:	a0 91 25 02 	lds	r26, 0x0225
     7f8:	b0 91 26 02 	lds	r27, 0x0226
     7fc:	01 96       	adiw	r24, 0x01	; 1
     7fe:	a1 1d       	adc	r26, r1
     800:	b1 1d       	adc	r27, r1
     802:	80 93 23 02 	sts	0x0223, r24
     806:	90 93 24 02 	sts	0x0224, r25
     80a:	a0 93 25 02 	sts	0x0225, r26
     80e:	b0 93 26 02 	sts	0x0226, r27
}
     812:	bf 91       	pop	r27
     814:	af 91       	pop	r26
     816:	9f 91       	pop	r25
     818:	8f 91       	pop	r24
     81a:	0f 90       	pop	r0
     81c:	0f be       	out	0x3f, r0	; 63
     81e:	0f 90       	pop	r0
     820:	1f 90       	pop	r1
     822:	18 95       	reti

00000824 <motion_set1>:
void motion_set1 (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
	PortARestore = PORTA; 		// reading the PORTA original status
     824:	92 b1       	in	r25, 0x02	; 2
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     826:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set1 (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
     828:	8f 70       	andi	r24, 0x0F	; 15
	PortARestore = PORTA; 		// reading the PORTA original status
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
	PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     82a:	98 2b       	or	r25, r24
	PORTA = PortARestore; 		// executing the command
     82c:	92 b9       	out	0x02, r25	; 2
}
     82e:	08 95       	ret

00000830 <forward1>:

void forward1 (void) //both wheels forward
{
	motion_set1(0x06);
     830:	86 e0       	ldi	r24, 0x06	; 6
     832:	0e 94 12 04 	call	0x824	; 0x824 <motion_set1>
}
     836:	08 95       	ret

00000838 <back1>:

void back1 (void) //both wheels backward
{
	motion_set1(0x09);
     838:	89 e0       	ldi	r24, 0x09	; 9
     83a:	0e 94 12 04 	call	0x824	; 0x824 <motion_set1>
}
     83e:	08 95       	ret

00000840 <left1>:

void left1 (void) //Left wheel backward, Right wheel forward
{
	motion_set1(0x05);
     840:	85 e0       	ldi	r24, 0x05	; 5
     842:	0e 94 12 04 	call	0x824	; 0x824 <motion_set1>
}
     846:	08 95       	ret

00000848 <right1>:

void right1 (void) //Left wheel forward, Right wheel backward
{
	motion_set1(0x0A);
     848:	8a e0       	ldi	r24, 0x0A	; 10
     84a:	0e 94 12 04 	call	0x824	; 0x824 <motion_set1>
}
     84e:	08 95       	ret

00000850 <soft_left1>:

void soft_left1 (void) //Left wheel stationary, Right wheel forward
{
	motion_set1(0x04);
     850:	84 e0       	ldi	r24, 0x04	; 4
     852:	0e 94 12 04 	call	0x824	; 0x824 <motion_set1>
}
     856:	08 95       	ret

00000858 <soft_right1>:

void soft_right1 (void) //Left wheel forward, Right wheel is stationary
{
	motion_set1(0x02);
     858:	82 e0       	ldi	r24, 0x02	; 2
     85a:	0e 94 12 04 	call	0x824	; 0x824 <motion_set1>
}
     85e:	08 95       	ret

00000860 <soft_left_2>:

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
	motion_set1(0x01);
     860:	81 e0       	ldi	r24, 0x01	; 1
     862:	0e 94 12 04 	call	0x824	; 0x824 <motion_set1>
}
     866:	08 95       	ret

00000868 <soft_right_2>:

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
	motion_set1(0x08);
     868:	88 e0       	ldi	r24, 0x08	; 8
     86a:	0e 94 12 04 	call	0x824	; 0x824 <motion_set1>
}
     86e:	08 95       	ret

00000870 <stop1>:

void stop1 (void)
{
	motion_set1(0x00);
     870:	80 e0       	ldi	r24, 0x00	; 0
     872:	0e 94 12 04 	call	0x824	; 0x824 <motion_set1>
	
}
     876:	08 95       	ret

00000878 <angle_rotate>:


//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     878:	0f 93       	push	r16
     87a:	1f 93       	push	r17
     87c:	cf 93       	push	r28
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     87e:	bc 01       	movw	r22, r24
     880:	80 e0       	ldi	r24, 0x00	; 0
     882:	90 e0       	ldi	r25, 0x00	; 0
     884:	0e 94 43 11 	call	0x2286	; 0x2286 <__floatunsisf>
     888:	28 e4       	ldi	r18, 0x48	; 72
     88a:	31 ee       	ldi	r19, 0xE1	; 225
     88c:	42 e8       	ldi	r20, 0x82	; 130
     88e:	50 e4       	ldi	r21, 0x40	; 64
     890:	0e 94 aa 10 	call	0x2154	; 0x2154 <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     894:	0e 94 17 11 	call	0x222e	; 0x222e <__fixunssfsi>
     898:	dc 01       	movw	r26, r24
     89a:	cb 01       	movw	r24, r22
     89c:	a0 e0       	ldi	r26, 0x00	; 0
     89e:	b0 e0       	ldi	r27, 0x00	; 0
	ShaftCountRight = 0;
     8a0:	10 92 1f 02 	sts	0x021F, r1
     8a4:	10 92 20 02 	sts	0x0220, r1
     8a8:	10 92 21 02 	sts	0x0221, r1
     8ac:	10 92 22 02 	sts	0x0222, r1
	ShaftCountLeft = 0;
     8b0:	10 92 23 02 	sts	0x0223, r1
     8b4:	10 92 24 02 	sts	0x0224, r1
     8b8:	10 92 25 02 	sts	0x0225, r1
     8bc:	10 92 26 02 	sts	0x0226, r1

	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     8c0:	f1 e0       	ldi	r31, 0x01	; 1
     8c2:	c0 e0       	ldi	r28, 0x00	; 0
     8c4:	40 91 1f 02 	lds	r20, 0x021F
     8c8:	50 91 20 02 	lds	r21, 0x0220
     8cc:	60 91 21 02 	lds	r22, 0x0221
     8d0:	70 91 22 02 	lds	r23, 0x0222
     8d4:	00 91 23 02 	lds	r16, 0x0223
     8d8:	10 91 24 02 	lds	r17, 0x0224
     8dc:	20 91 25 02 	lds	r18, 0x0225
     8e0:	30 91 26 02 	lds	r19, 0x0226
     8e4:	ef 2f       	mov	r30, r31
     8e6:	48 17       	cp	r20, r24
     8e8:	59 07       	cpc	r21, r25
     8ea:	6a 07       	cpc	r22, r26
     8ec:	7b 07       	cpc	r23, r27
     8ee:	08 f4       	brcc	.+2      	; 0x8f2 <angle_rotate+0x7a>
     8f0:	ec 2f       	mov	r30, r28
     8f2:	ee 23       	and	r30, r30
     8f4:	49 f4       	brne	.+18     	; 0x908 <angle_rotate+0x90>
     8f6:	4f 2f       	mov	r20, r31
     8f8:	08 17       	cp	r16, r24
     8fa:	19 07       	cpc	r17, r25
     8fc:	2a 07       	cpc	r18, r26
     8fe:	3b 07       	cpc	r19, r27
     900:	08 f4       	brcc	.+2      	; 0x904 <angle_rotate+0x8c>
     902:	4c 2f       	mov	r20, r28
     904:	44 23       	and	r20, r20
     906:	f1 f2       	breq	.-68     	; 0x8c4 <angle_rotate+0x4c>
		break;
	}
	stop1(); //Stop robot
     908:	0e 94 38 04 	call	0x870	; 0x870 <stop1>
}
     90c:	cf 91       	pop	r28
     90e:	1f 91       	pop	r17
     910:	0f 91       	pop	r16
     912:	08 95       	ret

00000914 <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
     914:	bc 01       	movw	r22, r24
     916:	80 e0       	ldi	r24, 0x00	; 0
     918:	90 e0       	ldi	r25, 0x00	; 0
     91a:	0e 94 43 11 	call	0x2286	; 0x2286 <__floatunsisf>
     91e:	25 ee       	ldi	r18, 0xE5	; 229
     920:	30 ed       	ldi	r19, 0xD0	; 208
     922:	4a ea       	ldi	r20, 0xAA	; 170
     924:	50 e4       	ldi	r21, 0x40	; 64
     926:	0e 94 aa 10 	call	0x2154	; 0x2154 <__divsf3>
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     92a:	0e 94 17 11 	call	0x222e	; 0x222e <__fixunssfsi>
     92e:	46 2f       	mov	r20, r22
     930:	57 2f       	mov	r21, r23
     932:	68 2f       	mov	r22, r24
     934:	79 2f       	mov	r23, r25
	
	ShaftCountRight = 0;
     936:	10 92 1f 02 	sts	0x021F, r1
     93a:	10 92 20 02 	sts	0x0220, r1
     93e:	10 92 21 02 	sts	0x0221, r1
     942:	10 92 22 02 	sts	0x0222, r1
	while(1)
	{
		if(ShaftCountRight > ReqdShaftCountInt)
     946:	80 91 1f 02 	lds	r24, 0x021F
     94a:	90 91 20 02 	lds	r25, 0x0220
     94e:	a0 91 21 02 	lds	r26, 0x0221
     952:	b0 91 22 02 	lds	r27, 0x0222
     956:	48 17       	cp	r20, r24
     958:	59 07       	cpc	r21, r25
     95a:	6a 07       	cpc	r22, r26
     95c:	7b 07       	cpc	r23, r27
     95e:	98 f7       	brcc	.-26     	; 0x946 <linear_distance_mm+0x32>
		{
			break;
		}
	}
	stop1(); //Stop robot
     960:	0e 94 38 04 	call	0x870	; 0x870 <stop1>
}
     964:	08 95       	ret

00000966 <forward_mm>:

void forward_mm(unsigned int DistanceInMM)
{
     966:	cf 93       	push	r28
     968:	df 93       	push	r29
     96a:	ec 01       	movw	r28, r24
	forward1();
     96c:	0e 94 18 04 	call	0x830	; 0x830 <forward1>
	linear_distance_mm(DistanceInMM);
     970:	ce 01       	movw	r24, r28
     972:	0e 94 8a 04 	call	0x914	; 0x914 <linear_distance_mm>
}
     976:	df 91       	pop	r29
     978:	cf 91       	pop	r28
     97a:	08 95       	ret

0000097c <back_mm>:

void back_mm(unsigned int DistanceInMM)
{
     97c:	cf 93       	push	r28
     97e:	df 93       	push	r29
     980:	ec 01       	movw	r28, r24
	back1();
     982:	0e 94 1c 04 	call	0x838	; 0x838 <back1>
	linear_distance_mm(DistanceInMM);
     986:	ce 01       	movw	r24, r28
     988:	0e 94 8a 04 	call	0x914	; 0x914 <linear_distance_mm>
}
     98c:	df 91       	pop	r29
     98e:	cf 91       	pop	r28
     990:	08 95       	ret

00000992 <left_degrees>:

void left_degrees(unsigned int Degrees)
{
     992:	cf 93       	push	r28
     994:	df 93       	push	r29
     996:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	left1(); //Turn left
     998:	0e 94 20 04 	call	0x840	; 0x840 <left1>
	angle_rotate(Degrees);
     99c:	ce 01       	movw	r24, r28
     99e:	0e 94 3c 04 	call	0x878	; 0x878 <angle_rotate>
}
     9a2:	df 91       	pop	r29
     9a4:	cf 91       	pop	r28
     9a6:	08 95       	ret

000009a8 <right_degrees>:



void right_degrees(unsigned int Degrees)
{
     9a8:	cf 93       	push	r28
     9aa:	df 93       	push	r29
     9ac:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	right1(); //Turn right
     9ae:	0e 94 24 04 	call	0x848	; 0x848 <right1>
	angle_rotate(Degrees);
     9b2:	ce 01       	movw	r24, r28
     9b4:	0e 94 3c 04 	call	0x878	; 0x878 <angle_rotate>
}
     9b8:	df 91       	pop	r29
     9ba:	cf 91       	pop	r28
     9bc:	08 95       	ret

000009be <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)
{
     9be:	cf 93       	push	r28
     9c0:	df 93       	push	r29
     9c2:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left1(); //Turn soft left
     9c4:	0e 94 28 04 	call	0x850	; 0x850 <soft_left1>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     9c8:	ce 01       	movw	r24, r28
     9ca:	88 0f       	add	r24, r24
     9cc:	99 1f       	adc	r25, r25
     9ce:	0e 94 3c 04 	call	0x878	; 0x878 <angle_rotate>
}
     9d2:	df 91       	pop	r29
     9d4:	cf 91       	pop	r28
     9d6:	08 95       	ret

000009d8 <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
     9d8:	cf 93       	push	r28
     9da:	df 93       	push	r29
     9dc:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right1();  //Turn soft right
     9de:	0e 94 2c 04 	call	0x858	; 0x858 <soft_right1>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     9e2:	ce 01       	movw	r24, r28
     9e4:	88 0f       	add	r24, r24
     9e6:	99 1f       	adc	r25, r25
     9e8:	0e 94 3c 04 	call	0x878	; 0x878 <angle_rotate>
}
     9ec:	df 91       	pop	r29
     9ee:	cf 91       	pop	r28
     9f0:	08 95       	ret

000009f2 <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
     9f2:	cf 93       	push	r28
     9f4:	df 93       	push	r29
     9f6:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left_2(); //Turn reverse soft left
     9f8:	0e 94 30 04 	call	0x860	; 0x860 <soft_left_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     9fc:	ce 01       	movw	r24, r28
     9fe:	88 0f       	add	r24, r24
     a00:	99 1f       	adc	r25, r25
     a02:	0e 94 3c 04 	call	0x878	; 0x878 <angle_rotate>
}
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	08 95       	ret

00000a0c <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
     a0c:	cf 93       	push	r28
     a0e:	df 93       	push	r29
     a10:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right_2();  //Turn reverse soft right
     a12:	0e 94 34 04 	call	0x868	; 0x868 <soft_right_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     a16:	ce 01       	movw	r24, r28
     a18:	88 0f       	add	r24, r24
     a1a:	99 1f       	adc	r25, r25
     a1c:	0e 94 3c 04 	call	0x878	; 0x878 <angle_rotate>
}
     a20:	df 91       	pop	r29
     a22:	cf 91       	pop	r28
     a24:	08 95       	ret

00000a26 <init_devices1>:

//Function to initialize all the devices
void init_devices1()
{
	cli(); //Clears the global interrupt
     a26:	f8 94       	cli
	port_init1();  //Initializes all the ports
     a28:	0e 94 af 03 	call	0x75e	; 0x75e <port_init1>
	left_position_encoder_interrupt_init();
     a2c:	0e 94 b6 03 	call	0x76c	; 0x76c <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
     a30:	0e 94 bf 03 	call	0x77e	; 0x77e <right_position_encoder_interrupt_init>
	sei();   // Enables the global interrupt
     a34:	78 94       	sei
}
     a36:	08 95       	ret

00000a38 <servo1_pin_config>:


//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
 DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
     a38:	25 9a       	sbi	0x04, 5	; 4
 PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
     a3a:	2d 9a       	sbi	0x05, 5	; 5
}
     a3c:	08 95       	ret

00000a3e <servo2_pin_config>:

//Configure PORTB 6 pin for servo motor 2 operation
void servo2_pin_config (void)
{
 DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
     a3e:	26 9a       	sbi	0x04, 6	; 4
 PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
     a40:	2e 9a       	sbi	0x05, 6	; 5
}
     a42:	08 95       	ret

00000a44 <servo3_pin_config>:

//Configure PORTB 7 pin for servo motor 3 operation
void servo3_pin_config (void)
{
 DDRB  = DDRB | 0x80;  //making PORTB 7 pin output
     a44:	27 9a       	sbi	0x04, 7	; 4
 PORTB = PORTB | 0x80; //setting PORTB 7 pin to logic 1
     a46:	2f 9a       	sbi	0x05, 7	; 5
}
     a48:	08 95       	ret

00000a4a <port_init_servo>:

//Initialize the ports
void port_init_servo(void)
{
 servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
     a4a:	0e 94 1c 05 	call	0xa38	; 0xa38 <servo1_pin_config>
 servo2_pin_config(); //Configure PORTB 6 pin for servo motor 2 operation 
     a4e:	0e 94 1f 05 	call	0xa3e	; 0xa3e <servo2_pin_config>
 servo3_pin_config(); //Configure PORTB 7 pin for servo motor 3 operation  
     a52:	0e 94 22 05 	call	0xa44	; 0xa44 <servo3_pin_config>
}
     a56:	08 95       	ret

00000a58 <timer1_init>:
//prescale:256
// WGM: 7) PWM 10bit fast, TOP=0x03FF
// actual value: 52.25Hz 
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     a58:	e1 e8       	ldi	r30, 0x81	; 129
     a5a:	f0 e0       	ldi	r31, 0x00	; 0
     a5c:	10 82       	st	Z, r1
 ICR1 = 1023;
     a5e:	8f ef       	ldi	r24, 0xFF	; 255
     a60:	93 e0       	ldi	r25, 0x03	; 3
     a62:	90 93 87 00 	sts	0x0087, r25
     a66:	80 93 86 00 	sts	0x0086, r24
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
     a6a:	2c ef       	ldi	r18, 0xFC	; 252
     a6c:	20 93 85 00 	sts	0x0085, r18
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
     a70:	21 e0       	ldi	r18, 0x01	; 1
     a72:	20 93 84 00 	sts	0x0084, r18
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
 ICR1H  = 0x03;	
 ICR1L  = 0xFF;*///////
 OCR1A = 1023;
     a76:	90 93 89 00 	sts	0x0089, r25
     a7a:	80 93 88 00 	sts	0x0088, r24
 OCR1B = 1023;
     a7e:	90 93 8b 00 	sts	0x008B, r25
     a82:	80 93 8a 00 	sts	0x008A, r24
 OCR1C = 1023;
     a86:	90 93 8d 00 	sts	0x008D, r25
     a8a:	80 93 8c 00 	sts	0x008C, r24
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
     a8e:	8b ea       	ldi	r24, 0xAB	; 171
     a90:	80 93 80 00 	sts	0x0080, r24
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
//TCCR1C = 0x00;
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
     a94:	8c e0       	ldi	r24, 0x0C	; 12
     a96:	80 83       	st	Z, r24
}
     a98:	08 95       	ret

00000a9a <init_devices_servo>:


//Function to initialize all the peripherals
void init_devices_servo(void)
{
 cli(); //disable all interrupts
     a9a:	f8 94       	cli
 port_init_servo();
     a9c:	0e 94 25 05 	call	0xa4a	; 0xa4a <port_init_servo>
 timer1_init();
     aa0:	0e 94 2c 05 	call	0xa58	; 0xa58 <timer1_init>
 sei(); //re-enable interrupts 
     aa4:	78 94       	sei
}
     aa6:	08 95       	ret

00000aa8 <servo_1>:

//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)  
{
 //float PositionPanServo = 0;
  float PositionPanServo = ((float)degrees * 0.512) + 34.56;
     aa8:	68 2f       	mov	r22, r24
     aaa:	70 e0       	ldi	r23, 0x00	; 0
     aac:	80 e0       	ldi	r24, 0x00	; 0
     aae:	90 e0       	ldi	r25, 0x00	; 0
     ab0:	0e 94 43 11 	call	0x2286	; 0x2286 <__floatunsisf>
     ab4:	2f e6       	ldi	r18, 0x6F	; 111
     ab6:	32 e1       	ldi	r19, 0x12	; 18
     ab8:	43 e0       	ldi	r20, 0x03	; 3
     aba:	5f e3       	ldi	r21, 0x3F	; 63
     abc:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <__mulsf3>
     ac0:	21 e7       	ldi	r18, 0x71	; 113
     ac2:	3d e3       	ldi	r19, 0x3D	; 61
     ac4:	4a e0       	ldi	r20, 0x0A	; 10
     ac6:	52 e4       	ldi	r21, 0x42	; 66
     ac8:	0e 94 46 10 	call	0x208c	; 0x208c <__addsf3>
// OCR1AH = 0x00;
 OCR1A = (unsigned char) PositionPanServo;
     acc:	0e 94 17 11 	call	0x222e	; 0x222e <__fixunssfsi>
     ad0:	70 e0       	ldi	r23, 0x00	; 0
     ad2:	70 93 89 00 	sts	0x0089, r23
     ad6:	60 93 88 00 	sts	0x0088, r22
}
     ada:	08 95       	ret

00000adc <servo_2>:

//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
 
 float PositionPanServo = ((float)degrees * 0.512) + 34.56;
     adc:	68 2f       	mov	r22, r24
     ade:	70 e0       	ldi	r23, 0x00	; 0
     ae0:	80 e0       	ldi	r24, 0x00	; 0
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	0e 94 43 11 	call	0x2286	; 0x2286 <__floatunsisf>
     ae8:	2f e6       	ldi	r18, 0x6F	; 111
     aea:	32 e1       	ldi	r19, 0x12	; 18
     aec:	43 e0       	ldi	r20, 0x03	; 3
     aee:	5f e3       	ldi	r21, 0x3F	; 63
     af0:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <__mulsf3>
     af4:	21 e7       	ldi	r18, 0x71	; 113
     af6:	3d e3       	ldi	r19, 0x3D	; 61
     af8:	4a e0       	ldi	r20, 0x0A	; 10
     afa:	52 e4       	ldi	r21, 0x42	; 66
     afc:	0e 94 46 10 	call	0x208c	; 0x208c <__addsf3>
 // OCR1AH = 0x00;
 OCR1B = (unsigned char) PositionPanServo;
     b00:	0e 94 17 11 	call	0x222e	; 0x222e <__fixunssfsi>
     b04:	70 e0       	ldi	r23, 0x00	; 0
     b06:	70 93 8b 00 	sts	0x008B, r23
     b0a:	60 93 8a 00 	sts	0x008A, r22
}
     b0e:	08 95       	ret

00000b10 <servo_3>:

//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
 
 float PositionPanServo = ((float)degrees * 0.512) + 34.56;
     b10:	68 2f       	mov	r22, r24
     b12:	70 e0       	ldi	r23, 0x00	; 0
     b14:	80 e0       	ldi	r24, 0x00	; 0
     b16:	90 e0       	ldi	r25, 0x00	; 0
     b18:	0e 94 43 11 	call	0x2286	; 0x2286 <__floatunsisf>
     b1c:	2f e6       	ldi	r18, 0x6F	; 111
     b1e:	32 e1       	ldi	r19, 0x12	; 18
     b20:	43 e0       	ldi	r20, 0x03	; 3
     b22:	5f e3       	ldi	r21, 0x3F	; 63
     b24:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <__mulsf3>
     b28:	21 e7       	ldi	r18, 0x71	; 113
     b2a:	3d e3       	ldi	r19, 0x3D	; 61
     b2c:	4a e0       	ldi	r20, 0x0A	; 10
     b2e:	52 e4       	ldi	r21, 0x42	; 66
     b30:	0e 94 46 10 	call	0x208c	; 0x208c <__addsf3>
 // OCR1AH = 0x00;
 OCR1C = (unsigned char) PositionPanServo;
     b34:	0e 94 17 11 	call	0x222e	; 0x222e <__fixunssfsi>
     b38:	70 e0       	ldi	r23, 0x00	; 0
     b3a:	70 93 8d 00 	sts	0x008D, r23
     b3e:	60 93 8c 00 	sts	0x008C, r22
}
     b42:	08 95       	ret

00000b44 <servo_1_free>:
//reduce the power consumption of the motor if it is holding load against the gravity.


void servo_1_free (void) //makes servo 1 free rotating
{
 OCR1A = 1023; 
     b44:	8f ef       	ldi	r24, 0xFF	; 255
     b46:	93 e0       	ldi	r25, 0x03	; 3
     b48:	90 93 89 00 	sts	0x0089, r25
     b4c:	80 93 88 00 	sts	0x0088, r24
// OCR1AL = 0xFF; //Servo 1 off
}
     b50:	08 95       	ret

00000b52 <servo_2_free>:

void servo_2_free (void) //makes servo 2 free rotating
{
 OCR1B = 1023;
     b52:	8f ef       	ldi	r24, 0xFF	; 255
     b54:	93 e0       	ldi	r25, 0x03	; 3
     b56:	90 93 8b 00 	sts	0x008B, r25
     b5a:	80 93 8a 00 	sts	0x008A, r24
//OCR1BL = 0xFF; //Servo 2 off
}
     b5e:	08 95       	ret

00000b60 <servo_3_free>:

void servo_3_free (void) //makes servo 3 free rotating
{
 OCR1C = 1023;
     b60:	8f ef       	ldi	r24, 0xFF	; 255
     b62:	93 e0       	ldi	r25, 0x03	; 3
     b64:	90 93 8d 00 	sts	0x008D, r25
     b68:	80 93 8c 00 	sts	0x008C, r24
// OCR1CL = 0xFF; //Servo 3 off
} 
     b6c:	08 95       	ret

00000b6e <adc_pin_config_sharp>:
}*/

//ADC pin configuration
void adc_pin_config_sharp (void)
{
 DDRF = 0x00; //set PORTF direction as input
     b6e:	10 ba       	out	0x10, r1	; 16
 PORTF = 0x00; //set PORTF pins floating
     b70:	11 ba       	out	0x11, r1	; 17
 DDRK = 0x00; //set PORTK direction as input
     b72:	10 92 07 01 	sts	0x0107, r1
 PORTK = 0x00; //set PORTK pins floating
     b76:	10 92 08 01 	sts	0x0108, r1
}
     b7a:	08 95       	ret

00000b7c <port_init_sharp>:

//Function to Initialize PORTS
void port_init_sharp()
{
	//lcd_port_config();
	adc_pin_config_sharp();	
     b7c:	0e 94 b7 05 	call	0xb6e	; 0xb6e <adc_pin_config_sharp>
}
     b80:	08 95       	ret

00000b82 <adc_init_sharp>:

//Function to Initialize ADC
void adc_init_sharp()
{
	ADCSRA = 0x00;
     b82:	ea e7       	ldi	r30, 0x7A	; 122
     b84:	f0 e0       	ldi	r31, 0x00	; 0
     b86:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
     b88:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     b8c:	80 e2       	ldi	r24, 0x20	; 32
     b8e:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
     b92:	80 e8       	ldi	r24, 0x80	; 128
     b94:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     b96:	86 e8       	ldi	r24, 0x86	; 134
     b98:	80 83       	st	Z, r24
}
     b9a:	08 95       	ret

00000b9c <ADC_Conversion_sharp>:

//This Function accepts the Channel Number and returns the corresponding Analog Value 
unsigned char ADC_Conversion_sharp(unsigned char Ch)
{
	unsigned char a;
	if(Ch>7)
     b9c:	88 30       	cpi	r24, 0x08	; 8
     b9e:	18 f0       	brcs	.+6      	; 0xba6 <ADC_Conversion_sharp+0xa>
	{
		ADCSRB = 0x08;
     ba0:	98 e0       	ldi	r25, 0x08	; 8
     ba2:	90 93 7b 00 	sts	0x007B, r25
	}
	Ch = Ch & 0x07;  			
     ba6:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;	   		
     ba8:	80 62       	ori	r24, 0x20	; 32
     baa:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     bae:	ea e7       	ldi	r30, 0x7A	; 122
     bb0:	f0 e0       	ldi	r31, 0x00	; 0
     bb2:	80 81       	ld	r24, Z
     bb4:	80 64       	ori	r24, 0x40	; 64
     bb6:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     bb8:	80 81       	ld	r24, Z
     bba:	84 ff       	sbrs	r24, 4
     bbc:	fd cf       	rjmp	.-6      	; 0xbb8 <ADC_Conversion_sharp+0x1c>
	a=ADCH;
     bbe:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     bc2:	ea e7       	ldi	r30, 0x7A	; 122
     bc4:	f0 e0       	ldi	r31, 0x00	; 0
     bc6:	90 81       	ld	r25, Z
     bc8:	90 61       	ori	r25, 0x10	; 16
     bca:	90 83       	st	Z, r25
	ADCSRB = 0x00;
     bcc:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
     bd0:	08 95       	ret

00000bd2 <print_sensor_sharp>:


// This Function prints the Analog Value Of Corresponding Channel No. at required Row
// and Coloumn Location. 
void print_sensor_sharp(char row, char coloumn,unsigned char channel)
{
     bd2:	84 2f       	mov	r24, r20
	ADC_Value_sharp = ADC_Conversion_sharp(channel);
     bd4:	0e 94 ce 05 	call	0xb9c	; 0xb9c <ADC_Conversion_sharp>
     bd8:	80 93 e0 02 	sts	0x02E0, r24
	//lcd_print(row, coloumn, ADC_Value, 3);
}
     bdc:	08 95       	ret

00000bde <Sharp_GP2D12_estimation>:


// This Function calculates the actual distance in millimeters(mm) from the input
// analog value of Sharp Sensor. 
unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
{
     bde:	0f 93       	push	r16
     be0:	1f 93       	push	r17
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
     be2:	68 2f       	mov	r22, r24
     be4:	70 e0       	ldi	r23, 0x00	; 0
     be6:	80 e0       	ldi	r24, 0x00	; 0
     be8:	90 e0       	ldi	r25, 0x00	; 0
     bea:	0e 94 43 11 	call	0x2286	; 0x2286 <__floatunsisf>
     bee:	2f ee       	ldi	r18, 0xEF	; 239
     bf0:	39 ec       	ldi	r19, 0xC9	; 201
     bf2:	43 e9       	ldi	r20, 0x93	; 147
     bf4:	5f e3       	ldi	r21, 0x3F	; 63
     bf6:	0e 94 34 12 	call	0x2468	; 0x2468 <pow>
     bfa:	b6 2f       	mov	r27, r22
     bfc:	a7 2f       	mov	r26, r23
     bfe:	38 2f       	mov	r19, r24
     c00:	29 2f       	mov	r18, r25
     c02:	60 e0       	ldi	r22, 0x00	; 0
     c04:	70 e0       	ldi	r23, 0x00	; 0
     c06:	80 e8       	ldi	r24, 0x80	; 128
     c08:	9f e3       	ldi	r25, 0x3F	; 63
     c0a:	42 2f       	mov	r20, r18
     c0c:	0b 2f       	mov	r16, r27
     c0e:	1a 2f       	mov	r17, r26
     c10:	23 2f       	mov	r18, r19
     c12:	34 2f       	mov	r19, r20
     c14:	a9 01       	movw	r20, r18
     c16:	98 01       	movw	r18, r16
     c18:	0e 94 aa 10 	call	0x2154	; 0x2154 <__divsf3>
     c1c:	2a e9       	ldi	r18, 0x9A	; 154
     c1e:	39 ef       	ldi	r19, 0xF9	; 249
     c20:	4e e2       	ldi	r20, 0x2E	; 46
     c22:	55 e4       	ldi	r21, 0x45	; 69
     c24:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <__mulsf3>
     c28:	20 e0       	ldi	r18, 0x00	; 0
     c2a:	30 e0       	ldi	r19, 0x00	; 0
     c2c:	40 e2       	ldi	r20, 0x20	; 32
     c2e:	51 e4       	ldi	r21, 0x41	; 65
     c30:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <__mulsf3>
     c34:	0e 94 12 11 	call	0x2224	; 0x2224 <__fixsfsi>
     c38:	88 27       	eor	r24, r24
     c3a:	77 fd       	sbrc	r23, 7
     c3c:	80 95       	com	r24
     c3e:	98 2f       	mov	r25, r24
     c40:	0e 94 45 11 	call	0x228a	; 0x228a <__floatsisf>
	distanceInt = (int)distance;
     c44:	0e 94 12 11 	call	0x2224	; 0x2224 <__fixsfsi>
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
     c48:	86 2f       	mov	r24, r22
     c4a:	97 2f       	mov	r25, r23
     c4c:	23 e0       	ldi	r18, 0x03	; 3
     c4e:	81 32       	cpi	r24, 0x21	; 33
     c50:	92 07       	cpc	r25, r18
     c52:	10 f0       	brcs	.+4      	; 0xc58 <Sharp_GP2D12_estimation+0x7a>
     c54:	80 e2       	ldi	r24, 0x20	; 32
     c56:	93 e0       	ldi	r25, 0x03	; 3
}
     c58:	1f 91       	pop	r17
     c5a:	0f 91       	pop	r16
     c5c:	08 95       	ret

00000c5e <init_devices_sharp>:

void init_devices_sharp (void)
{
 cli(); //Clears the global interrupts
     c5e:	f8 94       	cli
 port_init_sharp();
     c60:	0e 94 be 05 	call	0xb7c	; 0xb7c <port_init_sharp>
 adc_init_sharp();
     c64:	0e 94 c1 05 	call	0xb82	; 0xb82 <adc_init_sharp>
 sei(); //Enables the global interrupts
     c68:	78 94       	sei
}
     c6a:	08 95       	ret

00000c6c <lcd_set_4bit>:
     c6c:	86 e6       	ldi	r24, 0x66	; 102
     c6e:	9e e0       	ldi	r25, 0x0E	; 14
     c70:	01 97       	sbiw	r24, 0x01	; 1
     c72:	f1 f7       	brne	.-4      	; 0xc70 <lcd_set_4bit+0x4>
     c74:	00 00       	nop
/*****Function to Reset LCD*****/
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     c76:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     c78:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     c7a:	80 e3       	ldi	r24, 0x30	; 48
     c7c:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     c7e:	42 9a       	sbi	0x08, 2	; 8
     c80:	ef ef       	ldi	r30, 0xFF	; 255
     c82:	f7 e4       	ldi	r31, 0x47	; 71
     c84:	31 97       	sbiw	r30, 0x01	; 1
     c86:	f1 f7       	brne	.-4      	; 0xc84 <lcd_set_4bit+0x18>
     c88:	00 c0       	rjmp	.+0      	; 0xc8a <lcd_set_4bit+0x1e>
     c8a:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     c8c:	42 98       	cbi	0x08, 2	; 8
     c8e:	e6 e6       	ldi	r30, 0x66	; 102
     c90:	fe e0       	ldi	r31, 0x0E	; 14
     c92:	31 97       	sbiw	r30, 0x01	; 1
     c94:	f1 f7       	brne	.-4      	; 0xc92 <lcd_set_4bit+0x26>
     c96:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     c98:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     c9a:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     c9c:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     c9e:	42 9a       	sbi	0x08, 2	; 8
     ca0:	ef ef       	ldi	r30, 0xFF	; 255
     ca2:	f7 e4       	ldi	r31, 0x47	; 71
     ca4:	31 97       	sbiw	r30, 0x01	; 1
     ca6:	f1 f7       	brne	.-4      	; 0xca4 <lcd_set_4bit+0x38>
     ca8:	00 c0       	rjmp	.+0      	; 0xcaa <lcd_set_4bit+0x3e>
     caa:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     cac:	42 98       	cbi	0x08, 2	; 8
     cae:	e6 e6       	ldi	r30, 0x66	; 102
     cb0:	fe e0       	ldi	r31, 0x0E	; 14
     cb2:	31 97       	sbiw	r30, 0x01	; 1
     cb4:	f1 f7       	brne	.-4      	; 0xcb2 <lcd_set_4bit+0x46>
     cb6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     cb8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     cba:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     cbc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     cbe:	42 9a       	sbi	0x08, 2	; 8
     cc0:	8f ef       	ldi	r24, 0xFF	; 255
     cc2:	97 e4       	ldi	r25, 0x47	; 71
     cc4:	01 97       	sbiw	r24, 0x01	; 1
     cc6:	f1 f7       	brne	.-4      	; 0xcc4 <lcd_set_4bit+0x58>
     cc8:	00 c0       	rjmp	.+0      	; 0xcca <lcd_set_4bit+0x5e>
     cca:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     ccc:	42 98       	cbi	0x08, 2	; 8
     cce:	e6 e6       	ldi	r30, 0x66	; 102
     cd0:	fe e0       	ldi	r31, 0x0E	; 14
     cd2:	31 97       	sbiw	r30, 0x01	; 1
     cd4:	f1 f7       	brne	.-4      	; 0xcd2 <lcd_set_4bit+0x66>
     cd6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     cd8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     cda:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     cdc:	80 e2       	ldi	r24, 0x20	; 32
     cde:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     ce0:	42 9a       	sbi	0x08, 2	; 8
     ce2:	8f ef       	ldi	r24, 0xFF	; 255
     ce4:	97 e4       	ldi	r25, 0x47	; 71
     ce6:	01 97       	sbiw	r24, 0x01	; 1
     ce8:	f1 f7       	brne	.-4      	; 0xce6 <lcd_set_4bit+0x7a>
     cea:	00 c0       	rjmp	.+0      	; 0xcec <lcd_set_4bit+0x80>
     cec:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     cee:	42 98       	cbi	0x08, 2	; 8

	
}
     cf0:	08 95       	ret

00000cf2 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     cf2:	98 b1       	in	r25, 0x08	; 8
     cf4:	9f 70       	andi	r25, 0x0F	; 15
     cf6:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     cf8:	98 b1       	in	r25, 0x08	; 8
/*****Function to Write Command on LCD*****/
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     cfa:	28 2f       	mov	r18, r24
     cfc:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     cfe:	92 2b       	or	r25, r18
     d00:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     d02:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     d04:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     d06:	42 9a       	sbi	0x08, 2	; 8
     d08:	ef ef       	ldi	r30, 0xFF	; 255
     d0a:	f7 e4       	ldi	r31, 0x47	; 71
     d0c:	31 97       	sbiw	r30, 0x01	; 1
     d0e:	f1 f7       	brne	.-4      	; 0xd0c <lcd_wr_command+0x1a>
     d10:	00 c0       	rjmp	.+0      	; 0xd12 <lcd_wr_command+0x20>
     d12:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     d14:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     d16:	98 b1       	in	r25, 0x08	; 8
     d18:	9f 70       	andi	r25, 0x0F	; 15
     d1a:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     d1c:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     d1e:	82 95       	swap	r24
     d20:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     d22:	89 2b       	or	r24, r25
     d24:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     d26:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     d28:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     d2a:	42 9a       	sbi	0x08, 2	; 8
     d2c:	8f ef       	ldi	r24, 0xFF	; 255
     d2e:	97 e4       	ldi	r25, 0x47	; 71
     d30:	01 97       	sbiw	r24, 0x01	; 1
     d32:	f1 f7       	brne	.-4      	; 0xd30 <lcd_wr_command+0x3e>
     d34:	00 c0       	rjmp	.+0      	; 0xd36 <lcd_wr_command+0x44>
     d36:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     d38:	42 98       	cbi	0x08, 2	; 8
}
     d3a:	08 95       	ret

00000d3c <lcd_init>:
     d3c:	86 e6       	ldi	r24, 0x66	; 102
     d3e:	9e e0       	ldi	r25, 0x0E	; 14
     d40:	01 97       	sbiw	r24, 0x01	; 1
     d42:	f1 f7       	brne	.-4      	; 0xd40 <lcd_init+0x4>
     d44:	00 00       	nop
/*****Function to Initialize LCD*****/
void lcd_init()
{
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     d46:	88 e2       	ldi	r24, 0x28	; 40
     d48:	0e 94 79 06 	call	0xcf2	; 0xcf2 <lcd_wr_command>
	lcd_wr_command(0x01);
     d4c:	81 e0       	ldi	r24, 0x01	; 1
     d4e:	0e 94 79 06 	call	0xcf2	; 0xcf2 <lcd_wr_command>
	lcd_wr_command(0x06);
     d52:	86 e0       	ldi	r24, 0x06	; 6
     d54:	0e 94 79 06 	call	0xcf2	; 0xcf2 <lcd_wr_command>
	lcd_wr_command(0x0E);
     d58:	8e e0       	ldi	r24, 0x0E	; 14
     d5a:	0e 94 79 06 	call	0xcf2	; 0xcf2 <lcd_wr_command>
	lcd_wr_command(0x80);
     d5e:	80 e8       	ldi	r24, 0x80	; 128
     d60:	0e 94 79 06 	call	0xcf2	; 0xcf2 <lcd_wr_command>
	
}
     d64:	08 95       	ret

00000d66 <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     d66:	98 b1       	in	r25, 0x08	; 8
     d68:	9f 70       	andi	r25, 0x0F	; 15
     d6a:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     d6c:	98 b1       	in	r25, 0x08	; 8
/*****Function to Write Data on LCD*****/
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     d6e:	28 2f       	mov	r18, r24
     d70:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     d72:	92 2b       	or	r25, r18
     d74:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     d76:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     d78:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     d7a:	42 9a       	sbi	0x08, 2	; 8
     d7c:	ef ef       	ldi	r30, 0xFF	; 255
     d7e:	f7 e4       	ldi	r31, 0x47	; 71
     d80:	31 97       	sbiw	r30, 0x01	; 1
     d82:	f1 f7       	brne	.-4      	; 0xd80 <lcd_wr_char+0x1a>
     d84:	00 c0       	rjmp	.+0      	; 0xd86 <lcd_wr_char+0x20>
     d86:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     d88:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     d8a:	98 b1       	in	r25, 0x08	; 8
     d8c:	9f 70       	andi	r25, 0x0F	; 15
     d8e:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     d90:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     d92:	82 95       	swap	r24
     d94:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     d96:	89 2b       	or	r24, r25
     d98:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     d9a:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     d9c:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     d9e:	42 9a       	sbi	0x08, 2	; 8
     da0:	8f ef       	ldi	r24, 0xFF	; 255
     da2:	97 e4       	ldi	r25, 0x47	; 71
     da4:	01 97       	sbiw	r24, 0x01	; 1
     da6:	f1 f7       	brne	.-4      	; 0xda4 <lcd_wr_char+0x3e>
     da8:	00 c0       	rjmp	.+0      	; 0xdaa <lcd_wr_char+0x44>
     daa:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     dac:	42 98       	cbi	0x08, 2	; 8
}
     dae:	08 95       	ret

00000db0 <lcd_home>:


void lcd_home()
{
	lcd_wr_command(0x80);
     db0:	80 e8       	ldi	r24, 0x80	; 128
     db2:	0e 94 79 06 	call	0xcf2	; 0xcf2 <lcd_wr_command>
}
     db6:	08 95       	ret

00000db8 <lcd_string>:


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
{
     db8:	cf 93       	push	r28
     dba:	df 93       	push	r29
     dbc:	ec 01       	movw	r28, r24
	while(*str != '\0')
     dbe:	88 81       	ld	r24, Y
     dc0:	88 23       	and	r24, r24
     dc2:	31 f0       	breq	.+12     	; 0xdd0 <lcd_string+0x18>
	lcd_wr_command(0x80);
}


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
     dc4:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     dc6:	0e 94 b3 06 	call	0xd66	; 0xd66 <lcd_wr_char>


/*****Function to Print String on LCD*****/
void lcd_string(char *str)
{
	while(*str != '\0')
     dca:	89 91       	ld	r24, Y+
     dcc:	88 23       	and	r24, r24
     dce:	d9 f7       	brne	.-10     	; 0xdc6 <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     dd0:	df 91       	pop	r29
     dd2:	cf 91       	pop	r28
     dd4:	08 95       	ret

00000dd6 <lcd_cursor>:

/*** Position the LCD cursor at "row", "column". ***/

void lcd_cursor (char row, char column)
{
	switch (row) {
     dd6:	82 30       	cpi	r24, 0x02	; 2
     dd8:	79 f0       	breq	.+30     	; 0xdf8 <lcd_cursor+0x22>
     dda:	83 30       	cpi	r24, 0x03	; 3
     ddc:	18 f4       	brcc	.+6      	; 0xde4 <lcd_cursor+0xe>
     dde:	81 30       	cpi	r24, 0x01	; 1
     de0:	c9 f4       	brne	.+50     	; 0xe14 <lcd_cursor+0x3e>
     de2:	05 c0       	rjmp	.+10     	; 0xdee <lcd_cursor+0x18>
     de4:	83 30       	cpi	r24, 0x03	; 3
     de6:	69 f0       	breq	.+26     	; 0xe02 <lcd_cursor+0x2c>
     de8:	84 30       	cpi	r24, 0x04	; 4
     dea:	a1 f4       	brne	.+40     	; 0xe14 <lcd_cursor+0x3e>
     dec:	0f c0       	rjmp	.+30     	; 0xe0c <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     dee:	86 2f       	mov	r24, r22
     df0:	81 58       	subi	r24, 0x81	; 129
     df2:	0e 94 79 06 	call	0xcf2	; 0xcf2 <lcd_wr_command>
     df6:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     df8:	86 2f       	mov	r24, r22
     dfa:	81 54       	subi	r24, 0x41	; 65
     dfc:	0e 94 79 06 	call	0xcf2	; 0xcf2 <lcd_wr_command>
     e00:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     e02:	86 2f       	mov	r24, r22
     e04:	8d 56       	subi	r24, 0x6D	; 109
     e06:	0e 94 79 06 	call	0xcf2	; 0xcf2 <lcd_wr_command>
     e0a:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     e0c:	86 2f       	mov	r24, r22
     e0e:	8d 52       	subi	r24, 0x2D	; 45
     e10:	0e 94 79 06 	call	0xcf2	; 0xcf2 <lcd_wr_command>
     e14:	08 95       	ret

00000e16 <lcd_print>:
	}
}

/***** Function To Print Any input value upto the desired digit on LCD *****/
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     e16:	0f 93       	push	r16
     e18:	1f 93       	push	r17
     e1a:	cf 93       	push	r28
     e1c:	df 93       	push	r29
     e1e:	8a 01       	movw	r16, r20
     e20:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     e22:	88 23       	and	r24, r24
     e24:	11 f0       	breq	.+4      	; 0xe2a <lcd_print+0x14>
     e26:	66 23       	and	r22, r22
     e28:	19 f4       	brne	.+6      	; 0xe30 <lcd_print+0x1a>
	{
		lcd_home();
     e2a:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <lcd_home>
     e2e:	02 c0       	rjmp	.+4      	; 0xe34 <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     e30:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <lcd_cursor>
	}
	if(digits==5 || flag==1)
     e34:	c5 30       	cpi	r28, 0x05	; 5
     e36:	d1 05       	cpc	r29, r1
     e38:	71 f4       	brne	.+28     	; 0xe56 <lcd_print+0x40>
	{
		million=value/10000+48;
     e3a:	c8 01       	movw	r24, r16
     e3c:	60 e1       	ldi	r22, 0x10	; 16
     e3e:	77 e2       	ldi	r23, 0x27	; 39
     e40:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodhi4>
     e44:	cb 01       	movw	r24, r22
     e46:	c0 96       	adiw	r24, 0x30	; 48
     e48:	90 93 4a 02 	sts	0x024A, r25
     e4c:	80 93 49 02 	sts	0x0249, r24
		lcd_wr_char(million);
     e50:	0e 94 b3 06 	call	0xd66	; 0xd66 <lcd_wr_char>
     e54:	03 c0       	rjmp	.+6      	; 0xe5c <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     e56:	c4 30       	cpi	r28, 0x04	; 4
     e58:	d1 05       	cpc	r29, r1
     e5a:	b9 f4       	brne	.+46     	; 0xe8a <lcd_print+0x74>
	{
		temp = value/1000;
     e5c:	c8 01       	movw	r24, r16
     e5e:	68 ee       	ldi	r22, 0xE8	; 232
     e60:	73 e0       	ldi	r23, 0x03	; 3
     e62:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodhi4>
     e66:	cb 01       	movw	r24, r22
     e68:	70 93 71 02 	sts	0x0271, r23
     e6c:	60 93 70 02 	sts	0x0270, r22
		thousand = temp%10 + 48;
     e70:	6a e0       	ldi	r22, 0x0A	; 10
     e72:	70 e0       	ldi	r23, 0x00	; 0
     e74:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodhi4>
     e78:	c0 96       	adiw	r24, 0x30	; 48
     e7a:	90 93 f3 02 	sts	0x02F3, r25
     e7e:	80 93 f2 02 	sts	0x02F2, r24
		lcd_wr_char(thousand);
     e82:	0e 94 b3 06 	call	0xd66	; 0xd66 <lcd_wr_char>
		flag=1;
     e86:	81 e0       	ldi	r24, 0x01	; 1
     e88:	01 c0       	rjmp	.+2      	; 0xe8c <lcd_print+0x76>
}

/***** Function To Print Any input value upto the desired digit on LCD *****/
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     e8a:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     e8c:	c3 30       	cpi	r28, 0x03	; 3
     e8e:	d1 05       	cpc	r29, r1
     e90:	11 f0       	breq	.+4      	; 0xe96 <lcd_print+0x80>
     e92:	81 30       	cpi	r24, 0x01	; 1
     e94:	b1 f4       	brne	.+44     	; 0xec2 <lcd_print+0xac>
	{
		temp = value/100;
     e96:	c8 01       	movw	r24, r16
     e98:	64 e6       	ldi	r22, 0x64	; 100
     e9a:	70 e0       	ldi	r23, 0x00	; 0
     e9c:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodhi4>
     ea0:	cb 01       	movw	r24, r22
     ea2:	70 93 71 02 	sts	0x0271, r23
     ea6:	60 93 70 02 	sts	0x0270, r22
		hundred = temp%10 + 48;
     eaa:	6a e0       	ldi	r22, 0x0A	; 10
     eac:	70 e0       	ldi	r23, 0x00	; 0
     eae:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodhi4>
     eb2:	c0 96       	adiw	r24, 0x30	; 48
     eb4:	90 93 e2 02 	sts	0x02E2, r25
     eb8:	80 93 e1 02 	sts	0x02E1, r24
		lcd_wr_char(hundred);
     ebc:	0e 94 b3 06 	call	0xd66	; 0xd66 <lcd_wr_char>
		flag=1;
     ec0:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     ec2:	c2 30       	cpi	r28, 0x02	; 2
     ec4:	d1 05       	cpc	r29, r1
     ec6:	11 f0       	breq	.+4      	; 0xecc <lcd_print+0xb6>
     ec8:	81 30       	cpi	r24, 0x01	; 1
     eca:	b1 f4       	brne	.+44     	; 0xef8 <lcd_print+0xe2>
	{
		temp = value/10;
     ecc:	2a e0       	ldi	r18, 0x0A	; 10
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	c8 01       	movw	r24, r16
     ed2:	b9 01       	movw	r22, r18
     ed4:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodhi4>
     ed8:	cb 01       	movw	r24, r22
     eda:	70 93 71 02 	sts	0x0271, r23
     ede:	60 93 70 02 	sts	0x0270, r22
		tens = temp%10 + 48;
     ee2:	b9 01       	movw	r22, r18
     ee4:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodhi4>
     ee8:	c0 96       	adiw	r24, 0x30	; 48
     eea:	90 93 b5 02 	sts	0x02B5, r25
     eee:	80 93 b4 02 	sts	0x02B4, r24
		lcd_wr_char(tens);
     ef2:	0e 94 b3 06 	call	0xd66	; 0xd66 <lcd_wr_char>
		flag=1;
     ef6:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     ef8:	c1 30       	cpi	r28, 0x01	; 1
     efa:	d1 05       	cpc	r29, r1
     efc:	11 f0       	breq	.+4      	; 0xf02 <lcd_print+0xec>
     efe:	81 30       	cpi	r24, 0x01	; 1
     f00:	61 f4       	brne	.+24     	; 0xf1a <lcd_print+0x104>
	{
		unit = value%10 + 48;
     f02:	c8 01       	movw	r24, r16
     f04:	6a e0       	ldi	r22, 0x0A	; 10
     f06:	70 e0       	ldi	r23, 0x00	; 0
     f08:	0e 94 99 13 	call	0x2732	; 0x2732 <__udivmodhi4>
     f0c:	c0 96       	adiw	r24, 0x30	; 48
     f0e:	90 93 f1 02 	sts	0x02F1, r25
     f12:	80 93 f0 02 	sts	0x02F0, r24
		lcd_wr_char(unit);
     f16:	0e 94 b3 06 	call	0xd66	; 0xd66 <lcd_wr_char>
	}
	if(digits>5)
     f1a:	c6 30       	cpi	r28, 0x06	; 6
     f1c:	d1 05       	cpc	r29, r1
     f1e:	1c f0       	brlt	.+6      	; 0xf26 <lcd_print+0x110>
	{
		lcd_wr_char('E');
     f20:	85 e4       	ldi	r24, 0x45	; 69
     f22:	0e 94 b3 06 	call	0xd66	; 0xd66 <lcd_wr_char>
	}
	
}
     f26:	df 91       	pop	r29
     f28:	cf 91       	pop	r28
     f2a:	1f 91       	pop	r17
     f2c:	0f 91       	pop	r16
     f2e:	08 95       	ret

00000f30 <lcd_port_config>:

int l=0;
//Function to configure LCD port
void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
     f30:	87 b1       	in	r24, 0x07	; 7
     f32:	87 6f       	ori	r24, 0xF7	; 247
     f34:	87 b9       	out	0x07, r24	; 7
 PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
     f36:	88 b1       	in	r24, 0x08	; 8
     f38:	80 78       	andi	r24, 0x80	; 128
     f3a:	88 b9       	out	0x08, r24	; 8
}
     f3c:	08 95       	ret

00000f3e <adc_pin_config>:

//ADC pin configuration
void adc_pin_config (void)
{
 DDRF = 0x00;
     f3e:	10 ba       	out	0x10, r1	; 16
 PORTF = 0x00;
     f40:	11 ba       	out	0x11, r1	; 17
 DDRK = 0x00;
     f42:	10 92 07 01 	sts	0x0107, r1
 PORTK = 0x00;
     f46:	10 92 08 01 	sts	0x0108, r1
}
     f4a:	08 95       	ret

00000f4c <motion_pin_config>:

//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
 DDRA = DDRA | 0x0F;
     f4c:	81 b1       	in	r24, 0x01	; 1
     f4e:	8f 60       	ori	r24, 0x0F	; 15
     f50:	81 b9       	out	0x01, r24	; 1
 PORTA = PORTA & 0xF0;
     f52:	82 b1       	in	r24, 0x02	; 2
     f54:	80 7f       	andi	r24, 0xF0	; 240
     f56:	82 b9       	out	0x02, r24	; 2
 DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
     f58:	ea e0       	ldi	r30, 0x0A	; 10
     f5a:	f1 e0       	ldi	r31, 0x01	; 1
     f5c:	80 81       	ld	r24, Z
     f5e:	88 61       	ori	r24, 0x18	; 24
     f60:	80 83       	st	Z, r24
 PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
     f62:	eb e0       	ldi	r30, 0x0B	; 11
     f64:	f1 e0       	ldi	r31, 0x01	; 1
     f66:	80 81       	ld	r24, Z
     f68:	88 61       	ori	r24, 0x18	; 24
     f6a:	80 83       	st	Z, r24
}
     f6c:	08 95       	ret

00000f6e <port_init>:

//Function to Initialize PORTS
void port_init()
{
	lcd_port_config();
     f6e:	0e 94 98 07 	call	0xf30	; 0xf30 <lcd_port_config>
	adc_pin_config();
     f72:	0e 94 9f 07 	call	0xf3e	; 0xf3e <adc_pin_config>
	motion_pin_config();
     f76:	0e 94 a6 07 	call	0xf4c	; 0xf4c <motion_pin_config>
	buzzer_pin_config();
     f7a:	0e 94 20 01 	call	0x240	; 0x240 <buzzer_pin_config>
}
     f7e:	08 95       	ret

00000f80 <timer5_init>:
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
	TCCR5B = 0x00;	//Stop
     f80:	e1 e2       	ldi	r30, 0x21	; 33
     f82:	f1 e0       	ldi	r31, 0x01	; 1
     f84:	10 82       	st	Z, r1
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
     f86:	8f ef       	ldi	r24, 0xFF	; 255
     f88:	80 93 25 01 	sts	0x0125, r24
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
     f8c:	91 e0       	ldi	r25, 0x01	; 1
     f8e:	90 93 24 01 	sts	0x0124, r25
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
     f92:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
     f96:	80 93 28 01 	sts	0x0128, r24
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
     f9a:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
     f9e:	80 93 2a 01 	sts	0x012A, r24
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
     fa2:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
     fa6:	80 93 2c 01 	sts	0x012C, r24
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
     faa:	89 ea       	ldi	r24, 0xA9	; 169
     fac:	80 93 20 01 	sts	0x0120, r24
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/

	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
     fb0:	8b e0       	ldi	r24, 0x0B	; 11
     fb2:	80 83       	st	Z, r24
}
     fb4:	08 95       	ret

00000fb6 <adc_init>:

void adc_init()
{
	ADCSRA = 0x00;
     fb6:	ea e7       	ldi	r30, 0x7A	; 122
     fb8:	f0 e0       	ldi	r31, 0x00	; 0
     fba:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
     fbc:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     fc0:	80 e2       	ldi	r24, 0x20	; 32
     fc2:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
     fc6:	80 e8       	ldi	r24, 0x80	; 128
     fc8:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     fca:	86 e8       	ldi	r24, 0x86	; 134
     fcc:	80 83       	st	Z, r24
}
     fce:	08 95       	ret

00000fd0 <ADC_Conversion>:

//Function For ADC Conversion
unsigned char ADC_Conversion(unsigned char Ch)
{
	unsigned char a;
	if(Ch>7)
     fd0:	88 30       	cpi	r24, 0x08	; 8
     fd2:	18 f0       	brcs	.+6      	; 0xfda <ADC_Conversion+0xa>
	{
		ADCSRB = 0x08;
     fd4:	98 e0       	ldi	r25, 0x08	; 8
     fd6:	90 93 7b 00 	sts	0x007B, r25
	}
	Ch = Ch & 0x07;
     fda:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;
     fdc:	80 62       	ori	r24, 0x20	; 32
     fde:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     fe2:	ea e7       	ldi	r30, 0x7A	; 122
     fe4:	f0 e0       	ldi	r31, 0x00	; 0
     fe6:	80 81       	ld	r24, Z
     fe8:	80 64       	ori	r24, 0x40	; 64
     fea:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for conversion to complete
     fec:	80 81       	ld	r24, Z
     fee:	84 ff       	sbrs	r24, 4
     ff0:	fd cf       	rjmp	.-6      	; 0xfec <ADC_Conversion+0x1c>
	a=ADCH;
     ff2:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     ff6:	ea e7       	ldi	r30, 0x7A	; 122
     ff8:	f0 e0       	ldi	r31, 0x00	; 0
     ffa:	90 81       	ld	r25, Z
     ffc:	90 61       	ori	r25, 0x10	; 16
     ffe:	90 83       	st	Z, r25
	ADCSRB = 0x00;
    1000:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
    1004:	08 95       	ret

00001006 <print_sensor>:


//Function To Print Sesor Values At Desired Row And Coloumn Location on LCD
void print_sensor(char row, char coloumn,unsigned char channel)
{
    1006:	cf 93       	push	r28
    1008:	df 93       	push	r29
    100a:	d8 2f       	mov	r29, r24
    100c:	c6 2f       	mov	r28, r22
    100e:	84 2f       	mov	r24, r20

	ADC_Value = ADC_Conversion(channel);
    1010:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <ADC_Conversion>
    1014:	48 2f       	mov	r20, r24
    1016:	80 93 ad 02 	sts	0x02AD, r24
	lcd_print(row, coloumn, ADC_Value, 3);
    101a:	8d 2f       	mov	r24, r29
    101c:	6c 2f       	mov	r22, r28
    101e:	50 e0       	ldi	r21, 0x00	; 0
    1020:	23 e0       	ldi	r18, 0x03	; 3
    1022:	30 e0       	ldi	r19, 0x00	; 0
    1024:	0e 94 0b 07 	call	0xe16	; 0xe16 <lcd_print>
}
    1028:	df 91       	pop	r29
    102a:	cf 91       	pop	r28
    102c:	08 95       	ret

0000102e <velocity>:

//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
    102e:	80 93 28 01 	sts	0x0128, r24
	OCR5BL = (unsigned char)right_motor;
    1032:	60 93 2a 01 	sts	0x012A, r22
}
    1036:	08 95       	ret

00001038 <motion_set>:
void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
    1038:	92 b1       	in	r25, 0x02	; 2
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
    103a:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
    103c:	8f 70       	andi	r24, 0x0F	; 15
 PortARestore = PORTA; 		// reading the PORTA original status
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
    103e:	98 2b       	or	r25, r24
 PORTA = PortARestore; 		// executing the command
    1040:	92 b9       	out	0x02, r25	; 2
}
    1042:	08 95       	ret

00001044 <back>:
void back (void) //both wheels backward
{
	motion_set(0x09);
    1044:	89 e0       	ldi	r24, 0x09	; 9
    1046:	0e 94 1c 08 	call	0x1038	; 0x1038 <motion_set>
}
    104a:	08 95       	ret

0000104c <forward>:
void forward (void)
{
  motion_set (0x06);
    104c:	86 e0       	ldi	r24, 0x06	; 6
    104e:	0e 94 1c 08 	call	0x1038	; 0x1038 <motion_set>
}
    1052:	08 95       	ret

00001054 <success>:
	}
}


void success(int x)
{
    1054:	cf 93       	push	r28
    1056:	df 93       	push	r29
    1058:	ec 01       	movw	r28, r24
	switch (x)
    105a:	82 30       	cpi	r24, 0x02	; 2
    105c:	91 05       	cpc	r25, r1
    105e:	b1 f0       	breq	.+44     	; 0x108c <success+0x38>
    1060:	83 30       	cpi	r24, 0x03	; 3
    1062:	91 05       	cpc	r25, r1
    1064:	19 f1       	breq	.+70     	; 0x10ac <success+0x58>
    1066:	81 30       	cpi	r24, 0x01	; 1
    1068:	91 05       	cpc	r25, r1
    106a:	79 f5       	brne	.+94     	; 0x10ca <success+0x76>
	{
		case 1:
		forward();
    106c:	0e 94 26 08 	call	0x104c	; 0x104c <forward>
		velocity(125,125);
    1070:	8d e7       	ldi	r24, 0x7D	; 125
    1072:	6d e7       	ldi	r22, 0x7D	; 125
    1074:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
    1078:	8f ef       	ldi	r24, 0xFF	; 255
    107a:	9f e7       	ldi	r25, 0x7F	; 127
    107c:	a4 e0       	ldi	r26, 0x04	; 4
    107e:	81 50       	subi	r24, 0x01	; 1
    1080:	90 40       	sbci	r25, 0x00	; 0
    1082:	a0 40       	sbci	r26, 0x00	; 0
    1084:	e1 f7       	brne	.-8      	; 0x107e <success+0x2a>
    1086:	00 c0       	rjmp	.+0      	; 0x1088 <success+0x34>
    1088:	00 00       	nop
    108a:	1f c0       	rjmp	.+62     	; 0x10ca <success+0x76>
		_delay_ms(100);
		break;
		case 2:
		forward();
    108c:	0e 94 26 08 	call	0x104c	; 0x104c <forward>
		velocity(130,30);
    1090:	82 e8       	ldi	r24, 0x82	; 130
    1092:	6e e1       	ldi	r22, 0x1E	; 30
    1094:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
    1098:	8f ef       	ldi	r24, 0xFF	; 255
    109a:	9f e3       	ldi	r25, 0x3F	; 63
    109c:	af e2       	ldi	r26, 0x2F	; 47
    109e:	81 50       	subi	r24, 0x01	; 1
    10a0:	90 40       	sbci	r25, 0x00	; 0
    10a2:	a0 40       	sbci	r26, 0x00	; 0
    10a4:	e1 f7       	brne	.-8      	; 0x109e <success+0x4a>
    10a6:	00 c0       	rjmp	.+0      	; 0x10a8 <success+0x54>
    10a8:	00 00       	nop
    10aa:	0f c0       	rjmp	.+30     	; 0x10ca <success+0x76>
		_delay_ms(1050);
		
		break;
		case 3:
		forward();
    10ac:	0e 94 26 08 	call	0x104c	; 0x104c <forward>
		velocity(30,130);
    10b0:	8e e1       	ldi	r24, 0x1E	; 30
    10b2:	62 e8       	ldi	r22, 0x82	; 130
    10b4:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
    10b8:	8f ef       	ldi	r24, 0xFF	; 255
    10ba:	9f e3       	ldi	r25, 0x3F	; 63
    10bc:	af e2       	ldi	r26, 0x2F	; 47
    10be:	81 50       	subi	r24, 0x01	; 1
    10c0:	90 40       	sbci	r25, 0x00	; 0
    10c2:	a0 40       	sbci	r26, 0x00	; 0
    10c4:	e1 f7       	brne	.-8      	; 0x10be <success+0x6a>
    10c6:	00 c0       	rjmp	.+0      	; 0x10c8 <success+0x74>
    10c8:	00 00       	nop
	}
	
	while(1)
	{
		
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    10ca:	83 e0       	ldi	r24, 0x03	; 3
    10cc:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <ADC_Conversion>
    10d0:	80 93 1b 02 	sts	0x021B, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    10d4:	82 e0       	ldi	r24, 0x02	; 2
    10d6:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <ADC_Conversion>
    10da:	80 93 1a 02 	sts	0x021A, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    10de:	81 e0       	ldi	r24, 0x01	; 1
    10e0:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <ADC_Conversion>
    10e4:	80 93 19 02 	sts	0x0219, r24

		

		print_sensor(1,1,3);	//Prints value of White Line Sensor1
    10e8:	81 e0       	ldi	r24, 0x01	; 1
    10ea:	61 e0       	ldi	r22, 0x01	; 1
    10ec:	43 e0       	ldi	r20, 0x03	; 3
    10ee:	0e 94 03 08 	call	0x1006	; 0x1006 <print_sensor>
		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
    10f2:	81 e0       	ldi	r24, 0x01	; 1
    10f4:	65 e0       	ldi	r22, 0x05	; 5
    10f6:	42 e0       	ldi	r20, 0x02	; 2
    10f8:	0e 94 03 08 	call	0x1006	; 0x1006 <print_sensor>
		print_sensor(1,9,1);	//Prints Value of White Line Sensor3
    10fc:	81 e0       	ldi	r24, 0x01	; 1
    10fe:	69 e0       	ldi	r22, 0x09	; 9
    1100:	41 e0       	ldi	r20, 0x01	; 1
    1102:	0e 94 03 08 	call	0x1006	; 0x1006 <print_sensor>

		if(Center_white_line<0x28 && Left_white_line<0x28 && Right_white_line<0x28)
    1106:	80 91 1a 02 	lds	r24, 0x021A
    110a:	88 32       	cpi	r24, 0x28	; 40
    110c:	08 f0       	brcs	.+2      	; 0x1110 <success+0xbc>
    110e:	42 c0       	rjmp	.+132    	; 0x1194 <success+0x140>
    1110:	90 91 1b 02 	lds	r25, 0x021B
    1114:	98 32       	cpi	r25, 0x28	; 40
    1116:	08 f0       	brcs	.+2      	; 0x111a <success+0xc6>
    1118:	51 c0       	rjmp	.+162    	; 0x11bc <success+0x168>
    111a:	80 91 19 02 	lds	r24, 0x0219
    111e:	88 32       	cpi	r24, 0x28	; 40
    1120:	e8 f5       	brcc	.+122    	; 0x119c <success+0x148>
		{
			switch (x)
    1122:	c2 30       	cpi	r28, 0x02	; 2
    1124:	d1 05       	cpc	r29, r1
    1126:	b1 f0       	breq	.+44     	; 0x1154 <success+0x100>
    1128:	c3 30       	cpi	r28, 0x03	; 3
    112a:	d1 05       	cpc	r29, r1
    112c:	19 f1       	breq	.+70     	; 0x1174 <success+0x120>
    112e:	c1 30       	cpi	r28, 0x01	; 1
    1130:	d1 05       	cpc	r29, r1
    1132:	59 f6       	brne	.-106    	; 0x10ca <success+0x76>
			{
				case 1:
				forward();
    1134:	0e 94 26 08 	call	0x104c	; 0x104c <forward>
				velocity(125,125);
    1138:	8d e7       	ldi	r24, 0x7D	; 125
    113a:	6d e7       	ldi	r22, 0x7D	; 125
    113c:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
    1140:	8f ef       	ldi	r24, 0xFF	; 255
    1142:	9f e7       	ldi	r25, 0x7F	; 127
    1144:	a4 e0       	ldi	r26, 0x04	; 4
    1146:	81 50       	subi	r24, 0x01	; 1
    1148:	90 40       	sbci	r25, 0x00	; 0
    114a:	a0 40       	sbci	r26, 0x00	; 0
    114c:	e1 f7       	brne	.-8      	; 0x1146 <success+0xf2>
    114e:	00 c0       	rjmp	.+0      	; 0x1150 <success+0xfc>
    1150:	00 00       	nop
    1152:	bb cf       	rjmp	.-138    	; 0x10ca <success+0x76>
				_delay_ms(100);
				break;
				case 2:
				forward();
    1154:	0e 94 26 08 	call	0x104c	; 0x104c <forward>
				velocity(130,30);
    1158:	82 e8       	ldi	r24, 0x82	; 130
    115a:	6e e1       	ldi	r22, 0x1E	; 30
    115c:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
    1160:	8f ef       	ldi	r24, 0xFF	; 255
    1162:	9f e7       	ldi	r25, 0x7F	; 127
    1164:	a4 e0       	ldi	r26, 0x04	; 4
    1166:	81 50       	subi	r24, 0x01	; 1
    1168:	90 40       	sbci	r25, 0x00	; 0
    116a:	a0 40       	sbci	r26, 0x00	; 0
    116c:	e1 f7       	brne	.-8      	; 0x1166 <success+0x112>
    116e:	00 c0       	rjmp	.+0      	; 0x1170 <success+0x11c>
    1170:	00 00       	nop
    1172:	ab cf       	rjmp	.-170    	; 0x10ca <success+0x76>
				_delay_ms(100);
				
				break;
				case 3:
				forward();
    1174:	0e 94 26 08 	call	0x104c	; 0x104c <forward>
				velocity(30,130);
    1178:	8e e1       	ldi	r24, 0x1E	; 30
    117a:	62 e8       	ldi	r22, 0x82	; 130
    117c:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
    1180:	8f ef       	ldi	r24, 0xFF	; 255
    1182:	9f e7       	ldi	r25, 0x7F	; 127
    1184:	a4 e0       	ldi	r26, 0x04	; 4
    1186:	81 50       	subi	r24, 0x01	; 1
    1188:	90 40       	sbci	r25, 0x00	; 0
    118a:	a0 40       	sbci	r26, 0x00	; 0
    118c:	e1 f7       	brne	.-8      	; 0x1186 <success+0x132>
    118e:	00 c0       	rjmp	.+0      	; 0x1190 <success+0x13c>
    1190:	00 00       	nop
    1192:	9b cf       	rjmp	.-202    	; 0x10ca <success+0x76>
		}


		

		else if((Left_white_line<0x28)) //&& (flag==0))
    1194:	90 91 1b 02 	lds	r25, 0x021B
    1198:	98 32       	cpi	r25, 0x28	; 40
    119a:	80 f4       	brcc	.+32     	; 0x11bc <success+0x168>
		{
			//flag=1;
			forward();
    119c:	0e 94 26 08 	call	0x104c	; 0x104c <forward>
			velocity(130,30);
    11a0:	82 e8       	ldi	r24, 0x82	; 130
    11a2:	6e e1       	ldi	r22, 0x1E	; 30
    11a4:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
    11a8:	8f ef       	ldi	r24, 0xFF	; 255
    11aa:	9f e7       	ldi	r25, 0x7F	; 127
    11ac:	ad e0       	ldi	r26, 0x0D	; 13
    11ae:	81 50       	subi	r24, 0x01	; 1
    11b0:	90 40       	sbci	r25, 0x00	; 0
    11b2:	a0 40       	sbci	r26, 0x00	; 0
    11b4:	e1 f7       	brne	.-8      	; 0x11ae <success+0x15a>
    11b6:	00 c0       	rjmp	.+0      	; 0x11b8 <success+0x164>
    11b8:	00 00       	nop
    11ba:	26 c0       	rjmp	.+76     	; 0x1208 <success+0x1b4>
			_delay_ms(300);
			break;
		}

		else if((Right_white_line<0x28))// && (flag==0))
    11bc:	90 91 19 02 	lds	r25, 0x0219
    11c0:	98 32       	cpi	r25, 0x28	; 40
    11c2:	80 f4       	brcc	.+32     	; 0x11e4 <success+0x190>
		{
			//	flag=1;
			
			forward();
    11c4:	0e 94 26 08 	call	0x104c	; 0x104c <forward>
			velocity(30,130);
    11c8:	8e e1       	ldi	r24, 0x1E	; 30
    11ca:	62 e8       	ldi	r22, 0x82	; 130
    11cc:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
    11d0:	8f ef       	ldi	r24, 0xFF	; 255
    11d2:	9f e7       	ldi	r25, 0x7F	; 127
    11d4:	ad e0       	ldi	r26, 0x0D	; 13
    11d6:	81 50       	subi	r24, 0x01	; 1
    11d8:	90 40       	sbci	r25, 0x00	; 0
    11da:	a0 40       	sbci	r26, 0x00	; 0
    11dc:	e1 f7       	brne	.-8      	; 0x11d6 <success+0x182>
    11de:	00 c0       	rjmp	.+0      	; 0x11e0 <success+0x18c>
    11e0:	00 00       	nop
    11e2:	12 c0       	rjmp	.+36     	; 0x1208 <success+0x1b4>
			_delay_ms(300);
			break;
		}
		else if(Center_white_line>0x28)
    11e4:	89 32       	cpi	r24, 0x29	; 41
    11e6:	08 f4       	brcc	.+2      	; 0x11ea <success+0x196>
    11e8:	70 cf       	rjmp	.-288    	; 0x10ca <success+0x76>
		{
			//flag=1;
			forward();
    11ea:	0e 94 26 08 	call	0x104c	; 0x104c <forward>
			velocity(135,135);
    11ee:	87 e8       	ldi	r24, 0x87	; 135
    11f0:	67 e8       	ldi	r22, 0x87	; 135
    11f2:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
    11f6:	8f ef       	ldi	r24, 0xFF	; 255
    11f8:	9f e7       	ldi	r25, 0x7F	; 127
    11fa:	ad e0       	ldi	r26, 0x0D	; 13
    11fc:	81 50       	subi	r24, 0x01	; 1
    11fe:	90 40       	sbci	r25, 0x00	; 0
    1200:	a0 40       	sbci	r26, 0x00	; 0
    1202:	e1 f7       	brne	.-8      	; 0x11fc <success+0x1a8>
    1204:	00 c0       	rjmp	.+0      	; 0x1206 <success+0x1b2>
    1206:	00 00       	nop
		
		

	}
	
    1208:	df 91       	pop	r29
    120a:	cf 91       	pop	r28
    120c:	08 95       	ret

0000120e <stop>:

void stop (void)
{
  motion_set (0x00);
    120e:	80 e0       	ldi	r24, 0x00	; 0
    1210:	0e 94 1c 08 	call	0x1038	; 0x1038 <motion_set>
}
    1214:	08 95       	ret

00001216 <init_devices>:

void init_devices (void)
{
 	cli(); //Clears the global interrupts
    1216:	f8 94       	cli
	port_init();
    1218:	0e 94 b7 07 	call	0xf6e	; 0xf6e <port_init>
	adc_init();
    121c:	0e 94 db 07 	call	0xfb6	; 0xfb6 <adc_init>
	timer5_init();
    1220:	0e 94 c0 07 	call	0xf80	; 0xf80 <timer5_init>
	sei();   //Enables the global interrupts
    1224:	78 94       	sei
}
    1226:	08 95       	ret

00001228 <line_follower>:

//Main Function
int line_follower()
{
    1228:	cf 93       	push	r28
	buzzer_pin_config();
    122a:	0e 94 20 01 	call	0x240	; 0x240 <buzzer_pin_config>
		while(1)
	{*/
		
	

		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    122e:	83 e0       	ldi	r24, 0x03	; 3
    1230:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <ADC_Conversion>
    1234:	80 93 1b 02 	sts	0x021B, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    1238:	82 e0       	ldi	r24, 0x02	; 2
    123a:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <ADC_Conversion>
    123e:	80 93 1a 02 	sts	0x021A, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    1242:	81 e0       	ldi	r24, 0x01	; 1
    1244:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <ADC_Conversion>
    1248:	80 93 19 02 	sts	0x0219, r24

		flag=0;
    124c:	10 92 1c 02 	sts	0x021C, r1

		print_sensor(1,1,3);	//Prints value of White Line Sensor1
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	61 e0       	ldi	r22, 0x01	; 1
    1254:	43 e0       	ldi	r20, 0x03	; 3
    1256:	0e 94 03 08 	call	0x1006	; 0x1006 <print_sensor>
		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
    125a:	81 e0       	ldi	r24, 0x01	; 1
    125c:	65 e0       	ldi	r22, 0x05	; 5
    125e:	42 e0       	ldi	r20, 0x02	; 2
    1260:	0e 94 03 08 	call	0x1006	; 0x1006 <print_sensor>
		print_sensor(1,9,1);	//Prints Value of White Line Sensor3
    1264:	81 e0       	ldi	r24, 0x01	; 1
    1266:	69 e0       	ldi	r22, 0x09	; 9
    1268:	41 e0       	ldi	r20, 0x01	; 1
    126a:	0e 94 03 08 	call	0x1006	; 0x1006 <print_sensor>



		if(Center_white_line>0x28)
    126e:	80 91 1a 02 	lds	r24, 0x021A
    1272:	89 32       	cpi	r24, 0x29	; 41
    1274:	48 f0       	brcs	.+18     	; 0x1288 <line_follower+0x60>
		{
			flag=1;
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	80 93 1c 02 	sts	0x021C, r24
			forward();
    127c:	0e 94 26 08 	call	0x104c	; 0x104c <forward>
			velocity(110,110);
    1280:	8e e6       	ldi	r24, 0x6E	; 110
    1282:	6e e6       	ldi	r22, 0x6E	; 110
    1284:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
		}

		if((Left_white_line<0x28) && (flag==0))
    1288:	80 91 1b 02 	lds	r24, 0x021B
    128c:	88 32       	cpi	r24, 0x28	; 40
    128e:	68 f4       	brcc	.+26     	; 0x12aa <line_follower+0x82>
    1290:	80 91 1c 02 	lds	r24, 0x021C
    1294:	88 23       	and	r24, r24
    1296:	49 f4       	brne	.+18     	; 0x12aa <line_follower+0x82>
		{
			flag=1;
    1298:	81 e0       	ldi	r24, 0x01	; 1
    129a:	80 93 1c 02 	sts	0x021C, r24
			forward();
    129e:	0e 94 26 08 	call	0x104c	; 0x104c <forward>
			velocity(130,0);
    12a2:	82 e8       	ldi	r24, 0x82	; 130
    12a4:	60 e0       	ldi	r22, 0x00	; 0
    12a6:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
		}

		if((Right_white_line<0x28) && (flag==0))
    12aa:	80 91 19 02 	lds	r24, 0x0219
    12ae:	88 32       	cpi	r24, 0x28	; 40
    12b0:	68 f4       	brcc	.+26     	; 0x12cc <line_follower+0xa4>
    12b2:	80 91 1c 02 	lds	r24, 0x021C
    12b6:	88 23       	and	r24, r24
    12b8:	49 f4       	brne	.+18     	; 0x12cc <line_follower+0xa4>
		{
			flag=1;
    12ba:	81 e0       	ldi	r24, 0x01	; 1
    12bc:	80 93 1c 02 	sts	0x021C, r24
			
			forward();
    12c0:	0e 94 26 08 	call	0x104c	; 0x104c <forward>
			velocity(0,130);
    12c4:	80 e0       	ldi	r24, 0x00	; 0
    12c6:	62 e8       	ldi	r22, 0x82	; 130
    12c8:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
		}

		if(Center_white_line>0x28 && Left_white_line>0x28 && Right_white_line>0x28)
    12cc:	80 91 1a 02 	lds	r24, 0x021A
    12d0:	89 32       	cpi	r24, 0x29	; 41
    12d2:	08 f4       	brcc	.+2      	; 0x12d6 <line_follower+0xae>
    12d4:	df c0       	rjmp	.+446    	; 0x1494 <line_follower+0x26c>
    12d6:	80 91 1b 02 	lds	r24, 0x021B
    12da:	89 32       	cpi	r24, 0x29	; 41
    12dc:	08 f4       	brcc	.+2      	; 0x12e0 <line_follower+0xb8>
    12de:	da c0       	rjmp	.+436    	; 0x1494 <line_follower+0x26c>
    12e0:	80 91 19 02 	lds	r24, 0x0219
    12e4:	89 32       	cpi	r24, 0x29	; 41
    12e6:	08 f4       	brcc	.+2      	; 0x12ea <line_follower+0xc2>
    12e8:	d5 c0       	rjmp	.+426    	; 0x1494 <line_follower+0x26c>
		{
			stop1();
    12ea:	0e 94 38 04 	call	0x870	; 0x870 <stop1>
    12ee:	8f ef       	ldi	r24, 0xFF	; 255
    12f0:	9f e7       	ldi	r25, 0x7F	; 127
    12f2:	a6 e1       	ldi	r26, 0x16	; 22
    12f4:	81 50       	subi	r24, 0x01	; 1
    12f6:	90 40       	sbci	r25, 0x00	; 0
    12f8:	a0 40       	sbci	r26, 0x00	; 0
    12fa:	e1 f7       	brne	.-8      	; 0x12f4 <line_follower+0xcc>
    12fc:	00 c0       	rjmp	.+0      	; 0x12fe <line_follower+0xd6>
    12fe:	00 00       	nop
			_delay_ms(500);
			lcd_print(2,1,path1.path[l],3);
    1300:	e0 91 17 02 	lds	r30, 0x0217
    1304:	f0 91 18 02 	lds	r31, 0x0218
    1308:	ee 0f       	add	r30, r30
    130a:	ff 1f       	adc	r31, r31
    130c:	e5 58       	subi	r30, 0x85	; 133
    130e:	fd 4f       	sbci	r31, 0xFD	; 253
    1310:	40 81       	ld	r20, Z
    1312:	51 81       	ldd	r21, Z+1	; 0x01
    1314:	82 e0       	ldi	r24, 0x02	; 2
    1316:	61 e0       	ldi	r22, 0x01	; 1
    1318:	23 e0       	ldi	r18, 0x03	; 3
    131a:	30 e0       	ldi	r19, 0x00	; 0
    131c:	0e 94 0b 07 	call	0xe16	; 0xe16 <lcd_print>
			l++;
    1320:	80 91 17 02 	lds	r24, 0x0217
    1324:	90 91 18 02 	lds	r25, 0x0218
    1328:	01 96       	adiw	r24, 0x01	; 1
    132a:	90 93 18 02 	sts	0x0218, r25
    132e:	80 93 17 02 	sts	0x0217, r24
			if(stage==2)
    1332:	80 91 07 02 	lds	r24, 0x0207
    1336:	90 91 08 02 	lds	r25, 0x0208
    133a:	82 30       	cpi	r24, 0x02	; 2
    133c:	91 05       	cpc	r25, r1
    133e:	09 f0       	breq	.+2      	; 0x1342 <line_follower+0x11a>
    1340:	a7 c0       	rjmp	.+334    	; 0x1490 <line_follower+0x268>
    1342:	cf e5       	ldi	r28, 0x5F	; 95
			{	
				for(int i=95;i<=180;i=i+3)//+90//right
				{	
					init_devices_sharp();
    1344:	0e 94 2f 06 	call	0xc5e	; 0xc5e <init_devices_sharp>
					sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
    1348:	8b e0       	ldi	r24, 0x0B	; 11
    134a:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <ADC_Conversion>
    134e:	80 93 ef 02 	sts	0x02EF, r24
					value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calsulated in a variable "value".
    1352:	0e 94 ef 05 	call	0xbde	; 0xbde <Sharp_GP2D12_estimation>
    1356:	90 93 09 03 	sts	0x0309, r25
    135a:	80 93 08 03 	sts	0x0308, r24
    135e:	8f ef       	ldi	r24, 0xFF	; 255
    1360:	9f e7       	ldi	r25, 0x7F	; 127
    1362:	a4 e0       	ldi	r26, 0x04	; 4
    1364:	81 50       	subi	r24, 0x01	; 1
    1366:	90 40       	sbci	r25, 0x00	; 0
    1368:	a0 40       	sbci	r26, 0x00	; 0
    136a:	e1 f7       	brne	.-8      	; 0x1364 <line_follower+0x13c>
    136c:	00 c0       	rjmp	.+0      	; 0x136e <line_follower+0x146>
    136e:	00 00       	nop
					_delay_ms(100);
					init_devices_servo();
    1370:	0e 94 4d 05 	call	0xa9a	; 0xa9a <init_devices_servo>
					servo_1(i);
    1374:	8c 2f       	mov	r24, r28
    1376:	0e 94 54 05 	call	0xaa8	; 0xaa8 <servo_1>
    137a:	af ef       	ldi	r26, 0xFF	; 255
    137c:	bf e8       	ldi	r27, 0x8F	; 143
    137e:	11 97       	sbiw	r26, 0x01	; 1
    1380:	f1 f7       	brne	.-4      	; 0x137e <line_follower+0x156>
    1382:	00 c0       	rjmp	.+0      	; 0x1384 <line_follower+0x15c>
    1384:	00 00       	nop
					_delay_ms(10);
					
					
					if(value<90 && value>0)
    1386:	80 91 08 03 	lds	r24, 0x0308
    138a:	90 91 09 03 	lds	r25, 0x0309
    138e:	01 97       	sbiw	r24, 0x01	; 1
    1390:	89 35       	cpi	r24, 0x59	; 89
    1392:	91 05       	cpc	r25, r1
    1394:	30 f5       	brcc	.+76     	; 0x13e2 <line_follower+0x1ba>
					{
						servo_1_free();
    1396:	0e 94 a2 05 	call	0xb44	; 0xb44 <servo_1_free>
    139a:	8f ef       	ldi	r24, 0xFF	; 255
    139c:	9f ef       	ldi	r25, 0xFF	; 255
    139e:	ac e2       	ldi	r26, 0x2C	; 44
    13a0:	81 50       	subi	r24, 0x01	; 1
    13a2:	90 40       	sbci	r25, 0x00	; 0
    13a4:	a0 40       	sbci	r26, 0x00	; 0
    13a6:	e1 f7       	brne	.-8      	; 0x13a0 <line_follower+0x178>
    13a8:	00 c0       	rjmp	.+0      	; 0x13aa <line_follower+0x182>
    13aa:	00 00       	nop
						_delay_ms(1000);
						//buzzer_beep();
						side=1;
    13ac:	81 e0       	ldi	r24, 0x01	; 1
    13ae:	80 93 1d 02 	sts	0x021D, r24
						color_sensor_work();
    13b2:	0e 94 5f 0b 	call	0x16be	; 0x16be <color_sensor_work>
    13b6:	8f ef       	ldi	r24, 0xFF	; 255
    13b8:	9f ef       	ldi	r25, 0xFF	; 255
    13ba:	ac e2       	ldi	r26, 0x2C	; 44
    13bc:	81 50       	subi	r24, 0x01	; 1
    13be:	90 40       	sbci	r25, 0x00	; 0
    13c0:	a0 40       	sbci	r26, 0x00	; 0
    13c2:	e1 f7       	brne	.-8      	; 0x13bc <line_follower+0x194>
    13c4:	00 c0       	rjmp	.+0      	; 0x13c6 <line_follower+0x19e>
    13c6:	00 00       	nop
						
						_delay_ms(1000);
						do_task();
    13c8:	0e 94 d6 00 	call	0x1ac	; 0x1ac <do_task>
    13cc:	8f ef       	ldi	r24, 0xFF	; 255
    13ce:	9f e7       	ldi	r25, 0x7F	; 127
    13d0:	a6 e1       	ldi	r26, 0x16	; 22
    13d2:	81 50       	subi	r24, 0x01	; 1
    13d4:	90 40       	sbci	r25, 0x00	; 0
    13d6:	a0 40       	sbci	r26, 0x00	; 0
    13d8:	e1 f7       	brne	.-8      	; 0x13d2 <line_follower+0x1aa>
    13da:	00 c0       	rjmp	.+0      	; 0x13dc <line_follower+0x1b4>
    13dc:	00 00       	nop
		{
			stop1();
			_delay_ms(500);
			lcd_print(2,1,path1.path[l],3);
			l++;
			if(stage==2)
    13de:	ca e5       	ldi	r28, 0x5A	; 90
    13e0:	05 c0       	rjmp	.+10     	; 0x13ec <line_follower+0x1c4>
    13e2:	cd 5f       	subi	r28, 0xFD	; 253
			{	
				for(int i=95;i<=180;i=i+3)//+90//right
    13e4:	c6 3b       	cpi	r28, 0xB6	; 182
    13e6:	09 f0       	breq	.+2      	; 0x13ea <line_follower+0x1c2>
    13e8:	ad cf       	rjmp	.-166    	; 0x1344 <line_follower+0x11c>
    13ea:	f9 cf       	rjmp	.-14     	; 0x13de <line_follower+0x1b6>
				
				
				for(int i=90;i>=10;i--)//left//-90
				{	//buzzer_pin_config();
					
					init_devices_sharp();
    13ec:	0e 94 2f 06 	call	0xc5e	; 0xc5e <init_devices_sharp>
					sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
    13f0:	8b e0       	ldi	r24, 0x0B	; 11
    13f2:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <ADC_Conversion>
    13f6:	80 93 ef 02 	sts	0x02EF, r24
					value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calsulated in a variable "value".
    13fa:	0e 94 ef 05 	call	0xbde	; 0xbde <Sharp_GP2D12_estimation>
    13fe:	90 93 09 03 	sts	0x0309, r25
    1402:	80 93 08 03 	sts	0x0308, r24
    1406:	8f ef       	ldi	r24, 0xFF	; 255
    1408:	9f e7       	ldi	r25, 0x7F	; 127
    140a:	a4 e0       	ldi	r26, 0x04	; 4
    140c:	81 50       	subi	r24, 0x01	; 1
    140e:	90 40       	sbci	r25, 0x00	; 0
    1410:	a0 40       	sbci	r26, 0x00	; 0
    1412:	e1 f7       	brne	.-8      	; 0x140c <line_follower+0x1e4>
    1414:	00 c0       	rjmp	.+0      	; 0x1416 <line_follower+0x1ee>
    1416:	00 00       	nop
					_delay_ms(100);
					init_devices_servo();
    1418:	0e 94 4d 05 	call	0xa9a	; 0xa9a <init_devices_servo>
					servo_1(i);
    141c:	8c 2f       	mov	r24, r28
    141e:	0e 94 54 05 	call	0xaa8	; 0xaa8 <servo_1>
    1422:	af ef       	ldi	r26, 0xFF	; 255
    1424:	bf e8       	ldi	r27, 0x8F	; 143
    1426:	11 97       	sbiw	r26, 0x01	; 1
    1428:	f1 f7       	brne	.-4      	; 0x1426 <line_follower+0x1fe>
    142a:	00 c0       	rjmp	.+0      	; 0x142c <line_follower+0x204>
    142c:	00 00       	nop
					_delay_ms(10);
					
					
					
					if(value<90 && value>0)
    142e:	80 91 08 03 	lds	r24, 0x0308
    1432:	90 91 09 03 	lds	r25, 0x0309
    1436:	01 97       	sbiw	r24, 0x01	; 1
    1438:	89 35       	cpi	r24, 0x59	; 89
    143a:	91 05       	cpc	r25, r1
    143c:	28 f5       	brcc	.+74     	; 0x1488 <line_follower+0x260>
					{
						servo_1_free();
    143e:	0e 94 a2 05 	call	0xb44	; 0xb44 <servo_1_free>
    1442:	8f ef       	ldi	r24, 0xFF	; 255
    1444:	9f ef       	ldi	r25, 0xFF	; 255
    1446:	ac e2       	ldi	r26, 0x2C	; 44
    1448:	81 50       	subi	r24, 0x01	; 1
    144a:	90 40       	sbci	r25, 0x00	; 0
    144c:	a0 40       	sbci	r26, 0x00	; 0
    144e:	e1 f7       	brne	.-8      	; 0x1448 <line_follower+0x220>
    1450:	00 c0       	rjmp	.+0      	; 0x1452 <line_follower+0x22a>
    1452:	00 00       	nop
						_delay_ms(1000);
						//buzzer_beep();
						side=2;
    1454:	82 e0       	ldi	r24, 0x02	; 2
    1456:	80 93 1d 02 	sts	0x021D, r24
						color_sensor_work();
    145a:	0e 94 5f 0b 	call	0x16be	; 0x16be <color_sensor_work>
    145e:	8f ef       	ldi	r24, 0xFF	; 255
    1460:	9f ef       	ldi	r25, 0xFF	; 255
    1462:	ac e2       	ldi	r26, 0x2C	; 44
    1464:	81 50       	subi	r24, 0x01	; 1
    1466:	90 40       	sbci	r25, 0x00	; 0
    1468:	a0 40       	sbci	r26, 0x00	; 0
    146a:	e1 f7       	brne	.-8      	; 0x1464 <line_follower+0x23c>
    146c:	00 c0       	rjmp	.+0      	; 0x146e <line_follower+0x246>
    146e:	00 00       	nop
						
						_delay_ms(1000);
						do_task();
    1470:	0e 94 d6 00 	call	0x1ac	; 0x1ac <do_task>
    1474:	8f ef       	ldi	r24, 0xFF	; 255
    1476:	9f e7       	ldi	r25, 0x7F	; 127
    1478:	a6 e1       	ldi	r26, 0x16	; 22
    147a:	81 50       	subi	r24, 0x01	; 1
    147c:	90 40       	sbci	r25, 0x00	; 0
    147e:	a0 40       	sbci	r26, 0x00	; 0
    1480:	e1 f7       	brne	.-8      	; 0x147a <line_follower+0x252>
    1482:	00 c0       	rjmp	.+0      	; 0x1484 <line_follower+0x25c>
    1484:	00 00       	nop
    1486:	04 c0       	rjmp	.+8      	; 0x1490 <line_follower+0x268>
    1488:	c1 50       	subi	r28, 0x01	; 1
					}
					
				}
				
				
				for(int i=90;i>=10;i--)//left//-90
    148a:	c9 30       	cpi	r28, 0x09	; 9
    148c:	09 f0       	breq	.+2      	; 0x1490 <line_follower+0x268>
    148e:	ae cf       	rjmp	.-164    	; 0x13ec <line_follower+0x1c4>
				init_devices_servo();
				servo_1(i);
				_delay_ms(10);
			}
			servo_1_free();*/
			direction();
    1490:	0e 94 c9 0c 	call	0x1992	; 0x1992 <direction>
			
		
			
			
		}
		if(Center_white_line<0x28 && Left_white_line<0x28 && Right_white_line<0x28)
    1494:	80 91 1a 02 	lds	r24, 0x021A
    1498:	88 32       	cpi	r24, 0x28	; 40
    149a:	70 f4       	brcc	.+28     	; 0x14b8 <line_follower+0x290>
    149c:	80 91 1b 02 	lds	r24, 0x021B
    14a0:	88 32       	cpi	r24, 0x28	; 40
    14a2:	50 f4       	brcc	.+20     	; 0x14b8 <line_follower+0x290>
    14a4:	80 91 19 02 	lds	r24, 0x0219
    14a8:	88 32       	cpi	r24, 0x28	; 40
    14aa:	30 f4       	brcc	.+12     	; 0x14b8 <line_follower+0x290>
		{
			back();
    14ac:	0e 94 22 08 	call	0x1044	; 0x1044 <back>
			velocity(100,100);
    14b0:	84 e6       	ldi	r24, 0x64	; 100
    14b2:	64 e6       	ldi	r22, 0x64	; 100
    14b4:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
		}

	
    14b8:	cf 91       	pop	r28
    14ba:	08 95       	ret

000014bc <color_sensor_pin_config>:
	PORTC = PORTC & 0x80; //setting all the LCD pins are set to logic 0 except PORTC 7
}*/

void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
    14bc:	8a b1       	in	r24, 0x0a	; 10
    14be:	8e 6f       	ori	r24, 0xFE	; 254
    14c0:	8a b9       	out	0x0a, r24	; 10
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
    14c2:	58 9a       	sbi	0x0b, 0	; 11
}
    14c4:	08 95       	ret

000014c6 <port_init_color>:

void port_init_color(void)
{
	//lcd_port_config();//lcd pin configuration
	color_sensor_pin_config();//color sensor pin configuration
    14c6:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <color_sensor_pin_config>
}
    14ca:	08 95       	ret

000014cc <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
    14cc:	f8 94       	cli
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
    14ce:	e9 e6       	ldi	r30, 0x69	; 105
    14d0:	f0 e0       	ldi	r31, 0x00	; 0
    14d2:	80 81       	ld	r24, Z
    14d4:	82 60       	ori	r24, 0x02	; 2
    14d6:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
    14d8:	e8 9a       	sbi	0x1d, 0	; 29
	sei(); // Enables the global interrupt
    14da:	78 94       	sei
}
    14dc:	08 95       	ret

000014de <__vector_1>:

//ISR for color sensor
ISR(INT0_vect)
{
    14de:	1f 92       	push	r1
    14e0:	0f 92       	push	r0
    14e2:	0f b6       	in	r0, 0x3f	; 63
    14e4:	0f 92       	push	r0
    14e6:	11 24       	eor	r1, r1
    14e8:	8f 93       	push	r24
    14ea:	9f 93       	push	r25
    14ec:	af 93       	push	r26
    14ee:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
    14f0:	80 91 13 02 	lds	r24, 0x0213
    14f4:	90 91 14 02 	lds	r25, 0x0214
    14f8:	a0 91 15 02 	lds	r26, 0x0215
    14fc:	b0 91 16 02 	lds	r27, 0x0216
    1500:	01 96       	adiw	r24, 0x01	; 1
    1502:	a1 1d       	adc	r26, r1
    1504:	b1 1d       	adc	r27, r1
    1506:	80 93 13 02 	sts	0x0213, r24
    150a:	90 93 14 02 	sts	0x0214, r25
    150e:	a0 93 15 02 	sts	0x0215, r26
    1512:	b0 93 16 02 	sts	0x0216, r27
}
    1516:	bf 91       	pop	r27
    1518:	af 91       	pop	r26
    151a:	9f 91       	pop	r25
    151c:	8f 91       	pop	r24
    151e:	0f 90       	pop	r0
    1520:	0f be       	out	0x3f, r0	; 63
    1522:	0f 90       	pop	r0
    1524:	1f 90       	pop	r1
    1526:	18 95       	reti

00001528 <init_devices_color>:

void init_devices_color(void)
{
	cli(); //Clears the global interrupt
    1528:	f8 94       	cli
	port_init_color();  //Initializes all the ports
    152a:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <port_init_color>
	color_sensor_pin_interrupt_init();
    152e:	0e 94 66 0a 	call	0x14cc	; 0x14cc <color_sensor_pin_interrupt_init>
	sei();   // Enables the global interrupt
    1532:	78 94       	sei
}
    1534:	08 95       	ret

00001536 <filter_red>:

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
    1536:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 low
    1538:	5f 98       	cbi	0x0b, 7	; 11
}
    153a:	08 95       	ret

0000153c <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
    153c:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
    153e:	5f 9a       	sbi	0x0b, 7	; 11
}
    1540:	08 95       	ret

00001542 <filter_blue>:

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
    1542:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
    1544:	5f 9a       	sbi	0x0b, 7	; 11
}
    1546:	08 95       	ret

00001548 <filter_clear>:

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTD = PORTD | 0x40; //set S2 High
    1548:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 Low
    154a:	5f 98       	cbi	0x0b, 7	; 11
}
    154c:	08 95       	ret

0000154e <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
    154e:	5c 9a       	sbi	0x0b, 4	; 11
	PORTD = PORTD & 0xDF; //set S1 low
    1550:	5d 98       	cbi	0x0b, 5	; 11
	//PORTD = PORTD | 0x20; //set S1 high
}
    1552:	08 95       	ret

00001554 <red_read>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
    1554:	0e 94 9b 0a 	call	0x1536	; 0x1536 <filter_red>
	pulse=0; //reset the count to 0
    1558:	10 92 13 02 	sts	0x0213, r1
    155c:	10 92 14 02 	sts	0x0214, r1
    1560:	10 92 15 02 	sts	0x0215, r1
    1564:	10 92 16 02 	sts	0x0216, r1
    1568:	8f ef       	ldi	r24, 0xFF	; 255
    156a:	9f e7       	ldi	r25, 0x7F	; 127
    156c:	a4 e0       	ldi	r26, 0x04	; 4
    156e:	81 50       	subi	r24, 0x01	; 1
    1570:	90 40       	sbci	r25, 0x00	; 0
    1572:	a0 40       	sbci	r26, 0x00	; 0
    1574:	e1 f7       	brne	.-8      	; 0x156e <red_read+0x1a>
    1576:	00 c0       	rjmp	.+0      	; 0x1578 <red_read+0x24>
    1578:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
    157a:	80 91 13 02 	lds	r24, 0x0213
    157e:	90 91 14 02 	lds	r25, 0x0214
    1582:	a0 91 15 02 	lds	r26, 0x0215
    1586:	b0 91 16 02 	lds	r27, 0x0216
    158a:	80 93 77 02 	sts	0x0277, r24
    158e:	90 93 78 02 	sts	0x0278, r25
    1592:	a0 93 79 02 	sts	0x0279, r26
    1596:	b0 93 7a 02 	sts	0x027A, r27
	
	
}
    159a:	08 95       	ret

0000159c <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
    159c:	0e 94 9e 0a 	call	0x153c	; 0x153c <filter_green>
	pulse=0; //reset the count to 0
    15a0:	10 92 13 02 	sts	0x0213, r1
    15a4:	10 92 14 02 	sts	0x0214, r1
    15a8:	10 92 15 02 	sts	0x0215, r1
    15ac:	10 92 16 02 	sts	0x0216, r1
    15b0:	8f ef       	ldi	r24, 0xFF	; 255
    15b2:	9f e7       	ldi	r25, 0x7F	; 127
    15b4:	a4 e0       	ldi	r26, 0x04	; 4
    15b6:	81 50       	subi	r24, 0x01	; 1
    15b8:	90 40       	sbci	r25, 0x00	; 0
    15ba:	a0 40       	sbci	r26, 0x00	; 0
    15bc:	e1 f7       	brne	.-8      	; 0x15b6 <green_read+0x1a>
    15be:	00 c0       	rjmp	.+0      	; 0x15c0 <green_read+0x24>
    15c0:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
    15c2:	80 91 13 02 	lds	r24, 0x0213
    15c6:	90 91 14 02 	lds	r25, 0x0214
    15ca:	a0 91 15 02 	lds	r26, 0x0215
    15ce:	b0 91 16 02 	lds	r27, 0x0216
    15d2:	80 93 73 02 	sts	0x0273, r24
    15d6:	90 93 74 02 	sts	0x0274, r25
    15da:	a0 93 75 02 	sts	0x0275, r26
    15de:	b0 93 76 02 	sts	0x0276, r27
	
	
}
    15e2:	08 95       	ret

000015e4 <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
    15e4:	0e 94 a1 0a 	call	0x1542	; 0x1542 <filter_blue>
	pulse=0; //reset the count to 0
    15e8:	10 92 13 02 	sts	0x0213, r1
    15ec:	10 92 14 02 	sts	0x0214, r1
    15f0:	10 92 15 02 	sts	0x0215, r1
    15f4:	10 92 16 02 	sts	0x0216, r1
    15f8:	8f ef       	ldi	r24, 0xFF	; 255
    15fa:	9f e7       	ldi	r25, 0x7F	; 127
    15fc:	a4 e0       	ldi	r26, 0x04	; 4
    15fe:	81 50       	subi	r24, 0x01	; 1
    1600:	90 40       	sbci	r25, 0x00	; 0
    1602:	a0 40       	sbci	r26, 0x00	; 0
    1604:	e1 f7       	brne	.-8      	; 0x15fe <blue_read+0x1a>
    1606:	00 c0       	rjmp	.+0      	; 0x1608 <blue_read+0x24>
    1608:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
    160a:	80 91 13 02 	lds	r24, 0x0213
    160e:	90 91 14 02 	lds	r25, 0x0214
    1612:	a0 91 15 02 	lds	r26, 0x0215
    1616:	b0 91 16 02 	lds	r27, 0x0216
    161a:	80 93 43 02 	sts	0x0243, r24
    161e:	90 93 44 02 	sts	0x0244, r25
    1622:	a0 93 45 02 	sts	0x0245, r26
    1626:	b0 93 46 02 	sts	0x0246, r27
	
	
}
    162a:	08 95       	ret

0000162c <colour>:
void colour(unsigned long int red_pulse, unsigned long int green_pulse,unsigned long int blue_pulse)
{	
    162c:	8f 92       	push	r8
    162e:	9f 92       	push	r9
    1630:	af 92       	push	r10
    1632:	bf 92       	push	r11
    1634:	ef 92       	push	r14
    1636:	ff 92       	push	r15
    1638:	0f 93       	push	r16
    163a:	1f 93       	push	r17
    163c:	4b 01       	movw	r8, r22
    163e:	5c 01       	movw	r10, r24
    1640:	da 01       	movw	r26, r20
    1642:	c9 01       	movw	r24, r18
    1644:	b8 01       	movw	r22, r16
    1646:	a7 01       	movw	r20, r14
	if(red_pulse>green_pulse && red_pulse>blue_pulse)
    1648:	88 15       	cp	r24, r8
    164a:	99 05       	cpc	r25, r9
    164c:	aa 05       	cpc	r26, r10
    164e:	bb 05       	cpc	r27, r11
    1650:	88 f4       	brcc	.+34     	; 0x1674 <colour+0x48>
    1652:	e8 14       	cp	r14, r8
    1654:	f9 04       	cpc	r15, r9
    1656:	0a 05       	cpc	r16, r10
    1658:	1b 05       	cpc	r17, r11
    165a:	60 f4       	brcc	.+24     	; 0x1674 <colour+0x48>
	{
		//red greatest
		PORTH=PORTH|(1<<PH4);
    165c:	e2 e0       	ldi	r30, 0x02	; 2
    165e:	f1 e0       	ldi	r31, 0x01	; 1
    1660:	80 81       	ld	r24, Z
    1662:	80 61       	ori	r24, 0x10	; 16
    1664:	80 83       	st	Z, r24
		PORTH=PORTH & 0x9F; //clear pc5 and pc6 1001 1111
    1666:	80 81       	ld	r24, Z
    1668:	8f 79       	andi	r24, 0x9F	; 159
    166a:	80 83       	st	Z, r24
		task=1;
    166c:	81 e0       	ldi	r24, 0x01	; 1
    166e:	80 93 1e 02 	sts	0x021E, r24
    1672:	1c c0       	rjmp	.+56     	; 0x16ac <colour+0x80>
	}
	else if(green_pulse>blue_pulse)
    1674:	48 17       	cp	r20, r24
    1676:	59 07       	cpc	r21, r25
    1678:	6a 07       	cpc	r22, r26
    167a:	7b 07       	cpc	r23, r27
    167c:	60 f4       	brcc	.+24     	; 0x1696 <colour+0x6a>
	{
		//green greatest
		PORTH=PORTH|(1<<PH5);
    167e:	e2 e0       	ldi	r30, 0x02	; 2
    1680:	f1 e0       	ldi	r31, 0x01	; 1
    1682:	80 81       	ld	r24, Z
    1684:	80 62       	ori	r24, 0x20	; 32
    1686:	80 83       	st	Z, r24
		PORTH=PORTH & 0xAF; //clear pc4 and pc6 1010 1111
    1688:	80 81       	ld	r24, Z
    168a:	8f 7a       	andi	r24, 0xAF	; 175
    168c:	80 83       	st	Z, r24
		task=2;
    168e:	82 e0       	ldi	r24, 0x02	; 2
    1690:	80 93 1e 02 	sts	0x021E, r24
    1694:	0b c0       	rjmp	.+22     	; 0x16ac <colour+0x80>
	}
	else
	{
		//blue greatest
		PORTH=PORTH|(1<<PH6);
    1696:	e2 e0       	ldi	r30, 0x02	; 2
    1698:	f1 e0       	ldi	r31, 0x01	; 1
    169a:	80 81       	ld	r24, Z
    169c:	80 64       	ori	r24, 0x40	; 64
    169e:	80 83       	st	Z, r24
		PORTH=PORTH & 0xCF; //clear pc5 and pc4 1100 1111
    16a0:	80 81       	ld	r24, Z
    16a2:	8f 7c       	andi	r24, 0xCF	; 207
    16a4:	80 83       	st	Z, r24
		task=3;
    16a6:	83 e0       	ldi	r24, 0x03	; 3
    16a8:	80 93 1e 02 	sts	0x021E, r24
	}
}
    16ac:	1f 91       	pop	r17
    16ae:	0f 91       	pop	r16
    16b0:	ff 90       	pop	r15
    16b2:	ef 90       	pop	r14
    16b4:	bf 90       	pop	r11
    16b6:	af 90       	pop	r10
    16b8:	9f 90       	pop	r9
    16ba:	8f 90       	pop	r8
    16bc:	08 95       	ret

000016be <color_sensor_work>:

volatile unsigned int a=10;

void color_sensor_work()
{
    16be:	ef 92       	push	r14
    16c0:	ff 92       	push	r15
    16c2:	0f 93       	push	r16
    16c4:	1f 93       	push	r17
    16c6:	cf 93       	push	r28
    16c8:	df 93       	push	r29
	init_devices_color();
    16ca:	0e 94 94 0a 	call	0x1528	; 0x1528 <init_devices_color>
	DDRH=0x70;//0111 0000
    16ce:	80 e7       	ldi	r24, 0x70	; 112
    16d0:	80 93 01 01 	sts	0x0101, r24
	PORTH=0x00;
    16d4:	10 92 02 01 	sts	0x0102, r1
	color_sensor_scaling();
    16d8:	0e 94 a7 0a 	call	0x154e	; 0x154e <color_sensor_scaling>
    16dc:	c5 e0       	ldi	r28, 0x05	; 5
    16de:	d0 e0       	ldi	r29, 0x00	; 0
	
	for (int i=0;i<5;i++)
	{
		red_read(); //display the pulse count when red filter is selected
    16e0:	0e 94 aa 0a 	call	0x1554	; 0x1554 <red_read>
		//_delay_ms(500);
		green_read(); //display the pulse count when green filter is selected
    16e4:	0e 94 ce 0a 	call	0x159c	; 0x159c <green_read>
		//_delay_ms(500);
		blue_read(); //display the pulse count when blue filter is selected
    16e8:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <blue_read>
		//_delay_ms(500);
		colour(red,green,blue);
    16ec:	60 91 77 02 	lds	r22, 0x0277
    16f0:	70 91 78 02 	lds	r23, 0x0278
    16f4:	80 91 79 02 	lds	r24, 0x0279
    16f8:	90 91 7a 02 	lds	r25, 0x027A
    16fc:	20 91 73 02 	lds	r18, 0x0273
    1700:	30 91 74 02 	lds	r19, 0x0274
    1704:	40 91 75 02 	lds	r20, 0x0275
    1708:	50 91 76 02 	lds	r21, 0x0276
    170c:	e0 90 43 02 	lds	r14, 0x0243
    1710:	f0 90 44 02 	lds	r15, 0x0244
    1714:	00 91 45 02 	lds	r16, 0x0245
    1718:	10 91 46 02 	lds	r17, 0x0246
    171c:	0e 94 16 0b 	call	0x162c	; 0x162c <colour>
    1720:	8f ef       	ldi	r24, 0xFF	; 255
    1722:	9f ef       	ldi	r25, 0xFF	; 255
    1724:	a8 e0       	ldi	r26, 0x08	; 8
    1726:	81 50       	subi	r24, 0x01	; 1
    1728:	90 40       	sbci	r25, 0x00	; 0
    172a:	a0 40       	sbci	r26, 0x00	; 0
    172c:	e1 f7       	brne	.-8      	; 0x1726 <color_sensor_work+0x68>
    172e:	00 c0       	rjmp	.+0      	; 0x1730 <color_sensor_work+0x72>
    1730:	00 00       	nop
    1732:	21 97       	sbiw	r28, 0x01	; 1
	init_devices_color();
	DDRH=0x70;//0111 0000
	PORTH=0x00;
	color_sensor_scaling();
	
	for (int i=0;i<5;i++)
    1734:	a9 f6       	brne	.-86     	; 0x16e0 <color_sensor_work+0x22>
		//_delay_ms(500);
		colour(red,green,blue);
		_delay_ms(200);
	}
		
	PORTH=PORTH & 0x8F;// 1000 1111
    1736:	e2 e0       	ldi	r30, 0x02	; 2
    1738:	f1 e0       	ldi	r31, 0x01	; 1
    173a:	80 81       	ld	r24, Z
    173c:	8f 78       	andi	r24, 0x8F	; 143
    173e:	80 83       	st	Z, r24
}
    1740:	df 91       	pop	r29
    1742:	cf 91       	pop	r28
    1744:	1f 91       	pop	r17
    1746:	0f 91       	pop	r16
    1748:	ff 90       	pop	r15
    174a:	ef 90       	pop	r14
    174c:	08 95       	ret

0000174e <buzzer_pin_config_xbee>:
	PORTC = PORTC & 0x80; //setting all the LCD pins are set to logic 0 except PORTC 7
}*/

void buzzer_pin_config_xbee (void)
{
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as outpt
    174e:	3b 9a       	sbi	0x07, 3	; 7
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
    1750:	43 98       	cbi	0x08, 3	; 8
}
    1752:	08 95       	ret

00001754 <motion_pin_config_xbee>:

void motion_pin_config_xbee (void)
{
 DDRA = DDRA | 0x0F;
    1754:	81 b1       	in	r24, 0x01	; 1
    1756:	8f 60       	ori	r24, 0x0F	; 15
    1758:	81 b9       	out	0x01, r24	; 1
 PORTA = PORTA & 0xF0;
    175a:	82 b1       	in	r24, 0x02	; 2
    175c:	80 7f       	andi	r24, 0xF0	; 240
    175e:	82 b9       	out	0x02, r24	; 2
 DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
    1760:	ea e0       	ldi	r30, 0x0A	; 10
    1762:	f1 e0       	ldi	r31, 0x01	; 1
    1764:	80 81       	ld	r24, Z
    1766:	88 61       	ori	r24, 0x18	; 24
    1768:	80 83       	st	Z, r24
 PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
    176a:	eb e0       	ldi	r30, 0x0B	; 11
    176c:	f1 e0       	ldi	r31, 0x01	; 1
    176e:	80 81       	ld	r24, Z
    1770:	88 61       	ori	r24, 0x18	; 24
    1772:	80 83       	st	Z, r24
}
    1774:	08 95       	ret

00001776 <port_init_xbee>:

//Function to initialize ports
void port_init_xbee()
{
	motion_pin_config_xbee();
    1776:	0e 94 aa 0b 	call	0x1754	; 0x1754 <motion_pin_config_xbee>
	buzzer_pin_config_xbee();
    177a:	0e 94 a7 0b 	call	0x174e	; 0x174e <buzzer_pin_config_xbee>
	//lcd_port_config();//lcd pin configuration
}
    177e:	08 95       	ret

00001780 <uart0_init>:
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init(void)
{
 UCSR0B = 0x00; //disable while setting baud rate
    1780:	e1 ec       	ldi	r30, 0xC1	; 193
    1782:	f0 e0       	ldi	r31, 0x00	; 0
    1784:	10 82       	st	Z, r1
 UCSR0A = 0x00;
    1786:	10 92 c0 00 	sts	0x00C0, r1
 UCSR0C = 0x06;
    178a:	86 e0       	ldi	r24, 0x06	; 6
    178c:	80 93 c2 00 	sts	0x00C2, r24
 UBRR0L = 0x5F; //set baud rate lo
    1790:	8f e5       	ldi	r24, 0x5F	; 95
    1792:	80 93 c4 00 	sts	0x00C4, r24
 UBRR0H = 0x00; //set baud rate hi
    1796:	10 92 c5 00 	sts	0x00C5, r1
 UCSR0B = 0x98;
    179a:	88 e9       	ldi	r24, 0x98	; 152
    179c:	80 83       	st	Z, r24
}
    179e:	08 95       	ret

000017a0 <conversion>:
unsigned char conversion(unsigned char hex)
{	unsigned char node;	
	
	switch(hex)
    17a0:	8b 31       	cpi	r24, 0x1B	; 27
    17a2:	e9 f1       	breq	.+122    	; 0x181e <conversion+0x7e>
    17a4:	8c 31       	cpi	r24, 0x1C	; 28
    17a6:	90 f4       	brcc	.+36     	; 0x17cc <conversion+0x2c>
    17a8:	8d 30       	cpi	r24, 0x0D	; 13
    17aa:	a9 f1       	breq	.+106    	; 0x1816 <conversion+0x76>
    17ac:	8e 30       	cpi	r24, 0x0E	; 14
    17ae:	38 f4       	brcc	.+14     	; 0x17be <conversion+0x1e>
    17b0:	86 30       	cpi	r24, 0x06	; 6
    17b2:	79 f1       	breq	.+94     	; 0x1812 <conversion+0x72>
    17b4:	8b 30       	cpi	r24, 0x0B	; 11
    17b6:	09 f1       	breq	.+66     	; 0x17fa <conversion+0x5a>
    17b8:	84 30       	cpi	r24, 0x04	; 4
    17ba:	f1 f5       	brne	.+124    	; 0x1838 <conversion+0x98>
    17bc:	3c c0       	rjmp	.+120    	; 0x1836 <conversion+0x96>
    17be:	84 31       	cpi	r24, 0x14	; 20
    17c0:	61 f1       	breq	.+88     	; 0x181a <conversion+0x7a>
    17c2:	89 31       	cpi	r24, 0x19	; 25
    17c4:	f1 f0       	breq	.+60     	; 0x1802 <conversion+0x62>
    17c6:	82 31       	cpi	r24, 0x12	; 18
    17c8:	b9 f5       	brne	.+110    	; 0x1838 <conversion+0x98>
    17ca:	19 c0       	rjmp	.+50     	; 0x17fe <conversion+0x5e>
    17cc:	89 32       	cpi	r24, 0x29	; 41
    17ce:	59 f1       	breq	.+86     	; 0x1826 <conversion+0x86>
    17d0:	8a 32       	cpi	r24, 0x2A	; 42
    17d2:	38 f4       	brcc	.+14     	; 0x17e2 <conversion+0x42>
    17d4:	82 32       	cpi	r24, 0x22	; 34
    17d6:	29 f1       	breq	.+74     	; 0x1822 <conversion+0x82>
    17d8:	87 32       	cpi	r24, 0x27	; 39
    17da:	b9 f0       	breq	.+46     	; 0x180a <conversion+0x6a>
    17dc:	80 32       	cpi	r24, 0x20	; 32
    17de:	61 f5       	brne	.+88     	; 0x1838 <conversion+0x98>
    17e0:	12 c0       	rjmp	.+36     	; 0x1806 <conversion+0x66>
    17e2:	80 33       	cpi	r24, 0x30	; 48
    17e4:	11 f1       	breq	.+68     	; 0x182a <conversion+0x8a>
    17e6:	81 33       	cpi	r24, 0x31	; 49
    17e8:	18 f4       	brcc	.+6      	; 0x17f0 <conversion+0x50>
    17ea:	8e 32       	cpi	r24, 0x2E	; 46
    17ec:	29 f5       	brne	.+74     	; 0x1838 <conversion+0x98>
    17ee:	0f c0       	rjmp	.+30     	; 0x180e <conversion+0x6e>
    17f0:	84 36       	cpi	r24, 0x64	; 100
    17f2:	e9 f0       	breq	.+58     	; 0x182e <conversion+0x8e>
    17f4:	85 36       	cpi	r24, 0x65	; 101
    17f6:	01 f5       	brne	.+64     	; 0x1838 <conversion+0x98>
    17f8:	1c c0       	rjmp	.+56     	; 0x1832 <conversion+0x92>
	{
		case 0x04:
		node=4;
		break;
		case 0x0B:
		node=11;
    17fa:	9b e0       	ldi	r25, 0x0B	; 11
		break;
    17fc:	1d c0       	rjmp	.+58     	; 0x1838 <conversion+0x98>
		case 0x12:
		node=18;
    17fe:	92 e1       	ldi	r25, 0x12	; 18
		break;
    1800:	1b c0       	rjmp	.+54     	; 0x1838 <conversion+0x98>
		case 0x19:
		node=25;
    1802:	99 e1       	ldi	r25, 0x19	; 25
		break;
    1804:	19 c0       	rjmp	.+50     	; 0x1838 <conversion+0x98>
		case 0x20:
		node=32;
    1806:	90 e2       	ldi	r25, 0x20	; 32
		break;
    1808:	17 c0       	rjmp	.+46     	; 0x1838 <conversion+0x98>
		case 0x27:
		node=39;
    180a:	97 e2       	ldi	r25, 0x27	; 39
		break;
    180c:	15 c0       	rjmp	.+42     	; 0x1838 <conversion+0x98>
		case 0x2E:
		node=46;
    180e:	9e e2       	ldi	r25, 0x2E	; 46
		break;
    1810:	13 c0       	rjmp	.+38     	; 0x1838 <conversion+0x98>
		
		case 0x06:
		node=6;
    1812:	96 e0       	ldi	r25, 0x06	; 6
		break;
    1814:	11 c0       	rjmp	.+34     	; 0x1838 <conversion+0x98>
		case 0x0D:
		node=13;
    1816:	9d e0       	ldi	r25, 0x0D	; 13
		break;
    1818:	0f c0       	rjmp	.+30     	; 0x1838 <conversion+0x98>
		case 0x14:
		node=20;
    181a:	94 e1       	ldi	r25, 0x14	; 20
		break;
    181c:	0d c0       	rjmp	.+26     	; 0x1838 <conversion+0x98>
		case 0x1B:
		node=27;
    181e:	9b e1       	ldi	r25, 0x1B	; 27
		break;
    1820:	0b c0       	rjmp	.+22     	; 0x1838 <conversion+0x98>
		case 0x22:
		node=34;
    1822:	92 e2       	ldi	r25, 0x22	; 34
		break;
    1824:	09 c0       	rjmp	.+18     	; 0x1838 <conversion+0x98>
		case 0x29:
		node=41;
    1826:	99 e2       	ldi	r25, 0x29	; 41
		break;
    1828:	07 c0       	rjmp	.+14     	; 0x1838 <conversion+0x98>
		case 0x30:
		node=45;
    182a:	9d e2       	ldi	r25, 0x2D	; 45
		break;
    182c:	05 c0       	rjmp	.+10     	; 0x1838 <conversion+0x98>
		
		case 0x64:
		node=100;
    182e:	94 e6       	ldi	r25, 0x64	; 100
		break;
    1830:	03 c0       	rjmp	.+6      	; 0x1838 <conversion+0x98>
		case 0x65:
		node=101;
    1832:	95 e6       	ldi	r25, 0x65	; 101
		break;
    1834:	01 c0       	rjmp	.+2      	; 0x1838 <conversion+0x98>
{	unsigned char node;	
	
	switch(hex)
	{
		case 0x04:
		node=4;
    1836:	94 e0       	ldi	r25, 0x04	; 4
	
	lcd_print(2,12,node,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	lcd_wr_command(0x01); //Clear the LCD*/
	return node;
}
    1838:	89 2f       	mov	r24, r25
    183a:	08 95       	ret

0000183c <__vector_25>:



SIGNAL(SIG_USART0_RECV) 		// ISR for receive complete interrupt
{	
    183c:	1f 92       	push	r1
    183e:	0f 92       	push	r0
    1840:	0f b6       	in	r0, 0x3f	; 63
    1842:	0f 92       	push	r0
    1844:	0b b6       	in	r0, 0x3b	; 59
    1846:	0f 92       	push	r0
    1848:	11 24       	eor	r1, r1
    184a:	0f 93       	push	r16
    184c:	1f 93       	push	r17
    184e:	2f 93       	push	r18
    1850:	3f 93       	push	r19
    1852:	4f 93       	push	r20
    1854:	5f 93       	push	r21
    1856:	6f 93       	push	r22
    1858:	7f 93       	push	r23
    185a:	8f 93       	push	r24
    185c:	9f 93       	push	r25
    185e:	af 93       	push	r26
    1860:	bf 93       	push	r27
    1862:	cf 93       	push	r28
    1864:	ef 93       	push	r30
    1866:	ff 93       	push	r31
	unsigned char k;
	
	lcd_set_4bit();
    1868:	0e 94 36 06 	call	0xc6c	; 0xc6c <lcd_set_4bit>
	lcd_init();
    186c:	0e 94 9e 06 	call	0xd3c	; 0xd3c <lcd_init>
	k=UDR0;
    1870:	c0 91 c6 00 	lds	r28, 0x00C6
	if(k==0x37)
    1874:	c7 33       	cpi	r28, 0x37	; 55
    1876:	21 f4       	brne	.+8      	; 0x1880 <__vector_25+0x44>
	{
		mark=1;
    1878:	81 e0       	ldi	r24, 0x01	; 1
    187a:	80 93 00 02 	sts	0x0200, r24
    187e:	0b c0       	rjmp	.+22     	; 0x1896 <__vector_25+0x5a>
	}
	if (k==0x38)
    1880:	c8 33       	cpi	r28, 0x38	; 56
    1882:	49 f4       	brne	.+18     	; 0x1896 <__vector_25+0x5a>
	{
		mark=0;
    1884:	10 92 00 02 	sts	0x0200, r1
		next++;
    1888:	80 91 10 02 	lds	r24, 0x0210
    188c:	8f 5f       	subi	r24, 0xFF	; 255
    188e:	80 93 10 02 	sts	0x0210, r24
		buzzer_beep();
    1892:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
	}
	if (mark==1)
    1896:	80 91 00 02 	lds	r24, 0x0200
    189a:	81 30       	cpi	r24, 0x01	; 1
    189c:	09 f0       	breq	.+2      	; 0x18a0 <__vector_25+0x64>
    189e:	59 c0       	rjmp	.+178    	; 0x1952 <__vector_25+0x116>
	{
		if(k>0x00 && k<0x31)
    18a0:	8c 2f       	mov	r24, r28
    18a2:	81 50       	subi	r24, 0x01	; 1
    18a4:	80 33       	cpi	r24, 0x30	; 48
    18a6:	48 f5       	brcc	.+82     	; 0x18fa <__vector_25+0xbe>
		{
			green_nodes[gn]=conversion(k);
    18a8:	00 91 12 02 	lds	r16, 0x0212
    18ac:	10 e0       	ldi	r17, 0x00	; 0
    18ae:	8c 2f       	mov	r24, r28
    18b0:	0e 94 d0 0b 	call	0x17a0	; 0x17a0 <conversion>
    18b4:	c8 2f       	mov	r28, r24
    18b6:	f8 01       	movw	r30, r16
    18b8:	e5 5d       	subi	r30, 0xD5	; 213
    18ba:	fd 4f       	sbci	r31, 0xFD	; 253
    18bc:	80 83       	st	Z, r24
			
			lcd_cursor(1,1);  //set the cursor on row 1, column 1
    18be:	81 e0       	ldi	r24, 0x01	; 1
    18c0:	61 e0       	ldi	r22, 0x01	; 1
    18c2:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <lcd_cursor>
			
			lcd_print(2,12,conversion(k),5);  //Print the count on second row
    18c6:	82 e0       	ldi	r24, 0x02	; 2
    18c8:	6c e0       	ldi	r22, 0x0C	; 12
    18ca:	4c 2f       	mov	r20, r28
    18cc:	50 e0       	ldi	r21, 0x00	; 0
    18ce:	25 e0       	ldi	r18, 0x05	; 5
    18d0:	30 e0       	ldi	r19, 0x00	; 0
    18d2:	0e 94 0b 07 	call	0xe16	; 0xe16 <lcd_print>
    18d6:	8f ef       	ldi	r24, 0xFF	; 255
    18d8:	9f ef       	ldi	r25, 0xFF	; 255
    18da:	ac e2       	ldi	r26, 0x2C	; 44
    18dc:	81 50       	subi	r24, 0x01	; 1
    18de:	90 40       	sbci	r25, 0x00	; 0
    18e0:	a0 40       	sbci	r26, 0x00	; 0
    18e2:	e1 f7       	brne	.-8      	; 0x18dc <__vector_25+0xa0>
    18e4:	00 c0       	rjmp	.+0      	; 0x18e6 <__vector_25+0xaa>
    18e6:	00 00       	nop
			_delay_ms(1000);	// Display for 1000ms or 1 second
			lcd_wr_command(0x01); //Clear the LCD
    18e8:	81 e0       	ldi	r24, 0x01	; 1
    18ea:	0e 94 79 06 	call	0xcf2	; 0xcf2 <lcd_wr_command>
			gn++;
    18ee:	80 91 12 02 	lds	r24, 0x0212
    18f2:	8f 5f       	subi	r24, 0xFF	; 255
    18f4:	80 93 12 02 	sts	0x0212, r24
    18f8:	2c c0       	rjmp	.+88     	; 0x1952 <__vector_25+0x116>
			
		}
		else if(k==0x64 || k==0x65)
    18fa:	8c 2f       	mov	r24, r28
    18fc:	84 56       	subi	r24, 0x64	; 100
    18fe:	82 30       	cpi	r24, 0x02	; 2
    1900:	40 f5       	brcc	.+80     	; 0x1952 <__vector_25+0x116>
		{
			green_side[gs]=conversion(k);
    1902:	00 91 11 02 	lds	r16, 0x0211
    1906:	10 e0       	ldi	r17, 0x00	; 0
    1908:	8c 2f       	mov	r24, r28
    190a:	0e 94 d0 0b 	call	0x17a0	; 0x17a0 <conversion>
    190e:	c8 2f       	mov	r28, r24
    1910:	f8 01       	movw	r30, r16
    1912:	e4 5b       	subi	r30, 0xB4	; 180
    1914:	fd 4f       	sbci	r31, 0xFD	; 253
    1916:	80 83       	st	Z, r24
			
			lcd_cursor(1,1);  //set the cursor on row 1, column 1
    1918:	81 e0       	ldi	r24, 0x01	; 1
    191a:	61 e0       	ldi	r22, 0x01	; 1
    191c:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <lcd_cursor>
			
			lcd_print(2,12,conversion(k),5);  //Print the count on second row
    1920:	82 e0       	ldi	r24, 0x02	; 2
    1922:	6c e0       	ldi	r22, 0x0C	; 12
    1924:	4c 2f       	mov	r20, r28
    1926:	50 e0       	ldi	r21, 0x00	; 0
    1928:	25 e0       	ldi	r18, 0x05	; 5
    192a:	30 e0       	ldi	r19, 0x00	; 0
    192c:	0e 94 0b 07 	call	0xe16	; 0xe16 <lcd_print>
    1930:	8f ef       	ldi	r24, 0xFF	; 255
    1932:	9f ef       	ldi	r25, 0xFF	; 255
    1934:	ac e2       	ldi	r26, 0x2C	; 44
    1936:	81 50       	subi	r24, 0x01	; 1
    1938:	90 40       	sbci	r25, 0x00	; 0
    193a:	a0 40       	sbci	r26, 0x00	; 0
    193c:	e1 f7       	brne	.-8      	; 0x1936 <__vector_25+0xfa>
    193e:	00 c0       	rjmp	.+0      	; 0x1940 <__vector_25+0x104>
    1940:	00 00       	nop
			_delay_ms(1000);	// Display for 1000ms or 1 second
			lcd_wr_command(0x01); //Clear the LCD
    1942:	81 e0       	ldi	r24, 0x01	; 1
    1944:	0e 94 79 06 	call	0xcf2	; 0xcf2 <lcd_wr_command>
			gs++;
    1948:	80 91 11 02 	lds	r24, 0x0211
    194c:	8f 5f       	subi	r24, 0xFF	; 255
    194e:	80 93 11 02 	sts	0x0211, r24
		{
			PORTA=0x06;  //forward
		}*/
	

}
    1952:	ff 91       	pop	r31
    1954:	ef 91       	pop	r30
    1956:	cf 91       	pop	r28
    1958:	bf 91       	pop	r27
    195a:	af 91       	pop	r26
    195c:	9f 91       	pop	r25
    195e:	8f 91       	pop	r24
    1960:	7f 91       	pop	r23
    1962:	6f 91       	pop	r22
    1964:	5f 91       	pop	r21
    1966:	4f 91       	pop	r20
    1968:	3f 91       	pop	r19
    196a:	2f 91       	pop	r18
    196c:	1f 91       	pop	r17
    196e:	0f 91       	pop	r16
    1970:	0f 90       	pop	r0
    1972:	0b be       	out	0x3b, r0	; 59
    1974:	0f 90       	pop	r0
    1976:	0f be       	out	0x3f, r0	; 63
    1978:	0f 90       	pop	r0
    197a:	1f 90       	pop	r1
    197c:	18 95       	reti

0000197e <init_devices_xbee>:


//Function To Initialize all The Devices
void init_devices_xbee()
{
 cli(); //Clears the global interrupts
    197e:	f8 94       	cli
 port_init_xbee();  //Initializes all the ports
    1980:	0e 94 bb 0b 	call	0x1776	; 0x1776 <port_init_xbee>
 uart0_init(); //Initailize UART1 for serial communiaction
    1984:	0e 94 c0 0b 	call	0x1780	; 0x1780 <uart0_init>
 sei();   //Enables the global interrupts
    1988:	78 94       	sei
}
    198a:	08 95       	ret

0000198c <USARTWriteChar>:
		//Do nothing
	*/

	//Now write the data to USART buffer
  
	UDR0=data;
    198c:	80 93 c6 00 	sts	0x00C6, r24
		
	
}
    1990:	08 95       	ret

00001992 <direction>:
	side=0;
	//buzzer_beep();
}

void direction(void)
{	buzzer_pin_config();
    1992:	0f 93       	push	r16
    1994:	1f 93       	push	r17
    1996:	cf 93       	push	r28
    1998:	df 93       	push	r29
    199a:	0e 94 20 01 	call	0x240	; 0x240 <buzzer_pin_config>
	int w=0;
	if(t==max)
    199e:	20 91 0e 02 	lds	r18, 0x020E
    19a2:	30 91 0f 02 	lds	r19, 0x020F
    19a6:	80 91 27 02 	lds	r24, 0x0227
    19aa:	90 91 28 02 	lds	r25, 0x0228
    19ae:	28 17       	cp	r18, r24
    19b0:	39 07       	cpc	r19, r25
    19b2:	09 f0       	breq	.+2      	; 0x19b6 <direction+0x24>
    19b4:	31 c1       	rjmp	.+610    	; 0x1c18 <direction+0x286>
	{	
		if(stage==1)
    19b6:	80 91 07 02 	lds	r24, 0x0207
    19ba:	90 91 08 02 	lds	r25, 0x0208
    19be:	81 30       	cpi	r24, 0x01	; 1
    19c0:	91 05       	cpc	r25, r1
    19c2:	09 f0       	breq	.+2      	; 0x19c6 <direction+0x34>
    19c4:	5a c0       	rjmp	.+180    	; 0x1a7a <direction+0xe8>
		{
			if(dir==1)
    19c6:	80 91 09 02 	lds	r24, 0x0209
    19ca:	90 91 0a 02 	lds	r25, 0x020A
    19ce:	81 30       	cpi	r24, 0x01	; 1
    19d0:	91 05       	cpc	r25, r1
    19d2:	81 f4       	brne	.+32     	; 0x19f4 <direction+0x62>
			{	//buzzer_beep();
				right_degrees(180);
    19d4:	84 eb       	ldi	r24, 0xB4	; 180
    19d6:	90 e0       	ldi	r25, 0x00	; 0
    19d8:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <right_degrees>
				stop1();
    19dc:	0e 94 38 04 	call	0x870	; 0x870 <stop1>
    19e0:	8f ef       	ldi	r24, 0xFF	; 255
    19e2:	9f e7       	ldi	r25, 0x7F	; 127
    19e4:	a6 e1       	ldi	r26, 0x16	; 22
    19e6:	81 50       	subi	r24, 0x01	; 1
    19e8:	90 40       	sbci	r25, 0x00	; 0
    19ea:	a0 40       	sbci	r26, 0x00	; 0
    19ec:	e1 f7       	brne	.-8      	; 0x19e6 <direction+0x54>
    19ee:	00 c0       	rjmp	.+0      	; 0x19f0 <direction+0x5e>
    19f0:	00 00       	nop
    19f2:	25 c0       	rjmp	.+74     	; 0x1a3e <direction+0xac>
				_delay_ms(500);
			}
			else if(dir==2)
    19f4:	82 30       	cpi	r24, 0x02	; 2
    19f6:	91 05       	cpc	r25, r1
    19f8:	81 f4       	brne	.+32     	; 0x1a1a <direction+0x88>
			{
				right_degrees(90);
    19fa:	8a e5       	ldi	r24, 0x5A	; 90
    19fc:	90 e0       	ldi	r25, 0x00	; 0
    19fe:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <right_degrees>
				stop1();
    1a02:	0e 94 38 04 	call	0x870	; 0x870 <stop1>
    1a06:	8f ef       	ldi	r24, 0xFF	; 255
    1a08:	9f e7       	ldi	r25, 0x7F	; 127
    1a0a:	a6 e1       	ldi	r26, 0x16	; 22
    1a0c:	81 50       	subi	r24, 0x01	; 1
    1a0e:	90 40       	sbci	r25, 0x00	; 0
    1a10:	a0 40       	sbci	r26, 0x00	; 0
    1a12:	e1 f7       	brne	.-8      	; 0x1a0c <direction+0x7a>
    1a14:	00 c0       	rjmp	.+0      	; 0x1a16 <direction+0x84>
    1a16:	00 00       	nop
    1a18:	12 c0       	rjmp	.+36     	; 0x1a3e <direction+0xac>
				_delay_ms(500);
			}
			else if(dir==4)
    1a1a:	84 30       	cpi	r24, 0x04	; 4
    1a1c:	91 05       	cpc	r25, r1
    1a1e:	79 f4       	brne	.+30     	; 0x1a3e <direction+0xac>
			{
				left_degrees(90);
    1a20:	8a e5       	ldi	r24, 0x5A	; 90
    1a22:	90 e0       	ldi	r25, 0x00	; 0
    1a24:	0e 94 c9 04 	call	0x992	; 0x992 <left_degrees>
				stop1();
    1a28:	0e 94 38 04 	call	0x870	; 0x870 <stop1>
    1a2c:	8f ef       	ldi	r24, 0xFF	; 255
    1a2e:	9f e7       	ldi	r25, 0x7F	; 127
    1a30:	a6 e1       	ldi	r26, 0x16	; 22
    1a32:	81 50       	subi	r24, 0x01	; 1
    1a34:	90 40       	sbci	r25, 0x00	; 0
    1a36:	a0 40       	sbci	r26, 0x00	; 0
    1a38:	e1 f7       	brne	.-8      	; 0x1a32 <direction+0xa0>
    1a3a:	00 c0       	rjmp	.+0      	; 0x1a3c <direction+0xaa>
    1a3c:	00 00       	nop
				_delay_ms(500);
			}
			
			dir=3;
    1a3e:	83 e0       	ldi	r24, 0x03	; 3
    1a40:	90 e0       	ldi	r25, 0x00	; 0
    1a42:	90 93 0a 02 	sts	0x020A, r25
    1a46:	80 93 09 02 	sts	0x0209, r24
			lcd_print(2,4,dir,3);
    1a4a:	82 e0       	ldi	r24, 0x02	; 2
    1a4c:	64 e0       	ldi	r22, 0x04	; 4
    1a4e:	43 e0       	ldi	r20, 0x03	; 3
    1a50:	50 e0       	ldi	r21, 0x00	; 0
    1a52:	23 e0       	ldi	r18, 0x03	; 3
    1a54:	30 e0       	ldi	r19, 0x00	; 0
    1a56:	0e 94 0b 07 	call	0xe16	; 0xe16 <lcd_print>
    1a5a:	8f ef       	ldi	r24, 0xFF	; 255
    1a5c:	9f ef       	ldi	r25, 0xFF	; 255
    1a5e:	ac e2       	ldi	r26, 0x2C	; 44
    1a60:	81 50       	subi	r24, 0x01	; 1
    1a62:	90 40       	sbci	r25, 0x00	; 0
    1a64:	a0 40       	sbci	r26, 0x00	; 0
    1a66:	e1 f7       	brne	.-8      	; 0x1a60 <direction+0xce>
    1a68:	00 c0       	rjmp	.+0      	; 0x1a6a <direction+0xd8>
    1a6a:	00 00       	nop
			_delay_ms(1000);
			g=1;
    1a6c:	81 e0       	ldi	r24, 0x01	; 1
    1a6e:	90 e0       	ldi	r25, 0x00	; 0
    1a70:	90 93 2a 02 	sts	0x022A, r25
    1a74:	80 93 29 02 	sts	0x0229, r24
    1a78:	cf c0       	rjmp	.+414    	; 0x1c18 <direction+0x286>
		}
		else if (stage==2)
    1a7a:	82 30       	cpi	r24, 0x02	; 2
    1a7c:	91 05       	cpc	r25, r1
    1a7e:	09 f0       	breq	.+2      	; 0x1a82 <direction+0xf0>
    1a80:	cb c0       	rjmp	.+406    	; 0x1c18 <direction+0x286>
		{	buzzer_beep();
    1a82:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
			init_devices_xbee();
    1a86:	0e 94 bf 0c 	call	0x197e	; 0x197e <init_devices_xbee>
    1a8a:	8f ef       	ldi	r24, 0xFF	; 255
    1a8c:	9f e7       	ldi	r25, 0x7F	; 127
    1a8e:	a4 e0       	ldi	r26, 0x04	; 4
    1a90:	81 50       	subi	r24, 0x01	; 1
    1a92:	90 40       	sbci	r25, 0x00	; 0
    1a94:	a0 40       	sbci	r26, 0x00	; 0
    1a96:	e1 f7       	brne	.-8      	; 0x1a90 <direction+0xfe>
    1a98:	00 c0       	rjmp	.+0      	; 0x1a9a <direction+0x108>
    1a9a:	00 00       	nop
			_delay_ms(100);
			red_nodes[0]=51;
    1a9c:	93 e3       	ldi	r25, 0x33	; 51
    1a9e:	90 93 e3 02 	sts	0x02E3, r25
			red_nodes[r]=52;
    1aa2:	e0 91 06 02 	lds	r30, 0x0206
    1aa6:	f0 e0       	ldi	r31, 0x00	; 0
    1aa8:	ed 51       	subi	r30, 0x1D	; 29
    1aaa:	fd 4f       	sbci	r31, 0xFD	; 253
    1aac:	84 e3       	ldi	r24, 0x34	; 52
    1aae:	80 83       	st	Z, r24
			red_side[0]=51;
    1ab0:	90 93 f4 02 	sts	0x02F4, r25
			red_side[rs]=52;
    1ab4:	e0 91 04 02 	lds	r30, 0x0204
    1ab8:	f0 e0       	ldi	r31, 0x00	; 0
    1aba:	ec 50       	subi	r30, 0x0C	; 12
    1abc:	fd 4f       	sbci	r31, 0xFD	; 253
    1abe:	80 83       	st	Z, r24
			for(int i=0;i<=10;i++)
			{	if(red_nodes[i]==0)
    1ac0:	80 91 e3 02 	lds	r24, 0x02E3
    1ac4:	88 23       	and	r24, r24
    1ac6:	09 f0       	breq	.+2      	; 0x1aca <direction+0x138>
    1ac8:	b8 c1       	rjmp	.+880    	; 0x1e3a <direction+0x4a8>
    1aca:	06 c0       	rjmp	.+12     	; 0x1ad8 <direction+0x146>
    1acc:	f8 01       	movw	r30, r16
    1ace:	ec 0f       	add	r30, r28
    1ad0:	fd 1f       	adc	r31, r29
    1ad2:	80 81       	ld	r24, Z
    1ad4:	88 23       	and	r24, r24
    1ad6:	31 f4       	brne	.+12     	; 0x1ae4 <direction+0x152>
				buzzer_beep();
				
			}
			
			for(int i=0;i<10;i++)
			{	if(red_side[i]==0)
    1ad8:	80 91 f4 02 	lds	r24, 0x02F4
    1adc:	88 23       	and	r24, r24
    1ade:	09 f0       	breq	.+2      	; 0x1ae2 <direction+0x150>
    1ae0:	98 c1       	rjmp	.+816    	; 0x1e12 <direction+0x480>
    1ae2:	31 c0       	rjmp	.+98     	; 0x1b46 <direction+0x1b4>
				{
					
					break;
					
				}
				USARTWriteChar(red_nodes[i]);
    1ae4:	f8 01       	movw	r30, r16
    1ae6:	ec 0f       	add	r30, r28
    1ae8:	fd 1f       	adc	r31, r29
    1aea:	80 81       	ld	r24, Z
    1aec:	0e 94 c6 0c 	call	0x198c	; 0x198c <USARTWriteChar>
    1af0:	8f ef       	ldi	r24, 0xFF	; 255
    1af2:	9f ef       	ldi	r25, 0xFF	; 255
    1af4:	ac e2       	ldi	r26, 0x2C	; 44
    1af6:	81 50       	subi	r24, 0x01	; 1
    1af8:	90 40       	sbci	r25, 0x00	; 0
    1afa:	a0 40       	sbci	r26, 0x00	; 0
    1afc:	e1 f7       	brne	.-8      	; 0x1af6 <direction+0x164>
    1afe:	00 c0       	rjmp	.+0      	; 0x1b00 <direction+0x16e>
    1b00:	00 00       	nop
				
				_delay_ms(1000);
				buzzer_beep();
    1b02:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
			_delay_ms(100);
			red_nodes[0]=51;
			red_nodes[r]=52;
			red_side[0]=51;
			red_side[rs]=52;
			for(int i=0;i<=10;i++)
    1b06:	21 96       	adiw	r28, 0x01	; 1
    1b08:	cb 30       	cpi	r28, 0x0B	; 11
    1b0a:	d1 05       	cpc	r29, r1
    1b0c:	f9 f6       	brne	.-66     	; 0x1acc <direction+0x13a>
    1b0e:	e4 cf       	rjmp	.-56     	; 0x1ad8 <direction+0x146>
				buzzer_beep();
				
			}
			
			for(int i=0;i<10;i++)
			{	if(red_side[i]==0)
    1b10:	f8 01       	movw	r30, r16
    1b12:	ec 0f       	add	r30, r28
    1b14:	fd 1f       	adc	r31, r29
    1b16:	80 81       	ld	r24, Z
    1b18:	88 23       	and	r24, r24
    1b1a:	a9 f0       	breq	.+42     	; 0x1b46 <direction+0x1b4>
				{
					break;
				}
				USARTWriteChar(red_side[i]);
    1b1c:	f8 01       	movw	r30, r16
    1b1e:	ec 0f       	add	r30, r28
    1b20:	fd 1f       	adc	r31, r29
    1b22:	80 81       	ld	r24, Z
    1b24:	0e 94 c6 0c 	call	0x198c	; 0x198c <USARTWriteChar>
    1b28:	8f ef       	ldi	r24, 0xFF	; 255
    1b2a:	9f ef       	ldi	r25, 0xFF	; 255
    1b2c:	ac e2       	ldi	r26, 0x2C	; 44
    1b2e:	81 50       	subi	r24, 0x01	; 1
    1b30:	90 40       	sbci	r25, 0x00	; 0
    1b32:	a0 40       	sbci	r26, 0x00	; 0
    1b34:	e1 f7       	brne	.-8      	; 0x1b2e <direction+0x19c>
    1b36:	00 c0       	rjmp	.+0      	; 0x1b38 <direction+0x1a6>
    1b38:	00 00       	nop
				_delay_ms(1000);
				buzzer_beep();
    1b3a:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
				_delay_ms(1000);
				buzzer_beep();
				
			}
			
			for(int i=0;i<10;i++)
    1b3e:	21 96       	adiw	r28, 0x01	; 1
    1b40:	ca 30       	cpi	r28, 0x0A	; 10
    1b42:	d1 05       	cpc	r29, r1
    1b44:	29 f7       	brne	.-54     	; 0x1b10 <direction+0x17e>
				_delay_ms(1000);
				buzzer_beep();
			}
			
			
			blue_nodes[0]=53;
    1b46:	95 e3       	ldi	r25, 0x35	; 53
    1b48:	90 93 37 02 	sts	0x0237, r25
			blue_nodes[b]=54;
    1b4c:	e0 91 05 02 	lds	r30, 0x0205
    1b50:	f0 e0       	ldi	r31, 0x00	; 0
    1b52:	e9 5c       	subi	r30, 0xC9	; 201
    1b54:	fd 4f       	sbci	r31, 0xFD	; 253
    1b56:	86 e3       	ldi	r24, 0x36	; 54
    1b58:	80 83       	st	Z, r24
			blue_side[0]=53;
    1b5a:	90 93 5c 02 	sts	0x025C, r25
			blue_side[bs]=54;
    1b5e:	e0 91 03 02 	lds	r30, 0x0203
    1b62:	f0 e0       	ldi	r31, 0x00	; 0
    1b64:	e4 5a       	subi	r30, 0xA4	; 164
    1b66:	fd 4f       	sbci	r31, 0xFD	; 253
    1b68:	80 83       	st	Z, r24
			for(int i=0;i<=10;i++)
			{	if(blue_nodes[i]==0)
    1b6a:	80 91 37 02 	lds	r24, 0x0237
    1b6e:	88 23       	and	r24, r24
    1b70:	09 f0       	breq	.+2      	; 0x1b74 <direction+0x1e2>
    1b72:	3b c1       	rjmp	.+630    	; 0x1dea <direction+0x458>
    1b74:	06 c0       	rjmp	.+12     	; 0x1b82 <direction+0x1f0>
    1b76:	f8 01       	movw	r30, r16
    1b78:	ec 0f       	add	r30, r28
    1b7a:	fd 1f       	adc	r31, r29
    1b7c:	80 81       	ld	r24, Z
    1b7e:	88 23       	and	r24, r24
    1b80:	31 f4       	brne	.+12     	; 0x1b8e <direction+0x1fc>
				buzzer_beep();
				
			}
			
			for(int i=0;i<10;i++)
			{	if(blue_side[i]==0)
    1b82:	80 91 5c 02 	lds	r24, 0x025C
    1b86:	88 23       	and	r24, r24
    1b88:	09 f0       	breq	.+2      	; 0x1b8c <direction+0x1fa>
    1b8a:	1b c1       	rjmp	.+566    	; 0x1dc2 <direction+0x430>
    1b8c:	31 c0       	rjmp	.+98     	; 0x1bf0 <direction+0x25e>
				{
					
					break;
					
				}
				USARTWriteChar(blue_nodes[i]);
    1b8e:	f8 01       	movw	r30, r16
    1b90:	ec 0f       	add	r30, r28
    1b92:	fd 1f       	adc	r31, r29
    1b94:	80 81       	ld	r24, Z
    1b96:	0e 94 c6 0c 	call	0x198c	; 0x198c <USARTWriteChar>
    1b9a:	8f ef       	ldi	r24, 0xFF	; 255
    1b9c:	9f ef       	ldi	r25, 0xFF	; 255
    1b9e:	ac e2       	ldi	r26, 0x2C	; 44
    1ba0:	81 50       	subi	r24, 0x01	; 1
    1ba2:	90 40       	sbci	r25, 0x00	; 0
    1ba4:	a0 40       	sbci	r26, 0x00	; 0
    1ba6:	e1 f7       	brne	.-8      	; 0x1ba0 <direction+0x20e>
    1ba8:	00 c0       	rjmp	.+0      	; 0x1baa <direction+0x218>
    1baa:	00 00       	nop
				
				_delay_ms(1000);
				buzzer_beep();
    1bac:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
			
			blue_nodes[0]=53;
			blue_nodes[b]=54;
			blue_side[0]=53;
			blue_side[bs]=54;
			for(int i=0;i<=10;i++)
    1bb0:	21 96       	adiw	r28, 0x01	; 1
    1bb2:	cb 30       	cpi	r28, 0x0B	; 11
    1bb4:	d1 05       	cpc	r29, r1
    1bb6:	f9 f6       	brne	.-66     	; 0x1b76 <direction+0x1e4>
    1bb8:	e4 cf       	rjmp	.-56     	; 0x1b82 <direction+0x1f0>
				buzzer_beep();
				
			}
			
			for(int i=0;i<10;i++)
			{	if(blue_side[i]==0)
    1bba:	f8 01       	movw	r30, r16
    1bbc:	ec 0f       	add	r30, r28
    1bbe:	fd 1f       	adc	r31, r29
    1bc0:	80 81       	ld	r24, Z
    1bc2:	88 23       	and	r24, r24
    1bc4:	a9 f0       	breq	.+42     	; 0x1bf0 <direction+0x25e>
				{
					break;
				}
				USARTWriteChar(blue_side[i]);
    1bc6:	f8 01       	movw	r30, r16
    1bc8:	ec 0f       	add	r30, r28
    1bca:	fd 1f       	adc	r31, r29
    1bcc:	80 81       	ld	r24, Z
    1bce:	0e 94 c6 0c 	call	0x198c	; 0x198c <USARTWriteChar>
    1bd2:	8f ef       	ldi	r24, 0xFF	; 255
    1bd4:	9f ef       	ldi	r25, 0xFF	; 255
    1bd6:	ac e2       	ldi	r26, 0x2C	; 44
    1bd8:	81 50       	subi	r24, 0x01	; 1
    1bda:	90 40       	sbci	r25, 0x00	; 0
    1bdc:	a0 40       	sbci	r26, 0x00	; 0
    1bde:	e1 f7       	brne	.-8      	; 0x1bd8 <direction+0x246>
    1be0:	00 c0       	rjmp	.+0      	; 0x1be2 <direction+0x250>
    1be2:	00 00       	nop
				_delay_ms(1000);
				buzzer_beep();
    1be4:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
				_delay_ms(1000);
				buzzer_beep();
				
			}
			
			for(int i=0;i<10;i++)
    1be8:	21 96       	adiw	r28, 0x01	; 1
    1bea:	ca 30       	cpi	r28, 0x0A	; 10
    1bec:	d1 05       	cpc	r29, r1
    1bee:	29 f7       	brne	.-54     	; 0x1bba <direction+0x228>
				buzzer_beep();
			}
			
			while (1)
			{
				if(next>2)
    1bf0:	80 91 10 02 	lds	r24, 0x0210
    1bf4:	83 30       	cpi	r24, 0x03	; 3
    1bf6:	e0 f3       	brcs	.-8      	; 0x1bf0 <direction+0x25e>
				{	buzzer_beep();
    1bf8:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
					buzzer_beep();
    1bfc:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
					break;
				}
			}
			stage=3;
    1c00:	83 e0       	ldi	r24, 0x03	; 3
    1c02:	90 e0       	ldi	r25, 0x00	; 0
    1c04:	90 93 08 02 	sts	0x0208, r25
    1c08:	80 93 07 02 	sts	0x0207, r24
			g=1;
    1c0c:	81 e0       	ldi	r24, 0x01	; 1
    1c0e:	90 e0       	ldi	r25, 0x00	; 0
    1c10:	90 93 2a 02 	sts	0x022A, r25
    1c14:	80 93 29 02 	sts	0x0229, r24
		
		
		
		
	}
	if(t<max)
    1c18:	e0 91 0e 02 	lds	r30, 0x020E
    1c1c:	f0 91 0f 02 	lds	r31, 0x020F
    1c20:	80 91 27 02 	lds	r24, 0x0227
    1c24:	90 91 28 02 	lds	r25, 0x0228
    1c28:	e8 17       	cp	r30, r24
    1c2a:	f9 07       	cpc	r31, r25
    1c2c:	0c f0       	brlt	.+2      	; 0x1c30 <direction+0x29e>
    1c2e:	19 c1       	rjmp	.+562    	; 0x1e62 <direction+0x4d0>
	{
		w=(path1.path[t]-path1.path[t+1]);
    1c30:	af 01       	movw	r20, r30
    1c32:	4f 5f       	subi	r20, 0xFF	; 255
    1c34:	5f 4f       	sbci	r21, 0xFF	; 255
    1c36:	8b e7       	ldi	r24, 0x7B	; 123
    1c38:	92 e0       	ldi	r25, 0x02	; 2
    1c3a:	ee 0f       	add	r30, r30
    1c3c:	ff 1f       	adc	r31, r31
    1c3e:	e8 0f       	add	r30, r24
    1c40:	f9 1f       	adc	r31, r25
    1c42:	9a 01       	movw	r18, r20
    1c44:	22 0f       	add	r18, r18
    1c46:	33 1f       	adc	r19, r19
    1c48:	82 0f       	add	r24, r18
    1c4a:	93 1f       	adc	r25, r19
    1c4c:	c0 81       	ld	r28, Z
    1c4e:	d1 81       	ldd	r29, Z+1	; 0x01
    1c50:	dc 01       	movw	r26, r24
    1c52:	8d 91       	ld	r24, X+
    1c54:	9c 91       	ld	r25, X
    1c56:	c8 1b       	sub	r28, r24
    1c58:	d9 0b       	sbc	r29, r25
		t++;
    1c5a:	50 93 0f 02 	sts	0x020F, r21
    1c5e:	40 93 0e 02 	sts	0x020E, r20
		lcd_print(2,9,w,3);
    1c62:	82 e0       	ldi	r24, 0x02	; 2
    1c64:	69 e0       	ldi	r22, 0x09	; 9
    1c66:	ae 01       	movw	r20, r28
    1c68:	23 e0       	ldi	r18, 0x03	; 3
    1c6a:	30 e0       	ldi	r19, 0x00	; 0
    1c6c:	0e 94 0b 07 	call	0xe16	; 0xe16 <lcd_print>
			lcd_init();
			
		
		lcd_print(2,1,w,3);
		_delay_ms(4000);*/
		switch (w)
    1c70:	bf ef       	ldi	r27, 0xFF	; 255
    1c72:	cf 3f       	cpi	r28, 0xFF	; 255
    1c74:	db 07       	cpc	r29, r27
    1c76:	a9 f1       	breq	.+106    	; 0x1ce2 <direction+0x350>
    1c78:	ef ef       	ldi	r30, 0xFF	; 255
    1c7a:	cf 3f       	cpi	r28, 0xFF	; 255
    1c7c:	de 07       	cpc	r29, r30
    1c7e:	09 f0       	breq	.+2      	; 0x1c82 <direction+0x2f0>
    1c80:	34 f4       	brge	.+12     	; 0x1c8e <direction+0x2fc>
    1c82:	ff ef       	ldi	r31, 0xFF	; 255
    1c84:	c9 3f       	cpi	r28, 0xF9	; 249
    1c86:	df 07       	cpc	r29, r31
    1c88:	09 f0       	breq	.+2      	; 0x1c8c <direction+0x2fa>
    1c8a:	90 c0       	rjmp	.+288    	; 0x1dac <direction+0x41a>
    1c8c:	6e c0       	rjmp	.+220    	; 0x1d6a <direction+0x3d8>
    1c8e:	c1 30       	cpi	r28, 0x01	; 1
    1c90:	d1 05       	cpc	r29, r1
    1c92:	29 f0       	breq	.+10     	; 0x1c9e <direction+0x30c>
    1c94:	c7 30       	cpi	r28, 0x07	; 7
    1c96:	d1 05       	cpc	r29, r1
    1c98:	09 f0       	breq	.+2      	; 0x1c9c <direction+0x30a>
    1c9a:	88 c0       	rjmp	.+272    	; 0x1dac <direction+0x41a>
    1c9c:	44 c0       	rjmp	.+136    	; 0x1d26 <direction+0x394>
		{
			case 1:
			
				if(dir==1)
    1c9e:	80 91 09 02 	lds	r24, 0x0209
    1ca2:	90 91 0a 02 	lds	r25, 0x020A
    1ca6:	81 30       	cpi	r24, 0x01	; 1
    1ca8:	91 05       	cpc	r25, r1
    1caa:	29 f4       	brne	.+10     	; 0x1cb6 <direction+0x324>
				success(3);
    1cac:	83 e0       	ldi	r24, 0x03	; 3
    1cae:	90 e0       	ldi	r25, 0x00	; 0
    1cb0:	0e 94 2a 08 	call	0x1054	; 0x1054 <success>
    1cb4:	0f c0       	rjmp	.+30     	; 0x1cd4 <direction+0x342>
				else if(dir==3)
    1cb6:	83 30       	cpi	r24, 0x03	; 3
    1cb8:	91 05       	cpc	r25, r1
    1cba:	29 f4       	brne	.+10     	; 0x1cc6 <direction+0x334>
				success(2);
    1cbc:	82 e0       	ldi	r24, 0x02	; 2
    1cbe:	90 e0       	ldi	r25, 0x00	; 0
    1cc0:	0e 94 2a 08 	call	0x1054	; 0x1054 <success>
    1cc4:	07 c0       	rjmp	.+14     	; 0x1cd4 <direction+0x342>
				else if(dir==4)
    1cc6:	84 30       	cpi	r24, 0x04	; 4
    1cc8:	91 05       	cpc	r25, r1
    1cca:	21 f4       	brne	.+8      	; 0x1cd4 <direction+0x342>
				success(1);
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	90 e0       	ldi	r25, 0x00	; 0
    1cd0:	0e 94 2a 08 	call	0x1054	; 0x1054 <success>
				
				dir=4;
    1cd4:	84 e0       	ldi	r24, 0x04	; 4
    1cd6:	90 e0       	ldi	r25, 0x00	; 0
    1cd8:	90 93 0a 02 	sts	0x020A, r25
    1cdc:	80 93 09 02 	sts	0x0209, r24
				break;
    1ce0:	65 c0       	rjmp	.+202    	; 0x1dac <direction+0x41a>
			
			case (-1):
			
				if(dir==1)
    1ce2:	80 91 09 02 	lds	r24, 0x0209
    1ce6:	90 91 0a 02 	lds	r25, 0x020A
    1cea:	81 30       	cpi	r24, 0x01	; 1
    1cec:	91 05       	cpc	r25, r1
    1cee:	29 f4       	brne	.+10     	; 0x1cfa <direction+0x368>
				success(2);
    1cf0:	82 e0       	ldi	r24, 0x02	; 2
    1cf2:	90 e0       	ldi	r25, 0x00	; 0
    1cf4:	0e 94 2a 08 	call	0x1054	; 0x1054 <success>
    1cf8:	0f c0       	rjmp	.+30     	; 0x1d18 <direction+0x386>
				else if(dir==2)
    1cfa:	82 30       	cpi	r24, 0x02	; 2
    1cfc:	91 05       	cpc	r25, r1
    1cfe:	29 f4       	brne	.+10     	; 0x1d0a <direction+0x378>
				success(1);
    1d00:	81 e0       	ldi	r24, 0x01	; 1
    1d02:	90 e0       	ldi	r25, 0x00	; 0
    1d04:	0e 94 2a 08 	call	0x1054	; 0x1054 <success>
    1d08:	07 c0       	rjmp	.+14     	; 0x1d18 <direction+0x386>
				else if(dir==3)
    1d0a:	83 30       	cpi	r24, 0x03	; 3
    1d0c:	91 05       	cpc	r25, r1
    1d0e:	21 f4       	brne	.+8      	; 0x1d18 <direction+0x386>
				success(3);
    1d10:	83 e0       	ldi	r24, 0x03	; 3
    1d12:	90 e0       	ldi	r25, 0x00	; 0
    1d14:	0e 94 2a 08 	call	0x1054	; 0x1054 <success>
				
				dir=2;
    1d18:	82 e0       	ldi	r24, 0x02	; 2
    1d1a:	90 e0       	ldi	r25, 0x00	; 0
    1d1c:	90 93 0a 02 	sts	0x020A, r25
    1d20:	80 93 09 02 	sts	0x0209, r24
				break;
    1d24:	43 c0       	rjmp	.+134    	; 0x1dac <direction+0x41a>
				
			
			case (7):
			
				if(dir==1)
    1d26:	80 91 09 02 	lds	r24, 0x0209
    1d2a:	90 91 0a 02 	lds	r25, 0x020A
    1d2e:	81 30       	cpi	r24, 0x01	; 1
    1d30:	91 05       	cpc	r25, r1
    1d32:	29 f4       	brne	.+10     	; 0x1d3e <direction+0x3ac>
				success(1);
    1d34:	81 e0       	ldi	r24, 0x01	; 1
    1d36:	90 e0       	ldi	r25, 0x00	; 0
    1d38:	0e 94 2a 08 	call	0x1054	; 0x1054 <success>
    1d3c:	0f c0       	rjmp	.+30     	; 0x1d5c <direction+0x3ca>
				else if(dir==2)
    1d3e:	82 30       	cpi	r24, 0x02	; 2
    1d40:	91 05       	cpc	r25, r1
    1d42:	29 f4       	brne	.+10     	; 0x1d4e <direction+0x3bc>
				success(3);
    1d44:	83 e0       	ldi	r24, 0x03	; 3
    1d46:	90 e0       	ldi	r25, 0x00	; 0
    1d48:	0e 94 2a 08 	call	0x1054	; 0x1054 <success>
    1d4c:	07 c0       	rjmp	.+14     	; 0x1d5c <direction+0x3ca>
				else if(dir==4)
    1d4e:	84 30       	cpi	r24, 0x04	; 4
    1d50:	91 05       	cpc	r25, r1
    1d52:	21 f4       	brne	.+8      	; 0x1d5c <direction+0x3ca>
				success(2);
    1d54:	82 e0       	ldi	r24, 0x02	; 2
    1d56:	90 e0       	ldi	r25, 0x00	; 0
    1d58:	0e 94 2a 08 	call	0x1054	; 0x1054 <success>
				
				dir=1;
    1d5c:	81 e0       	ldi	r24, 0x01	; 1
    1d5e:	90 e0       	ldi	r25, 0x00	; 0
    1d60:	90 93 0a 02 	sts	0x020A, r25
    1d64:	80 93 09 02 	sts	0x0209, r24
				break;
    1d68:	21 c0       	rjmp	.+66     	; 0x1dac <direction+0x41a>
				
			
			case (-7):
			
				if(dir==2)
    1d6a:	80 91 09 02 	lds	r24, 0x0209
    1d6e:	90 91 0a 02 	lds	r25, 0x020A
    1d72:	82 30       	cpi	r24, 0x02	; 2
    1d74:	91 05       	cpc	r25, r1
    1d76:	29 f4       	brne	.+10     	; 0x1d82 <direction+0x3f0>
				success(2);
    1d78:	82 e0       	ldi	r24, 0x02	; 2
    1d7a:	90 e0       	ldi	r25, 0x00	; 0
    1d7c:	0e 94 2a 08 	call	0x1054	; 0x1054 <success>
    1d80:	0f c0       	rjmp	.+30     	; 0x1da0 <direction+0x40e>
				else if(dir==3)
    1d82:	83 30       	cpi	r24, 0x03	; 3
    1d84:	91 05       	cpc	r25, r1
    1d86:	29 f4       	brne	.+10     	; 0x1d92 <direction+0x400>
				success(1);
    1d88:	81 e0       	ldi	r24, 0x01	; 1
    1d8a:	90 e0       	ldi	r25, 0x00	; 0
    1d8c:	0e 94 2a 08 	call	0x1054	; 0x1054 <success>
    1d90:	07 c0       	rjmp	.+14     	; 0x1da0 <direction+0x40e>
				else if(dir==4)
    1d92:	84 30       	cpi	r24, 0x04	; 4
    1d94:	91 05       	cpc	r25, r1
    1d96:	21 f4       	brne	.+8      	; 0x1da0 <direction+0x40e>
				success(3);
    1d98:	83 e0       	ldi	r24, 0x03	; 3
    1d9a:	90 e0       	ldi	r25, 0x00	; 0
    1d9c:	0e 94 2a 08 	call	0x1054	; 0x1054 <success>
				
				dir=3;
    1da0:	83 e0       	ldi	r24, 0x03	; 3
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	90 93 0a 02 	sts	0x020A, r25
    1da8:	80 93 09 02 	sts	0x0209, r24
				break;
				
			
			
		}
		lcd_print(2,4,dir,3);
    1dac:	40 91 09 02 	lds	r20, 0x0209
    1db0:	50 91 0a 02 	lds	r21, 0x020A
    1db4:	82 e0       	ldi	r24, 0x02	; 2
    1db6:	64 e0       	ldi	r22, 0x04	; 4
    1db8:	23 e0       	ldi	r18, 0x03	; 3
    1dba:	30 e0       	ldi	r19, 0x00	; 0
    1dbc:	0e 94 0b 07 	call	0xe16	; 0xe16 <lcd_print>
    1dc0:	50 c0       	rjmp	.+160    	; 0x1e62 <direction+0x4d0>
			for(int i=0;i<10;i++)
			{	if(blue_side[i]==0)
				{
					break;
				}
				USARTWriteChar(blue_side[i]);
    1dc2:	80 91 5c 02 	lds	r24, 0x025C
    1dc6:	0e 94 c6 0c 	call	0x198c	; 0x198c <USARTWriteChar>
    1dca:	8f ef       	ldi	r24, 0xFF	; 255
    1dcc:	9f ef       	ldi	r25, 0xFF	; 255
    1dce:	ac e2       	ldi	r26, 0x2C	; 44
    1dd0:	81 50       	subi	r24, 0x01	; 1
    1dd2:	90 40       	sbci	r25, 0x00	; 0
    1dd4:	a0 40       	sbci	r26, 0x00	; 0
    1dd6:	e1 f7       	brne	.-8      	; 0x1dd0 <direction+0x43e>
    1dd8:	00 c0       	rjmp	.+0      	; 0x1dda <direction+0x448>
    1dda:	00 00       	nop
				_delay_ms(1000);
				buzzer_beep();
    1ddc:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
				_delay_ms(1000);
				buzzer_beep();
				
			}
			
			for(int i=0;i<10;i++)
    1de0:	c1 e0       	ldi	r28, 0x01	; 1
    1de2:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(blue_side[i]==0)
    1de4:	0c e5       	ldi	r16, 0x5C	; 92
    1de6:	12 e0       	ldi	r17, 0x02	; 2
    1de8:	e8 ce       	rjmp	.-560    	; 0x1bba <direction+0x228>
				{
					
					break;
					
				}
				USARTWriteChar(blue_nodes[i]);
    1dea:	80 91 37 02 	lds	r24, 0x0237
    1dee:	0e 94 c6 0c 	call	0x198c	; 0x198c <USARTWriteChar>
    1df2:	8f ef       	ldi	r24, 0xFF	; 255
    1df4:	9f ef       	ldi	r25, 0xFF	; 255
    1df6:	ac e2       	ldi	r26, 0x2C	; 44
    1df8:	81 50       	subi	r24, 0x01	; 1
    1dfa:	90 40       	sbci	r25, 0x00	; 0
    1dfc:	a0 40       	sbci	r26, 0x00	; 0
    1dfe:	e1 f7       	brne	.-8      	; 0x1df8 <direction+0x466>
    1e00:	00 c0       	rjmp	.+0      	; 0x1e02 <direction+0x470>
    1e02:	00 00       	nop
				
				_delay_ms(1000);
				buzzer_beep();
    1e04:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
			
			blue_nodes[0]=53;
			blue_nodes[b]=54;
			blue_side[0]=53;
			blue_side[bs]=54;
			for(int i=0;i<=10;i++)
    1e08:	c1 e0       	ldi	r28, 0x01	; 1
    1e0a:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(blue_nodes[i]==0)
    1e0c:	07 e3       	ldi	r16, 0x37	; 55
    1e0e:	12 e0       	ldi	r17, 0x02	; 2
    1e10:	b2 ce       	rjmp	.-668    	; 0x1b76 <direction+0x1e4>
			for(int i=0;i<10;i++)
			{	if(red_side[i]==0)
				{
					break;
				}
				USARTWriteChar(red_side[i]);
    1e12:	80 91 f4 02 	lds	r24, 0x02F4
    1e16:	0e 94 c6 0c 	call	0x198c	; 0x198c <USARTWriteChar>
    1e1a:	8f ef       	ldi	r24, 0xFF	; 255
    1e1c:	9f ef       	ldi	r25, 0xFF	; 255
    1e1e:	ac e2       	ldi	r26, 0x2C	; 44
    1e20:	81 50       	subi	r24, 0x01	; 1
    1e22:	90 40       	sbci	r25, 0x00	; 0
    1e24:	a0 40       	sbci	r26, 0x00	; 0
    1e26:	e1 f7       	brne	.-8      	; 0x1e20 <direction+0x48e>
    1e28:	00 c0       	rjmp	.+0      	; 0x1e2a <direction+0x498>
    1e2a:	00 00       	nop
				_delay_ms(1000);
				buzzer_beep();
    1e2c:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
				_delay_ms(1000);
				buzzer_beep();
				
			}
			
			for(int i=0;i<10;i++)
    1e30:	c1 e0       	ldi	r28, 0x01	; 1
    1e32:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(red_side[i]==0)
    1e34:	04 ef       	ldi	r16, 0xF4	; 244
    1e36:	12 e0       	ldi	r17, 0x02	; 2
    1e38:	6b ce       	rjmp	.-810    	; 0x1b10 <direction+0x17e>
				{
					
					break;
					
				}
				USARTWriteChar(red_nodes[i]);
    1e3a:	80 91 e3 02 	lds	r24, 0x02E3
    1e3e:	0e 94 c6 0c 	call	0x198c	; 0x198c <USARTWriteChar>
    1e42:	8f ef       	ldi	r24, 0xFF	; 255
    1e44:	9f ef       	ldi	r25, 0xFF	; 255
    1e46:	ac e2       	ldi	r26, 0x2C	; 44
    1e48:	81 50       	subi	r24, 0x01	; 1
    1e4a:	90 40       	sbci	r25, 0x00	; 0
    1e4c:	a0 40       	sbci	r26, 0x00	; 0
    1e4e:	e1 f7       	brne	.-8      	; 0x1e48 <direction+0x4b6>
    1e50:	00 c0       	rjmp	.+0      	; 0x1e52 <direction+0x4c0>
    1e52:	00 00       	nop
				
				_delay_ms(1000);
				buzzer_beep();
    1e54:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
			_delay_ms(100);
			red_nodes[0]=51;
			red_nodes[r]=52;
			red_side[0]=51;
			red_side[rs]=52;
			for(int i=0;i<=10;i++)
    1e58:	c1 e0       	ldi	r28, 0x01	; 1
    1e5a:	d0 e0       	ldi	r29, 0x00	; 0
			{	if(red_nodes[i]==0)
    1e5c:	03 ee       	ldi	r16, 0xE3	; 227
    1e5e:	12 e0       	ldi	r17, 0x02	; 2
    1e60:	35 ce       	rjmp	.-918    	; 0x1acc <direction+0x13a>
			
			
		}
		lcd_print(2,4,dir,3);
	}
}
    1e62:	df 91       	pop	r29
    1e64:	cf 91       	pop	r28
    1e66:	1f 91       	pop	r17
    1e68:	0f 91       	pop	r16
    1e6a:	08 95       	ret

00001e6c <array_init>:
int t=0;


void array_init()
{
	for(int i=0;i<=10;i++)
    1e6c:	80 e0       	ldi	r24, 0x00	; 0
    1e6e:	90 e0       	ldi	r25, 0x00	; 0
	{
		red_nodes[i]=0;
    1e70:	23 ee       	ldi	r18, 0xE3	; 227
    1e72:	32 e0       	ldi	r19, 0x02	; 2
		blue_nodes[i]=0;
    1e74:	47 e3       	ldi	r20, 0x37	; 55
    1e76:	52 e0       	ldi	r21, 0x02	; 2

void array_init()
{
	for(int i=0;i<=10;i++)
	{
		red_nodes[i]=0;
    1e78:	f9 01       	movw	r30, r18
    1e7a:	e8 0f       	add	r30, r24
    1e7c:	f9 1f       	adc	r31, r25
    1e7e:	10 82       	st	Z, r1
		blue_nodes[i]=0;
    1e80:	fa 01       	movw	r30, r20
    1e82:	e8 0f       	add	r30, r24
    1e84:	f9 1f       	adc	r31, r25
    1e86:	10 82       	st	Z, r1
int t=0;


void array_init()
{
	for(int i=0;i<=10;i++)
    1e88:	01 96       	adiw	r24, 0x01	; 1
    1e8a:	8b 30       	cpi	r24, 0x0B	; 11
    1e8c:	91 05       	cpc	r25, r1
    1e8e:	a1 f7       	brne	.-24     	; 0x1e78 <array_init+0xc>
    1e90:	80 e0       	ldi	r24, 0x00	; 0
    1e92:	90 e0       	ldi	r25, 0x00	; 0
		red_nodes[i]=0;
		blue_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
	{	
		red_side[i]=0;
    1e94:	24 ef       	ldi	r18, 0xF4	; 244
    1e96:	32 e0       	ldi	r19, 0x02	; 2
		blue_side[i]=0;
    1e98:	4c e5       	ldi	r20, 0x5C	; 92
    1e9a:	52 e0       	ldi	r21, 0x02	; 2
		red_nodes[i]=0;
		blue_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
	{	
		red_side[i]=0;
    1e9c:	f9 01       	movw	r30, r18
    1e9e:	e8 0f       	add	r30, r24
    1ea0:	f9 1f       	adc	r31, r25
    1ea2:	10 82       	st	Z, r1
		blue_side[i]=0;
    1ea4:	fa 01       	movw	r30, r20
    1ea6:	e8 0f       	add	r30, r24
    1ea8:	f9 1f       	adc	r31, r25
    1eaa:	10 82       	st	Z, r1
	for(int i=0;i<=10;i++)
	{
		red_nodes[i]=0;
		blue_nodes[i]=0;
	}
	for(int i=0;i<=20;i++)
    1eac:	01 96       	adiw	r24, 0x01	; 1
    1eae:	85 31       	cpi	r24, 0x15	; 21
    1eb0:	91 05       	cpc	r25, r1
    1eb2:	a1 f7       	brne	.-24     	; 0x1e9c <array_init+0x30>
	{	
		red_side[i]=0;
		blue_side[i]=0;
	}
}
    1eb4:	08 95       	ret

00001eb6 <ReachDestinationAvoidingNode>:
#include "zigbee.h"
#include "direction.h"


void ReachDestinationAvoidingNode(unsigned char Xd,unsigned char Yd)
{
    1eb6:	cf 93       	push	r28
    1eb8:	df 93       	push	r29
    1eba:	cd b7       	in	r28, 0x3d	; 61
    1ebc:	de b7       	in	r29, 0x3e	; 62
    1ebe:	e2 97       	sbiw	r28, 0x32	; 50
    1ec0:	0f b6       	in	r0, 0x3f	; 63
    1ec2:	f8 94       	cli
    1ec4:	de bf       	out	0x3e, r29	; 62
    1ec6:	0f be       	out	0x3f, r0	; 63
    1ec8:	cd bf       	out	0x3d, r28	; 61
	
	

	path1 = main_function7( start,des);
    1eca:	ce 01       	movw	r24, r28
    1ecc:	01 96       	adiw	r24, 0x01	; 1
    1ece:	60 91 0c 02 	lds	r22, 0x020C
    1ed2:	40 91 0b 02 	lds	r20, 0x020B
    1ed6:	0e 94 42 01 	call	0x284	; 0x284 <main_function7>
    1eda:	ab e7       	ldi	r26, 0x7B	; 123
    1edc:	b2 e0       	ldi	r27, 0x02	; 2
    1ede:	fe 01       	movw	r30, r28
    1ee0:	31 96       	adiw	r30, 0x01	; 1
    1ee2:	82 e3       	ldi	r24, 0x32	; 50
    1ee4:	01 90       	ld	r0, Z+
    1ee6:	0d 92       	st	X+, r0
    1ee8:	81 50       	subi	r24, 0x01	; 1
    1eea:	e1 f7       	brne	.-8      	; 0x1ee4 <ReachDestinationAvoidingNode+0x2e>
	
	init_devices();
    1eec:	0e 94 0b 09 	call	0x1216	; 0x1216 <init_devices>
	lcd_set_4bit();
    1ef0:	0e 94 36 06 	call	0xc6c	; 0xc6c <lcd_set_4bit>
	lcd_init();
    1ef4:	0e 94 9e 06 	call	0xd3c	; 0xd3c <lcd_init>
	_delay_ms(1000);	
	}*/
	
	while(1)
	{
		line_follower();
    1ef8:	0e 94 14 09 	call	0x1228	; 0x1228 <line_follower>
		if (g==1)
    1efc:	80 91 29 02 	lds	r24, 0x0229
    1f00:	90 91 2a 02 	lds	r25, 0x022A
    1f04:	81 30       	cpi	r24, 0x01	; 1
    1f06:	91 05       	cpc	r25, r1
    1f08:	b9 f7       	brne	.-18     	; 0x1ef8 <ReachDestinationAvoidingNode+0x42>
	}
	/*buzzer_on();
	_delay_ms(500);
	buzzer_off();*/
	
	g=0;
    1f0a:	10 92 2a 02 	sts	0x022A, r1
    1f0e:	10 92 29 02 	sts	0x0229, r1
	l=0;
    1f12:	10 92 18 02 	sts	0x0218, r1
    1f16:	10 92 17 02 	sts	0x0217, r1
	t=0;
    1f1a:	10 92 0f 02 	sts	0x020F, r1
    1f1e:	10 92 0e 02 	sts	0x020E, r1
	back();
    1f22:	0e 94 22 08 	call	0x1044	; 0x1044 <back>
	velocity(100,100);
    1f26:	84 e6       	ldi	r24, 0x64	; 100
    1f28:	64 e6       	ldi	r22, 0x64	; 100
    1f2a:	0e 94 17 08 	call	0x102e	; 0x102e <velocity>
	//_delay_ms(1500);
	start=des;
    1f2e:	80 91 0b 02 	lds	r24, 0x020B
    1f32:	80 93 0c 02 	sts	0x020C, r24



}
    1f36:	e2 96       	adiw	r28, 0x32	; 50
    1f38:	0f b6       	in	r0, 0x3f	; 63
    1f3a:	f8 94       	cli
    1f3c:	de bf       	out	0x3e, r29	; 62
    1f3e:	0f be       	out	0x3f, r0	; 63
    1f40:	cd bf       	out	0x3d, r28	; 61
    1f42:	df 91       	pop	r29
    1f44:	cf 91       	pop	r28
    1f46:	08 95       	ret

00001f48 <main>:


//Do not make changes in main function

int main(void)
{		init_devices1();//pos
    1f48:	0e 94 13 05 	call	0xa26	; 0xa26 <init_devices1>
	init_devices_xbee();
    1f4c:	0e 94 bf 0c 	call	0x197e	; 0x197e <init_devices_xbee>
		buzzer_beep();
    1f50:	0e 94 2b 01 	call	0x256	; 0x256 <buzzer_beep>
    1f54:	8f ef       	ldi	r24, 0xFF	; 255
    1f56:	9f ef       	ldi	r25, 0xFF	; 255
    1f58:	ac e2       	ldi	r26, 0x2C	; 44
    1f5a:	81 50       	subi	r24, 0x01	; 1
    1f5c:	90 40       	sbci	r25, 0x00	; 0
    1f5e:	a0 40       	sbci	r26, 0x00	; 0
    1f60:	e1 f7       	brne	.-8      	; 0x1f5a <main+0x12>
    1f62:	00 c0       	rjmp	.+0      	; 0x1f64 <main+0x1c>
    1f64:	00 00       	nop
		_delay_ms(1000);
	start=40;
    1f66:	88 e2       	ldi	r24, 0x28	; 40
    1f68:	80 93 0c 02 	sts	0x020C, r24
	des=2;
    1f6c:	82 e0       	ldi	r24, 0x02	; 2
    1f6e:	80 93 0b 02 	sts	0x020B, r24
	ReachDestinationAvoidingNode(start,des);//40-2
    1f72:	88 e2       	ldi	r24, 0x28	; 40
    1f74:	62 e0       	ldi	r22, 0x02	; 2
    1f76:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <ReachDestinationAvoidingNode>
	  buzzer_on();
    1f7a:	0e 94 23 01 	call	0x246	; 0x246 <buzzer_on>
    1f7e:	8f ef       	ldi	r24, 0xFF	; 255
    1f80:	9f ef       	ldi	r25, 0xFF	; 255
    1f82:	ac e2       	ldi	r26, 0x2C	; 44
    1f84:	81 50       	subi	r24, 0x01	; 1
    1f86:	90 40       	sbci	r25, 0x00	; 0
    1f88:	a0 40       	sbci	r26, 0x00	; 0
    1f8a:	e1 f7       	brne	.-8      	; 0x1f84 <main+0x3c>
    1f8c:	00 c0       	rjmp	.+0      	; 0x1f8e <main+0x46>
    1f8e:	00 00       	nop
	  _delay_ms(1000);
	  buzzer_off();
    1f90:	0e 94 27 01 	call	0x24e	; 0x24e <buzzer_off>
	 stage=2;
    1f94:	82 e0       	ldi	r24, 0x02	; 2
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	90 93 08 02 	sts	0x0208, r25
    1f9c:	80 93 07 02 	sts	0x0207, r24
	 des=44;
    1fa0:	8c e2       	ldi	r24, 0x2C	; 44
    1fa2:	80 93 0b 02 	sts	0x020B, r24
		 array_init();
    1fa6:	0e 94 36 0f 	call	0x1e6c	; 0x1e6c <array_init>
		 ReachDestinationAvoidingNode(start,des);//2-44
    1faa:	80 91 0c 02 	lds	r24, 0x020C
    1fae:	60 91 0b 02 	lds	r22, 0x020B
    1fb2:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <ReachDestinationAvoidingNode>
		 buzzer_on();
    1fb6:	0e 94 23 01 	call	0x246	; 0x246 <buzzer_on>
    1fba:	8f ef       	ldi	r24, 0xFF	; 255
    1fbc:	9f ef       	ldi	r25, 0xFF	; 255
    1fbe:	ac e2       	ldi	r26, 0x2C	; 44
    1fc0:	81 50       	subi	r24, 0x01	; 1
    1fc2:	90 40       	sbci	r25, 0x00	; 0
    1fc4:	a0 40       	sbci	r26, 0x00	; 0
    1fc6:	e1 f7       	brne	.-8      	; 0x1fc0 <main+0x78>
    1fc8:	00 c0       	rjmp	.+0      	; 0x1fca <main+0x82>
    1fca:	00 00       	nop
		 _delay_ms(1000);
		 buzzer_off();
    1fcc:	0e 94 27 01 	call	0x24e	; 0x24e <buzzer_off>
		 stage=3;
    1fd0:	83 e0       	ldi	r24, 0x03	; 3
    1fd2:	90 e0       	ldi	r25, 0x00	; 0
    1fd4:	90 93 08 02 	sts	0x0208, r25
    1fd8:	80 93 07 02 	sts	0x0207, r24
		 des=4;
    1fdc:	84 e0       	ldi	r24, 0x04	; 4
    1fde:	80 93 0b 02 	sts	0x020B, r24
		  ReachDestinationAvoidingNode(start,des);//44-4
    1fe2:	80 91 0c 02 	lds	r24, 0x020C
    1fe6:	64 e0       	ldi	r22, 0x04	; 4
    1fe8:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <ReachDestinationAvoidingNode>
		  buzzer_on();
    1fec:	0e 94 23 01 	call	0x246	; 0x246 <buzzer_on>
    1ff0:	8f ef       	ldi	r24, 0xFF	; 255
    1ff2:	9f ef       	ldi	r25, 0xFF	; 255
    1ff4:	ac e2       	ldi	r26, 0x2C	; 44
    1ff6:	81 50       	subi	r24, 0x01	; 1
    1ff8:	90 40       	sbci	r25, 0x00	; 0
    1ffa:	a0 40       	sbci	r26, 0x00	; 0
    1ffc:	e1 f7       	brne	.-8      	; 0x1ff6 <main+0xae>
    1ffe:	00 c0       	rjmp	.+0      	; 0x2000 <main+0xb8>
    2000:	00 00       	nop
		  _delay_ms(1000);
		  buzzer_off();
    2002:	0e 94 27 01 	call	0x24e	; 0x24e <buzzer_off>
		  des=41;
    2006:	89 e2       	ldi	r24, 0x29	; 41
    2008:	80 93 0b 02 	sts	0x020B, r24
		  ReachDestinationAvoidingNode(start,des);//4-41
    200c:	80 91 0c 02 	lds	r24, 0x020C
    2010:	69 e2       	ldi	r22, 0x29	; 41
    2012:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <ReachDestinationAvoidingNode>
		  buzzer_on();
    2016:	0e 94 23 01 	call	0x246	; 0x246 <buzzer_on>
    201a:	8f ef       	ldi	r24, 0xFF	; 255
    201c:	9f ef       	ldi	r25, 0xFF	; 255
    201e:	ac e2       	ldi	r26, 0x2C	; 44
    2020:	81 50       	subi	r24, 0x01	; 1
    2022:	90 40       	sbci	r25, 0x00	; 0
    2024:	a0 40       	sbci	r26, 0x00	; 0
    2026:	e1 f7       	brne	.-8      	; 0x2020 <main+0xd8>
    2028:	00 c0       	rjmp	.+0      	; 0x202a <main+0xe2>
    202a:	00 00       	nop
		  _delay_ms(1000);
		  buzzer_off();
    202c:	0e 94 27 01 	call	0x24e	; 0x24e <buzzer_off>
		  des=42;
    2030:	8a e2       	ldi	r24, 0x2A	; 42
    2032:	80 93 0b 02 	sts	0x020B, r24
		  ReachDestinationAvoidingNode(start,des);//41-42
    2036:	80 91 0c 02 	lds	r24, 0x020C
    203a:	6a e2       	ldi	r22, 0x2A	; 42
    203c:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <ReachDestinationAvoidingNode>
		  buzzer_on();
    2040:	0e 94 23 01 	call	0x246	; 0x246 <buzzer_on>
    2044:	8f ef       	ldi	r24, 0xFF	; 255
    2046:	9f ef       	ldi	r25, 0xFF	; 255
    2048:	ac e2       	ldi	r26, 0x2C	; 44
    204a:	81 50       	subi	r24, 0x01	; 1
    204c:	90 40       	sbci	r25, 0x00	; 0
    204e:	a0 40       	sbci	r26, 0x00	; 0
    2050:	e1 f7       	brne	.-8      	; 0x204a <main+0x102>
    2052:	00 c0       	rjmp	.+0      	; 0x2054 <main+0x10c>
    2054:	00 00       	nop
		  _delay_ms(1000);
		  buzzer_off();
    2056:	0e 94 27 01 	call	0x24e	; 0x24e <buzzer_off>
		  des=46;
    205a:	8e e2       	ldi	r24, 0x2E	; 46
    205c:	80 93 0b 02 	sts	0x020B, r24
		  ReachDestinationAvoidingNode(start,des);//42-46
    2060:	80 91 0c 02 	lds	r24, 0x020C
    2064:	6e e2       	ldi	r22, 0x2E	; 46
    2066:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <ReachDestinationAvoidingNode>
		  buzzer_on();
    206a:	0e 94 23 01 	call	0x246	; 0x246 <buzzer_on>
    206e:	8f ef       	ldi	r24, 0xFF	; 255
    2070:	9f ef       	ldi	r25, 0xFF	; 255
    2072:	ac e2       	ldi	r26, 0x2C	; 44
    2074:	81 50       	subi	r24, 0x01	; 1
    2076:	90 40       	sbci	r25, 0x00	; 0
    2078:	a0 40       	sbci	r26, 0x00	; 0
    207a:	e1 f7       	brne	.-8      	; 0x2074 <main+0x12c>
    207c:	00 c0       	rjmp	.+0      	; 0x207e <main+0x136>
    207e:	00 00       	nop
		  _delay_ms(1000);
		  buzzer_off();
    2080:	0e 94 27 01 	call	0x24e	; 0x24e <buzzer_off>
	 

}
    2084:	80 e0       	ldi	r24, 0x00	; 0
    2086:	90 e0       	ldi	r25, 0x00	; 0
    2088:	08 95       	ret

0000208a <__subsf3>:
    208a:	50 58       	subi	r21, 0x80	; 128

0000208c <__addsf3>:
    208c:	bb 27       	eor	r27, r27
    208e:	aa 27       	eor	r26, r26
    2090:	0e d0       	rcall	.+28     	; 0x20ae <__addsf3x>
    2092:	4d c1       	rjmp	.+666    	; 0x232e <__fp_round>
    2094:	3e d1       	rcall	.+636    	; 0x2312 <__fp_pscA>
    2096:	30 f0       	brcs	.+12     	; 0x20a4 <__addsf3+0x18>
    2098:	43 d1       	rcall	.+646    	; 0x2320 <__fp_pscB>
    209a:	20 f0       	brcs	.+8      	; 0x20a4 <__addsf3+0x18>
    209c:	31 f4       	brne	.+12     	; 0x20aa <__addsf3+0x1e>
    209e:	9f 3f       	cpi	r25, 0xFF	; 255
    20a0:	11 f4       	brne	.+4      	; 0x20a6 <__addsf3+0x1a>
    20a2:	1e f4       	brtc	.+6      	; 0x20aa <__addsf3+0x1e>
    20a4:	33 c1       	rjmp	.+614    	; 0x230c <__fp_nan>
    20a6:	0e f4       	brtc	.+2      	; 0x20aa <__addsf3+0x1e>
    20a8:	e0 95       	com	r30
    20aa:	e7 fb       	bst	r30, 7
    20ac:	29 c1       	rjmp	.+594    	; 0x2300 <__fp_inf>

000020ae <__addsf3x>:
    20ae:	e9 2f       	mov	r30, r25
    20b0:	4f d1       	rcall	.+670    	; 0x2350 <__fp_split3>
    20b2:	80 f3       	brcs	.-32     	; 0x2094 <__addsf3+0x8>
    20b4:	ba 17       	cp	r27, r26
    20b6:	62 07       	cpc	r22, r18
    20b8:	73 07       	cpc	r23, r19
    20ba:	84 07       	cpc	r24, r20
    20bc:	95 07       	cpc	r25, r21
    20be:	18 f0       	brcs	.+6      	; 0x20c6 <__addsf3x+0x18>
    20c0:	71 f4       	brne	.+28     	; 0x20de <__addsf3x+0x30>
    20c2:	9e f5       	brtc	.+102    	; 0x212a <__addsf3x+0x7c>
    20c4:	67 c1       	rjmp	.+718    	; 0x2394 <__fp_zero>
    20c6:	0e f4       	brtc	.+2      	; 0x20ca <__addsf3x+0x1c>
    20c8:	e0 95       	com	r30
    20ca:	0b 2e       	mov	r0, r27
    20cc:	ba 2f       	mov	r27, r26
    20ce:	a0 2d       	mov	r26, r0
    20d0:	0b 01       	movw	r0, r22
    20d2:	b9 01       	movw	r22, r18
    20d4:	90 01       	movw	r18, r0
    20d6:	0c 01       	movw	r0, r24
    20d8:	ca 01       	movw	r24, r20
    20da:	a0 01       	movw	r20, r0
    20dc:	11 24       	eor	r1, r1
    20de:	ff 27       	eor	r31, r31
    20e0:	59 1b       	sub	r21, r25
    20e2:	99 f0       	breq	.+38     	; 0x210a <__addsf3x+0x5c>
    20e4:	59 3f       	cpi	r21, 0xF9	; 249
    20e6:	50 f4       	brcc	.+20     	; 0x20fc <__addsf3x+0x4e>
    20e8:	50 3e       	cpi	r21, 0xE0	; 224
    20ea:	68 f1       	brcs	.+90     	; 0x2146 <__addsf3x+0x98>
    20ec:	1a 16       	cp	r1, r26
    20ee:	f0 40       	sbci	r31, 0x00	; 0
    20f0:	a2 2f       	mov	r26, r18
    20f2:	23 2f       	mov	r18, r19
    20f4:	34 2f       	mov	r19, r20
    20f6:	44 27       	eor	r20, r20
    20f8:	58 5f       	subi	r21, 0xF8	; 248
    20fa:	f3 cf       	rjmp	.-26     	; 0x20e2 <__addsf3x+0x34>
    20fc:	46 95       	lsr	r20
    20fe:	37 95       	ror	r19
    2100:	27 95       	ror	r18
    2102:	a7 95       	ror	r26
    2104:	f0 40       	sbci	r31, 0x00	; 0
    2106:	53 95       	inc	r21
    2108:	c9 f7       	brne	.-14     	; 0x20fc <__addsf3x+0x4e>
    210a:	7e f4       	brtc	.+30     	; 0x212a <__addsf3x+0x7c>
    210c:	1f 16       	cp	r1, r31
    210e:	ba 0b       	sbc	r27, r26
    2110:	62 0b       	sbc	r22, r18
    2112:	73 0b       	sbc	r23, r19
    2114:	84 0b       	sbc	r24, r20
    2116:	ba f0       	brmi	.+46     	; 0x2146 <__addsf3x+0x98>
    2118:	91 50       	subi	r25, 0x01	; 1
    211a:	a1 f0       	breq	.+40     	; 0x2144 <__addsf3x+0x96>
    211c:	ff 0f       	add	r31, r31
    211e:	bb 1f       	adc	r27, r27
    2120:	66 1f       	adc	r22, r22
    2122:	77 1f       	adc	r23, r23
    2124:	88 1f       	adc	r24, r24
    2126:	c2 f7       	brpl	.-16     	; 0x2118 <__addsf3x+0x6a>
    2128:	0e c0       	rjmp	.+28     	; 0x2146 <__addsf3x+0x98>
    212a:	ba 0f       	add	r27, r26
    212c:	62 1f       	adc	r22, r18
    212e:	73 1f       	adc	r23, r19
    2130:	84 1f       	adc	r24, r20
    2132:	48 f4       	brcc	.+18     	; 0x2146 <__addsf3x+0x98>
    2134:	87 95       	ror	r24
    2136:	77 95       	ror	r23
    2138:	67 95       	ror	r22
    213a:	b7 95       	ror	r27
    213c:	f7 95       	ror	r31
    213e:	9e 3f       	cpi	r25, 0xFE	; 254
    2140:	08 f0       	brcs	.+2      	; 0x2144 <__addsf3x+0x96>
    2142:	b3 cf       	rjmp	.-154    	; 0x20aa <__addsf3+0x1e>
    2144:	93 95       	inc	r25
    2146:	88 0f       	add	r24, r24
    2148:	08 f0       	brcs	.+2      	; 0x214c <__addsf3x+0x9e>
    214a:	99 27       	eor	r25, r25
    214c:	ee 0f       	add	r30, r30
    214e:	97 95       	ror	r25
    2150:	87 95       	ror	r24
    2152:	08 95       	ret

00002154 <__divsf3>:
    2154:	0c d0       	rcall	.+24     	; 0x216e <__divsf3x>
    2156:	eb c0       	rjmp	.+470    	; 0x232e <__fp_round>
    2158:	e3 d0       	rcall	.+454    	; 0x2320 <__fp_pscB>
    215a:	40 f0       	brcs	.+16     	; 0x216c <__divsf3+0x18>
    215c:	da d0       	rcall	.+436    	; 0x2312 <__fp_pscA>
    215e:	30 f0       	brcs	.+12     	; 0x216c <__divsf3+0x18>
    2160:	21 f4       	brne	.+8      	; 0x216a <__divsf3+0x16>
    2162:	5f 3f       	cpi	r21, 0xFF	; 255
    2164:	19 f0       	breq	.+6      	; 0x216c <__divsf3+0x18>
    2166:	cc c0       	rjmp	.+408    	; 0x2300 <__fp_inf>
    2168:	51 11       	cpse	r21, r1
    216a:	15 c1       	rjmp	.+554    	; 0x2396 <__fp_szero>
    216c:	cf c0       	rjmp	.+414    	; 0x230c <__fp_nan>

0000216e <__divsf3x>:
    216e:	f0 d0       	rcall	.+480    	; 0x2350 <__fp_split3>
    2170:	98 f3       	brcs	.-26     	; 0x2158 <__divsf3+0x4>

00002172 <__divsf3_pse>:
    2172:	99 23       	and	r25, r25
    2174:	c9 f3       	breq	.-14     	; 0x2168 <__divsf3+0x14>
    2176:	55 23       	and	r21, r21
    2178:	b1 f3       	breq	.-20     	; 0x2166 <__divsf3+0x12>
    217a:	95 1b       	sub	r25, r21
    217c:	55 0b       	sbc	r21, r21
    217e:	bb 27       	eor	r27, r27
    2180:	aa 27       	eor	r26, r26
    2182:	62 17       	cp	r22, r18
    2184:	73 07       	cpc	r23, r19
    2186:	84 07       	cpc	r24, r20
    2188:	38 f0       	brcs	.+14     	; 0x2198 <__divsf3_pse+0x26>
    218a:	9f 5f       	subi	r25, 0xFF	; 255
    218c:	5f 4f       	sbci	r21, 0xFF	; 255
    218e:	22 0f       	add	r18, r18
    2190:	33 1f       	adc	r19, r19
    2192:	44 1f       	adc	r20, r20
    2194:	aa 1f       	adc	r26, r26
    2196:	a9 f3       	breq	.-22     	; 0x2182 <__divsf3_pse+0x10>
    2198:	33 d0       	rcall	.+102    	; 0x2200 <__stack+0x1>
    219a:	0e 2e       	mov	r0, r30
    219c:	3a f0       	brmi	.+14     	; 0x21ac <__divsf3_pse+0x3a>
    219e:	e0 e8       	ldi	r30, 0x80	; 128
    21a0:	30 d0       	rcall	.+96     	; 0x2202 <__stack+0x3>
    21a2:	91 50       	subi	r25, 0x01	; 1
    21a4:	50 40       	sbci	r21, 0x00	; 0
    21a6:	e6 95       	lsr	r30
    21a8:	00 1c       	adc	r0, r0
    21aa:	ca f7       	brpl	.-14     	; 0x219e <__divsf3_pse+0x2c>
    21ac:	29 d0       	rcall	.+82     	; 0x2200 <__stack+0x1>
    21ae:	fe 2f       	mov	r31, r30
    21b0:	27 d0       	rcall	.+78     	; 0x2200 <__stack+0x1>
    21b2:	66 0f       	add	r22, r22
    21b4:	77 1f       	adc	r23, r23
    21b6:	88 1f       	adc	r24, r24
    21b8:	bb 1f       	adc	r27, r27
    21ba:	26 17       	cp	r18, r22
    21bc:	37 07       	cpc	r19, r23
    21be:	48 07       	cpc	r20, r24
    21c0:	ab 07       	cpc	r26, r27
    21c2:	b0 e8       	ldi	r27, 0x80	; 128
    21c4:	09 f0       	breq	.+2      	; 0x21c8 <__divsf3_pse+0x56>
    21c6:	bb 0b       	sbc	r27, r27
    21c8:	80 2d       	mov	r24, r0
    21ca:	bf 01       	movw	r22, r30
    21cc:	ff 27       	eor	r31, r31
    21ce:	93 58       	subi	r25, 0x83	; 131
    21d0:	5f 4f       	sbci	r21, 0xFF	; 255
    21d2:	2a f0       	brmi	.+10     	; 0x21de <__divsf3_pse+0x6c>
    21d4:	9e 3f       	cpi	r25, 0xFE	; 254
    21d6:	51 05       	cpc	r21, r1
    21d8:	68 f0       	brcs	.+26     	; 0x21f4 <__divsf3_pse+0x82>
    21da:	92 c0       	rjmp	.+292    	; 0x2300 <__fp_inf>
    21dc:	dc c0       	rjmp	.+440    	; 0x2396 <__fp_szero>
    21de:	5f 3f       	cpi	r21, 0xFF	; 255
    21e0:	ec f3       	brlt	.-6      	; 0x21dc <__divsf3_pse+0x6a>
    21e2:	98 3e       	cpi	r25, 0xE8	; 232
    21e4:	dc f3       	brlt	.-10     	; 0x21dc <__divsf3_pse+0x6a>
    21e6:	86 95       	lsr	r24
    21e8:	77 95       	ror	r23
    21ea:	67 95       	ror	r22
    21ec:	b7 95       	ror	r27
    21ee:	f7 95       	ror	r31
    21f0:	9f 5f       	subi	r25, 0xFF	; 255
    21f2:	c9 f7       	brne	.-14     	; 0x21e6 <__divsf3_pse+0x74>
    21f4:	88 0f       	add	r24, r24
    21f6:	91 1d       	adc	r25, r1
    21f8:	96 95       	lsr	r25
    21fa:	87 95       	ror	r24
    21fc:	97 f9       	bld	r25, 7
    21fe:	08 95       	ret
    2200:	e1 e0       	ldi	r30, 0x01	; 1
    2202:	66 0f       	add	r22, r22
    2204:	77 1f       	adc	r23, r23
    2206:	88 1f       	adc	r24, r24
    2208:	bb 1f       	adc	r27, r27
    220a:	62 17       	cp	r22, r18
    220c:	73 07       	cpc	r23, r19
    220e:	84 07       	cpc	r24, r20
    2210:	ba 07       	cpc	r27, r26
    2212:	20 f0       	brcs	.+8      	; 0x221c <__stack+0x1d>
    2214:	62 1b       	sub	r22, r18
    2216:	73 0b       	sbc	r23, r19
    2218:	84 0b       	sbc	r24, r20
    221a:	ba 0b       	sbc	r27, r26
    221c:	ee 1f       	adc	r30, r30
    221e:	88 f7       	brcc	.-30     	; 0x2202 <__stack+0x3>
    2220:	e0 95       	com	r30
    2222:	08 95       	ret

00002224 <__fixsfsi>:
    2224:	04 d0       	rcall	.+8      	; 0x222e <__fixunssfsi>
    2226:	68 94       	set
    2228:	b1 11       	cpse	r27, r1
    222a:	b5 c0       	rjmp	.+362    	; 0x2396 <__fp_szero>
    222c:	08 95       	ret

0000222e <__fixunssfsi>:
    222e:	98 d0       	rcall	.+304    	; 0x2360 <__fp_splitA>
    2230:	88 f0       	brcs	.+34     	; 0x2254 <__fixunssfsi+0x26>
    2232:	9f 57       	subi	r25, 0x7F	; 127
    2234:	90 f0       	brcs	.+36     	; 0x225a <__fixunssfsi+0x2c>
    2236:	b9 2f       	mov	r27, r25
    2238:	99 27       	eor	r25, r25
    223a:	b7 51       	subi	r27, 0x17	; 23
    223c:	a0 f0       	brcs	.+40     	; 0x2266 <__fixunssfsi+0x38>
    223e:	d1 f0       	breq	.+52     	; 0x2274 <__fixunssfsi+0x46>
    2240:	66 0f       	add	r22, r22
    2242:	77 1f       	adc	r23, r23
    2244:	88 1f       	adc	r24, r24
    2246:	99 1f       	adc	r25, r25
    2248:	1a f0       	brmi	.+6      	; 0x2250 <__fixunssfsi+0x22>
    224a:	ba 95       	dec	r27
    224c:	c9 f7       	brne	.-14     	; 0x2240 <__fixunssfsi+0x12>
    224e:	12 c0       	rjmp	.+36     	; 0x2274 <__fixunssfsi+0x46>
    2250:	b1 30       	cpi	r27, 0x01	; 1
    2252:	81 f0       	breq	.+32     	; 0x2274 <__fixunssfsi+0x46>
    2254:	9f d0       	rcall	.+318    	; 0x2394 <__fp_zero>
    2256:	b1 e0       	ldi	r27, 0x01	; 1
    2258:	08 95       	ret
    225a:	9c c0       	rjmp	.+312    	; 0x2394 <__fp_zero>
    225c:	67 2f       	mov	r22, r23
    225e:	78 2f       	mov	r23, r24
    2260:	88 27       	eor	r24, r24
    2262:	b8 5f       	subi	r27, 0xF8	; 248
    2264:	39 f0       	breq	.+14     	; 0x2274 <__fixunssfsi+0x46>
    2266:	b9 3f       	cpi	r27, 0xF9	; 249
    2268:	cc f3       	brlt	.-14     	; 0x225c <__fixunssfsi+0x2e>
    226a:	86 95       	lsr	r24
    226c:	77 95       	ror	r23
    226e:	67 95       	ror	r22
    2270:	b3 95       	inc	r27
    2272:	d9 f7       	brne	.-10     	; 0x226a <__fixunssfsi+0x3c>
    2274:	3e f4       	brtc	.+14     	; 0x2284 <__fixunssfsi+0x56>
    2276:	90 95       	com	r25
    2278:	80 95       	com	r24
    227a:	70 95       	com	r23
    227c:	61 95       	neg	r22
    227e:	7f 4f       	sbci	r23, 0xFF	; 255
    2280:	8f 4f       	sbci	r24, 0xFF	; 255
    2282:	9f 4f       	sbci	r25, 0xFF	; 255
    2284:	08 95       	ret

00002286 <__floatunsisf>:
    2286:	e8 94       	clt
    2288:	09 c0       	rjmp	.+18     	; 0x229c <__floatsisf+0x12>

0000228a <__floatsisf>:
    228a:	97 fb       	bst	r25, 7
    228c:	3e f4       	brtc	.+14     	; 0x229c <__floatsisf+0x12>
    228e:	90 95       	com	r25
    2290:	80 95       	com	r24
    2292:	70 95       	com	r23
    2294:	61 95       	neg	r22
    2296:	7f 4f       	sbci	r23, 0xFF	; 255
    2298:	8f 4f       	sbci	r24, 0xFF	; 255
    229a:	9f 4f       	sbci	r25, 0xFF	; 255
    229c:	99 23       	and	r25, r25
    229e:	a9 f0       	breq	.+42     	; 0x22ca <__floatsisf+0x40>
    22a0:	f9 2f       	mov	r31, r25
    22a2:	96 e9       	ldi	r25, 0x96	; 150
    22a4:	bb 27       	eor	r27, r27
    22a6:	93 95       	inc	r25
    22a8:	f6 95       	lsr	r31
    22aa:	87 95       	ror	r24
    22ac:	77 95       	ror	r23
    22ae:	67 95       	ror	r22
    22b0:	b7 95       	ror	r27
    22b2:	f1 11       	cpse	r31, r1
    22b4:	f8 cf       	rjmp	.-16     	; 0x22a6 <__floatsisf+0x1c>
    22b6:	fa f4       	brpl	.+62     	; 0x22f6 <__floatsisf+0x6c>
    22b8:	bb 0f       	add	r27, r27
    22ba:	11 f4       	brne	.+4      	; 0x22c0 <__floatsisf+0x36>
    22bc:	60 ff       	sbrs	r22, 0
    22be:	1b c0       	rjmp	.+54     	; 0x22f6 <__floatsisf+0x6c>
    22c0:	6f 5f       	subi	r22, 0xFF	; 255
    22c2:	7f 4f       	sbci	r23, 0xFF	; 255
    22c4:	8f 4f       	sbci	r24, 0xFF	; 255
    22c6:	9f 4f       	sbci	r25, 0xFF	; 255
    22c8:	16 c0       	rjmp	.+44     	; 0x22f6 <__floatsisf+0x6c>
    22ca:	88 23       	and	r24, r24
    22cc:	11 f0       	breq	.+4      	; 0x22d2 <__floatsisf+0x48>
    22ce:	96 e9       	ldi	r25, 0x96	; 150
    22d0:	11 c0       	rjmp	.+34     	; 0x22f4 <__floatsisf+0x6a>
    22d2:	77 23       	and	r23, r23
    22d4:	21 f0       	breq	.+8      	; 0x22de <__floatsisf+0x54>
    22d6:	9e e8       	ldi	r25, 0x8E	; 142
    22d8:	87 2f       	mov	r24, r23
    22da:	76 2f       	mov	r23, r22
    22dc:	05 c0       	rjmp	.+10     	; 0x22e8 <__floatsisf+0x5e>
    22de:	66 23       	and	r22, r22
    22e0:	71 f0       	breq	.+28     	; 0x22fe <__floatsisf+0x74>
    22e2:	96 e8       	ldi	r25, 0x86	; 134
    22e4:	86 2f       	mov	r24, r22
    22e6:	70 e0       	ldi	r23, 0x00	; 0
    22e8:	60 e0       	ldi	r22, 0x00	; 0
    22ea:	2a f0       	brmi	.+10     	; 0x22f6 <__floatsisf+0x6c>
    22ec:	9a 95       	dec	r25
    22ee:	66 0f       	add	r22, r22
    22f0:	77 1f       	adc	r23, r23
    22f2:	88 1f       	adc	r24, r24
    22f4:	da f7       	brpl	.-10     	; 0x22ec <__floatsisf+0x62>
    22f6:	88 0f       	add	r24, r24
    22f8:	96 95       	lsr	r25
    22fa:	87 95       	ror	r24
    22fc:	97 f9       	bld	r25, 7
    22fe:	08 95       	ret

00002300 <__fp_inf>:
    2300:	97 f9       	bld	r25, 7
    2302:	9f 67       	ori	r25, 0x7F	; 127
    2304:	80 e8       	ldi	r24, 0x80	; 128
    2306:	70 e0       	ldi	r23, 0x00	; 0
    2308:	60 e0       	ldi	r22, 0x00	; 0
    230a:	08 95       	ret

0000230c <__fp_nan>:
    230c:	9f ef       	ldi	r25, 0xFF	; 255
    230e:	80 ec       	ldi	r24, 0xC0	; 192
    2310:	08 95       	ret

00002312 <__fp_pscA>:
    2312:	00 24       	eor	r0, r0
    2314:	0a 94       	dec	r0
    2316:	16 16       	cp	r1, r22
    2318:	17 06       	cpc	r1, r23
    231a:	18 06       	cpc	r1, r24
    231c:	09 06       	cpc	r0, r25
    231e:	08 95       	ret

00002320 <__fp_pscB>:
    2320:	00 24       	eor	r0, r0
    2322:	0a 94       	dec	r0
    2324:	12 16       	cp	r1, r18
    2326:	13 06       	cpc	r1, r19
    2328:	14 06       	cpc	r1, r20
    232a:	05 06       	cpc	r0, r21
    232c:	08 95       	ret

0000232e <__fp_round>:
    232e:	09 2e       	mov	r0, r25
    2330:	03 94       	inc	r0
    2332:	00 0c       	add	r0, r0
    2334:	11 f4       	brne	.+4      	; 0x233a <__fp_round+0xc>
    2336:	88 23       	and	r24, r24
    2338:	52 f0       	brmi	.+20     	; 0x234e <__fp_round+0x20>
    233a:	bb 0f       	add	r27, r27
    233c:	40 f4       	brcc	.+16     	; 0x234e <__fp_round+0x20>
    233e:	bf 2b       	or	r27, r31
    2340:	11 f4       	brne	.+4      	; 0x2346 <__fp_round+0x18>
    2342:	60 ff       	sbrs	r22, 0
    2344:	04 c0       	rjmp	.+8      	; 0x234e <__fp_round+0x20>
    2346:	6f 5f       	subi	r22, 0xFF	; 255
    2348:	7f 4f       	sbci	r23, 0xFF	; 255
    234a:	8f 4f       	sbci	r24, 0xFF	; 255
    234c:	9f 4f       	sbci	r25, 0xFF	; 255
    234e:	08 95       	ret

00002350 <__fp_split3>:
    2350:	57 fd       	sbrc	r21, 7
    2352:	90 58       	subi	r25, 0x80	; 128
    2354:	44 0f       	add	r20, r20
    2356:	55 1f       	adc	r21, r21
    2358:	59 f0       	breq	.+22     	; 0x2370 <__fp_splitA+0x10>
    235a:	5f 3f       	cpi	r21, 0xFF	; 255
    235c:	71 f0       	breq	.+28     	; 0x237a <__fp_splitA+0x1a>
    235e:	47 95       	ror	r20

00002360 <__fp_splitA>:
    2360:	88 0f       	add	r24, r24
    2362:	97 fb       	bst	r25, 7
    2364:	99 1f       	adc	r25, r25
    2366:	61 f0       	breq	.+24     	; 0x2380 <__fp_splitA+0x20>
    2368:	9f 3f       	cpi	r25, 0xFF	; 255
    236a:	79 f0       	breq	.+30     	; 0x238a <__fp_splitA+0x2a>
    236c:	87 95       	ror	r24
    236e:	08 95       	ret
    2370:	12 16       	cp	r1, r18
    2372:	13 06       	cpc	r1, r19
    2374:	14 06       	cpc	r1, r20
    2376:	55 1f       	adc	r21, r21
    2378:	f2 cf       	rjmp	.-28     	; 0x235e <__fp_split3+0xe>
    237a:	46 95       	lsr	r20
    237c:	f1 df       	rcall	.-30     	; 0x2360 <__fp_splitA>
    237e:	08 c0       	rjmp	.+16     	; 0x2390 <__fp_splitA+0x30>
    2380:	16 16       	cp	r1, r22
    2382:	17 06       	cpc	r1, r23
    2384:	18 06       	cpc	r1, r24
    2386:	99 1f       	adc	r25, r25
    2388:	f1 cf       	rjmp	.-30     	; 0x236c <__fp_splitA+0xc>
    238a:	86 95       	lsr	r24
    238c:	71 05       	cpc	r23, r1
    238e:	61 05       	cpc	r22, r1
    2390:	08 94       	sec
    2392:	08 95       	ret

00002394 <__fp_zero>:
    2394:	e8 94       	clt

00002396 <__fp_szero>:
    2396:	bb 27       	eor	r27, r27
    2398:	66 27       	eor	r22, r22
    239a:	77 27       	eor	r23, r23
    239c:	cb 01       	movw	r24, r22
    239e:	97 f9       	bld	r25, 7
    23a0:	08 95       	ret

000023a2 <__mulsf3>:
    23a2:	0b d0       	rcall	.+22     	; 0x23ba <__mulsf3x>
    23a4:	c4 cf       	rjmp	.-120    	; 0x232e <__fp_round>
    23a6:	b5 df       	rcall	.-150    	; 0x2312 <__fp_pscA>
    23a8:	28 f0       	brcs	.+10     	; 0x23b4 <__mulsf3+0x12>
    23aa:	ba df       	rcall	.-140    	; 0x2320 <__fp_pscB>
    23ac:	18 f0       	brcs	.+6      	; 0x23b4 <__mulsf3+0x12>
    23ae:	95 23       	and	r25, r21
    23b0:	09 f0       	breq	.+2      	; 0x23b4 <__mulsf3+0x12>
    23b2:	a6 cf       	rjmp	.-180    	; 0x2300 <__fp_inf>
    23b4:	ab cf       	rjmp	.-170    	; 0x230c <__fp_nan>
    23b6:	11 24       	eor	r1, r1
    23b8:	ee cf       	rjmp	.-36     	; 0x2396 <__fp_szero>

000023ba <__mulsf3x>:
    23ba:	ca df       	rcall	.-108    	; 0x2350 <__fp_split3>
    23bc:	a0 f3       	brcs	.-24     	; 0x23a6 <__mulsf3+0x4>

000023be <__mulsf3_pse>:
    23be:	95 9f       	mul	r25, r21
    23c0:	d1 f3       	breq	.-12     	; 0x23b6 <__mulsf3+0x14>
    23c2:	95 0f       	add	r25, r21
    23c4:	50 e0       	ldi	r21, 0x00	; 0
    23c6:	55 1f       	adc	r21, r21
    23c8:	62 9f       	mul	r22, r18
    23ca:	f0 01       	movw	r30, r0
    23cc:	72 9f       	mul	r23, r18
    23ce:	bb 27       	eor	r27, r27
    23d0:	f0 0d       	add	r31, r0
    23d2:	b1 1d       	adc	r27, r1
    23d4:	63 9f       	mul	r22, r19
    23d6:	aa 27       	eor	r26, r26
    23d8:	f0 0d       	add	r31, r0
    23da:	b1 1d       	adc	r27, r1
    23dc:	aa 1f       	adc	r26, r26
    23de:	64 9f       	mul	r22, r20
    23e0:	66 27       	eor	r22, r22
    23e2:	b0 0d       	add	r27, r0
    23e4:	a1 1d       	adc	r26, r1
    23e6:	66 1f       	adc	r22, r22
    23e8:	82 9f       	mul	r24, r18
    23ea:	22 27       	eor	r18, r18
    23ec:	b0 0d       	add	r27, r0
    23ee:	a1 1d       	adc	r26, r1
    23f0:	62 1f       	adc	r22, r18
    23f2:	73 9f       	mul	r23, r19
    23f4:	b0 0d       	add	r27, r0
    23f6:	a1 1d       	adc	r26, r1
    23f8:	62 1f       	adc	r22, r18
    23fa:	83 9f       	mul	r24, r19
    23fc:	a0 0d       	add	r26, r0
    23fe:	61 1d       	adc	r22, r1
    2400:	22 1f       	adc	r18, r18
    2402:	74 9f       	mul	r23, r20
    2404:	33 27       	eor	r19, r19
    2406:	a0 0d       	add	r26, r0
    2408:	61 1d       	adc	r22, r1
    240a:	23 1f       	adc	r18, r19
    240c:	84 9f       	mul	r24, r20
    240e:	60 0d       	add	r22, r0
    2410:	21 1d       	adc	r18, r1
    2412:	82 2f       	mov	r24, r18
    2414:	76 2f       	mov	r23, r22
    2416:	6a 2f       	mov	r22, r26
    2418:	11 24       	eor	r1, r1
    241a:	9f 57       	subi	r25, 0x7F	; 127
    241c:	50 40       	sbci	r21, 0x00	; 0
    241e:	8a f0       	brmi	.+34     	; 0x2442 <__mulsf3_pse+0x84>
    2420:	e1 f0       	breq	.+56     	; 0x245a <__mulsf3_pse+0x9c>
    2422:	88 23       	and	r24, r24
    2424:	4a f0       	brmi	.+18     	; 0x2438 <__mulsf3_pse+0x7a>
    2426:	ee 0f       	add	r30, r30
    2428:	ff 1f       	adc	r31, r31
    242a:	bb 1f       	adc	r27, r27
    242c:	66 1f       	adc	r22, r22
    242e:	77 1f       	adc	r23, r23
    2430:	88 1f       	adc	r24, r24
    2432:	91 50       	subi	r25, 0x01	; 1
    2434:	50 40       	sbci	r21, 0x00	; 0
    2436:	a9 f7       	brne	.-22     	; 0x2422 <__mulsf3_pse+0x64>
    2438:	9e 3f       	cpi	r25, 0xFE	; 254
    243a:	51 05       	cpc	r21, r1
    243c:	70 f0       	brcs	.+28     	; 0x245a <__mulsf3_pse+0x9c>
    243e:	60 cf       	rjmp	.-320    	; 0x2300 <__fp_inf>
    2440:	aa cf       	rjmp	.-172    	; 0x2396 <__fp_szero>
    2442:	5f 3f       	cpi	r21, 0xFF	; 255
    2444:	ec f3       	brlt	.-6      	; 0x2440 <__mulsf3_pse+0x82>
    2446:	98 3e       	cpi	r25, 0xE8	; 232
    2448:	dc f3       	brlt	.-10     	; 0x2440 <__mulsf3_pse+0x82>
    244a:	86 95       	lsr	r24
    244c:	77 95       	ror	r23
    244e:	67 95       	ror	r22
    2450:	b7 95       	ror	r27
    2452:	f7 95       	ror	r31
    2454:	e7 95       	ror	r30
    2456:	9f 5f       	subi	r25, 0xFF	; 255
    2458:	c1 f7       	brne	.-16     	; 0x244a <__mulsf3_pse+0x8c>
    245a:	fe 2b       	or	r31, r30
    245c:	88 0f       	add	r24, r24
    245e:	91 1d       	adc	r25, r1
    2460:	96 95       	lsr	r25
    2462:	87 95       	ror	r24
    2464:	97 f9       	bld	r25, 7
    2466:	08 95       	ret

00002468 <pow>:
    2468:	fa 01       	movw	r30, r20
    246a:	ee 0f       	add	r30, r30
    246c:	ff 1f       	adc	r31, r31
    246e:	30 96       	adiw	r30, 0x00	; 0
    2470:	21 05       	cpc	r18, r1
    2472:	31 05       	cpc	r19, r1
    2474:	99 f1       	breq	.+102    	; 0x24dc <pow+0x74>
    2476:	61 15       	cp	r22, r1
    2478:	71 05       	cpc	r23, r1
    247a:	61 f4       	brne	.+24     	; 0x2494 <pow+0x2c>
    247c:	80 38       	cpi	r24, 0x80	; 128
    247e:	bf e3       	ldi	r27, 0x3F	; 63
    2480:	9b 07       	cpc	r25, r27
    2482:	49 f1       	breq	.+82     	; 0x24d6 <pow+0x6e>
    2484:	68 94       	set
    2486:	90 38       	cpi	r25, 0x80	; 128
    2488:	81 05       	cpc	r24, r1
    248a:	61 f0       	breq	.+24     	; 0x24a4 <pow+0x3c>
    248c:	80 38       	cpi	r24, 0x80	; 128
    248e:	bf ef       	ldi	r27, 0xFF	; 255
    2490:	9b 07       	cpc	r25, r27
    2492:	41 f0       	breq	.+16     	; 0x24a4 <pow+0x3c>
    2494:	99 23       	and	r25, r25
    2496:	42 f5       	brpl	.+80     	; 0x24e8 <pow+0x80>
    2498:	ff 3f       	cpi	r31, 0xFF	; 255
    249a:	e1 05       	cpc	r30, r1
    249c:	31 05       	cpc	r19, r1
    249e:	21 05       	cpc	r18, r1
    24a0:	11 f1       	breq	.+68     	; 0x24e6 <pow+0x7e>
    24a2:	e8 94       	clt
    24a4:	08 94       	sec
    24a6:	e7 95       	ror	r30
    24a8:	d9 01       	movw	r26, r18
    24aa:	aa 23       	and	r26, r26
    24ac:	29 f4       	brne	.+10     	; 0x24b8 <pow+0x50>
    24ae:	ab 2f       	mov	r26, r27
    24b0:	be 2f       	mov	r27, r30
    24b2:	f8 5f       	subi	r31, 0xF8	; 248
    24b4:	d0 f3       	brcs	.-12     	; 0x24aa <pow+0x42>
    24b6:	10 c0       	rjmp	.+32     	; 0x24d8 <pow+0x70>
    24b8:	ff 5f       	subi	r31, 0xFF	; 255
    24ba:	70 f4       	brcc	.+28     	; 0x24d8 <pow+0x70>
    24bc:	a6 95       	lsr	r26
    24be:	e0 f7       	brcc	.-8      	; 0x24b8 <pow+0x50>
    24c0:	f7 39       	cpi	r31, 0x97	; 151
    24c2:	50 f0       	brcs	.+20     	; 0x24d8 <pow+0x70>
    24c4:	19 f0       	breq	.+6      	; 0x24cc <pow+0x64>
    24c6:	ff 3a       	cpi	r31, 0xAF	; 175
    24c8:	38 f4       	brcc	.+14     	; 0x24d8 <pow+0x70>
    24ca:	9f 77       	andi	r25, 0x7F	; 127
    24cc:	9f 93       	push	r25
    24ce:	0c d0       	rcall	.+24     	; 0x24e8 <pow+0x80>
    24d0:	0f 90       	pop	r0
    24d2:	07 fc       	sbrc	r0, 7
    24d4:	90 58       	subi	r25, 0x80	; 128
    24d6:	08 95       	ret
    24d8:	3e f0       	brts	.+14     	; 0x24e8 <pow+0x80>
    24da:	18 cf       	rjmp	.-464    	; 0x230c <__fp_nan>
    24dc:	60 e0       	ldi	r22, 0x00	; 0
    24de:	70 e0       	ldi	r23, 0x00	; 0
    24e0:	80 e8       	ldi	r24, 0x80	; 128
    24e2:	9f e3       	ldi	r25, 0x3F	; 63
    24e4:	08 95       	ret
    24e6:	4f e7       	ldi	r20, 0x7F	; 127
    24e8:	9f 77       	andi	r25, 0x7F	; 127
    24ea:	5f 93       	push	r21
    24ec:	4f 93       	push	r20
    24ee:	3f 93       	push	r19
    24f0:	2f 93       	push	r18
    24f2:	9e d0       	rcall	.+316    	; 0x2630 <log>
    24f4:	2f 91       	pop	r18
    24f6:	3f 91       	pop	r19
    24f8:	4f 91       	pop	r20
    24fa:	5f 91       	pop	r21
    24fc:	52 df       	rcall	.-348    	; 0x23a2 <__mulsf3>
    24fe:	05 c0       	rjmp	.+10     	; 0x250a <exp>
    2500:	19 f4       	brne	.+6      	; 0x2508 <pow+0xa0>
    2502:	0e f0       	brts	.+2      	; 0x2506 <pow+0x9e>
    2504:	fd ce       	rjmp	.-518    	; 0x2300 <__fp_inf>
    2506:	46 cf       	rjmp	.-372    	; 0x2394 <__fp_zero>
    2508:	01 cf       	rjmp	.-510    	; 0x230c <__fp_nan>

0000250a <exp>:
    250a:	2a df       	rcall	.-428    	; 0x2360 <__fp_splitA>
    250c:	c8 f3       	brcs	.-14     	; 0x2500 <pow+0x98>
    250e:	96 38       	cpi	r25, 0x86	; 134
    2510:	c0 f7       	brcc	.-16     	; 0x2502 <pow+0x9a>
    2512:	07 f8       	bld	r0, 7
    2514:	0f 92       	push	r0
    2516:	e8 94       	clt
    2518:	2b e3       	ldi	r18, 0x3B	; 59
    251a:	3a ea       	ldi	r19, 0xAA	; 170
    251c:	48 eb       	ldi	r20, 0xB8	; 184
    251e:	5f e7       	ldi	r21, 0x7F	; 127
    2520:	4e df       	rcall	.-356    	; 0x23be <__mulsf3_pse>
    2522:	0f 92       	push	r0
    2524:	0f 92       	push	r0
    2526:	0f 92       	push	r0
    2528:	4d b7       	in	r20, 0x3d	; 61
    252a:	5e b7       	in	r21, 0x3e	; 62
    252c:	0f 92       	push	r0
    252e:	c0 d0       	rcall	.+384    	; 0x26b0 <modf>
    2530:	e4 ee       	ldi	r30, 0xE4	; 228
    2532:	f0 e0       	ldi	r31, 0x00	; 0
    2534:	16 d0       	rcall	.+44     	; 0x2562 <__fp_powser>
    2536:	4f 91       	pop	r20
    2538:	5f 91       	pop	r21
    253a:	ef 91       	pop	r30
    253c:	ff 91       	pop	r31
    253e:	e5 95       	asr	r30
    2540:	ee 1f       	adc	r30, r30
    2542:	ff 1f       	adc	r31, r31
    2544:	49 f0       	breq	.+18     	; 0x2558 <exp+0x4e>
    2546:	fe 57       	subi	r31, 0x7E	; 126
    2548:	e0 68       	ori	r30, 0x80	; 128
    254a:	44 27       	eor	r20, r20
    254c:	ee 0f       	add	r30, r30
    254e:	44 1f       	adc	r20, r20
    2550:	fa 95       	dec	r31
    2552:	e1 f7       	brne	.-8      	; 0x254c <exp+0x42>
    2554:	41 95       	neg	r20
    2556:	55 0b       	sbc	r21, r21
    2558:	32 d0       	rcall	.+100    	; 0x25be <ldexp>
    255a:	0f 90       	pop	r0
    255c:	07 fe       	sbrs	r0, 7
    255e:	26 c0       	rjmp	.+76     	; 0x25ac <inverse>
    2560:	08 95       	ret

00002562 <__fp_powser>:
    2562:	df 93       	push	r29
    2564:	cf 93       	push	r28
    2566:	1f 93       	push	r17
    2568:	0f 93       	push	r16
    256a:	ff 92       	push	r15
    256c:	ef 92       	push	r14
    256e:	df 92       	push	r13
    2570:	7b 01       	movw	r14, r22
    2572:	8c 01       	movw	r16, r24
    2574:	68 94       	set
    2576:	05 c0       	rjmp	.+10     	; 0x2582 <__fp_powser+0x20>
    2578:	da 2e       	mov	r13, r26
    257a:	ef 01       	movw	r28, r30
    257c:	1e df       	rcall	.-452    	; 0x23ba <__mulsf3x>
    257e:	fe 01       	movw	r30, r28
    2580:	e8 94       	clt
    2582:	a5 91       	lpm	r26, Z+
    2584:	25 91       	lpm	r18, Z+
    2586:	35 91       	lpm	r19, Z+
    2588:	45 91       	lpm	r20, Z+
    258a:	55 91       	lpm	r21, Z+
    258c:	ae f3       	brts	.-22     	; 0x2578 <__fp_powser+0x16>
    258e:	ef 01       	movw	r28, r30
    2590:	8e dd       	rcall	.-1252   	; 0x20ae <__addsf3x>
    2592:	fe 01       	movw	r30, r28
    2594:	97 01       	movw	r18, r14
    2596:	a8 01       	movw	r20, r16
    2598:	da 94       	dec	r13
    259a:	79 f7       	brne	.-34     	; 0x257a <__fp_powser+0x18>
    259c:	df 90       	pop	r13
    259e:	ef 90       	pop	r14
    25a0:	ff 90       	pop	r15
    25a2:	0f 91       	pop	r16
    25a4:	1f 91       	pop	r17
    25a6:	cf 91       	pop	r28
    25a8:	df 91       	pop	r29
    25aa:	08 95       	ret

000025ac <inverse>:
    25ac:	9b 01       	movw	r18, r22
    25ae:	ac 01       	movw	r20, r24
    25b0:	60 e0       	ldi	r22, 0x00	; 0
    25b2:	70 e0       	ldi	r23, 0x00	; 0
    25b4:	80 e8       	ldi	r24, 0x80	; 128
    25b6:	9f e3       	ldi	r25, 0x3F	; 63
    25b8:	cd cd       	rjmp	.-1126   	; 0x2154 <__divsf3>
    25ba:	a2 ce       	rjmp	.-700    	; 0x2300 <__fp_inf>
    25bc:	ac c0       	rjmp	.+344    	; 0x2716 <__fp_mpack>

000025be <ldexp>:
    25be:	d0 de       	rcall	.-608    	; 0x2360 <__fp_splitA>
    25c0:	e8 f3       	brcs	.-6      	; 0x25bc <inverse+0x10>
    25c2:	99 23       	and	r25, r25
    25c4:	d9 f3       	breq	.-10     	; 0x25bc <inverse+0x10>
    25c6:	94 0f       	add	r25, r20
    25c8:	51 1d       	adc	r21, r1
    25ca:	bb f3       	brvs	.-18     	; 0x25ba <inverse+0xe>
    25cc:	91 50       	subi	r25, 0x01	; 1
    25ce:	50 40       	sbci	r21, 0x00	; 0
    25d0:	94 f0       	brlt	.+36     	; 0x25f6 <ldexp+0x38>
    25d2:	59 f0       	breq	.+22     	; 0x25ea <ldexp+0x2c>
    25d4:	88 23       	and	r24, r24
    25d6:	32 f0       	brmi	.+12     	; 0x25e4 <ldexp+0x26>
    25d8:	66 0f       	add	r22, r22
    25da:	77 1f       	adc	r23, r23
    25dc:	88 1f       	adc	r24, r24
    25de:	91 50       	subi	r25, 0x01	; 1
    25e0:	50 40       	sbci	r21, 0x00	; 0
    25e2:	c1 f7       	brne	.-16     	; 0x25d4 <ldexp+0x16>
    25e4:	9e 3f       	cpi	r25, 0xFE	; 254
    25e6:	51 05       	cpc	r21, r1
    25e8:	44 f7       	brge	.-48     	; 0x25ba <inverse+0xe>
    25ea:	88 0f       	add	r24, r24
    25ec:	91 1d       	adc	r25, r1
    25ee:	96 95       	lsr	r25
    25f0:	87 95       	ror	r24
    25f2:	97 f9       	bld	r25, 7
    25f4:	08 95       	ret
    25f6:	5f 3f       	cpi	r21, 0xFF	; 255
    25f8:	ac f0       	brlt	.+42     	; 0x2624 <ldexp+0x66>
    25fa:	98 3e       	cpi	r25, 0xE8	; 232
    25fc:	9c f0       	brlt	.+38     	; 0x2624 <ldexp+0x66>
    25fe:	bb 27       	eor	r27, r27
    2600:	86 95       	lsr	r24
    2602:	77 95       	ror	r23
    2604:	67 95       	ror	r22
    2606:	b7 95       	ror	r27
    2608:	08 f4       	brcc	.+2      	; 0x260c <ldexp+0x4e>
    260a:	b1 60       	ori	r27, 0x01	; 1
    260c:	93 95       	inc	r25
    260e:	c1 f7       	brne	.-16     	; 0x2600 <ldexp+0x42>
    2610:	bb 0f       	add	r27, r27
    2612:	58 f7       	brcc	.-42     	; 0x25ea <ldexp+0x2c>
    2614:	11 f4       	brne	.+4      	; 0x261a <ldexp+0x5c>
    2616:	60 ff       	sbrs	r22, 0
    2618:	e8 cf       	rjmp	.-48     	; 0x25ea <ldexp+0x2c>
    261a:	6f 5f       	subi	r22, 0xFF	; 255
    261c:	7f 4f       	sbci	r23, 0xFF	; 255
    261e:	8f 4f       	sbci	r24, 0xFF	; 255
    2620:	9f 4f       	sbci	r25, 0xFF	; 255
    2622:	e3 cf       	rjmp	.-58     	; 0x25ea <ldexp+0x2c>
    2624:	b8 ce       	rjmp	.-656    	; 0x2396 <__fp_szero>
    2626:	0e f0       	brts	.+2      	; 0x262a <ldexp+0x6c>
    2628:	76 c0       	rjmp	.+236    	; 0x2716 <__fp_mpack>
    262a:	70 ce       	rjmp	.-800    	; 0x230c <__fp_nan>
    262c:	68 94       	set
    262e:	68 ce       	rjmp	.-816    	; 0x2300 <__fp_inf>

00002630 <log>:
    2630:	97 de       	rcall	.-722    	; 0x2360 <__fp_splitA>
    2632:	c8 f3       	brcs	.-14     	; 0x2626 <ldexp+0x68>
    2634:	99 23       	and	r25, r25
    2636:	d1 f3       	breq	.-12     	; 0x262c <ldexp+0x6e>
    2638:	c6 f3       	brts	.-16     	; 0x262a <ldexp+0x6c>
    263a:	df 93       	push	r29
    263c:	cf 93       	push	r28
    263e:	1f 93       	push	r17
    2640:	0f 93       	push	r16
    2642:	ff 92       	push	r15
    2644:	c9 2f       	mov	r28, r25
    2646:	dd 27       	eor	r29, r29
    2648:	88 23       	and	r24, r24
    264a:	2a f0       	brmi	.+10     	; 0x2656 <log+0x26>
    264c:	21 97       	sbiw	r28, 0x01	; 1
    264e:	66 0f       	add	r22, r22
    2650:	77 1f       	adc	r23, r23
    2652:	88 1f       	adc	r24, r24
    2654:	da f7       	brpl	.-10     	; 0x264c <log+0x1c>
    2656:	20 e0       	ldi	r18, 0x00	; 0
    2658:	30 e0       	ldi	r19, 0x00	; 0
    265a:	40 e8       	ldi	r20, 0x80	; 128
    265c:	5f eb       	ldi	r21, 0xBF	; 191
    265e:	9f e3       	ldi	r25, 0x3F	; 63
    2660:	88 39       	cpi	r24, 0x98	; 152
    2662:	20 f0       	brcs	.+8      	; 0x266c <log+0x3c>
    2664:	80 3e       	cpi	r24, 0xE0	; 224
    2666:	30 f0       	brcs	.+12     	; 0x2674 <log+0x44>
    2668:	21 96       	adiw	r28, 0x01	; 1
    266a:	8f 77       	andi	r24, 0x7F	; 127
    266c:	0f dd       	rcall	.-1506   	; 0x208c <__addsf3>
    266e:	ec e0       	ldi	r30, 0x0C	; 12
    2670:	f1 e0       	ldi	r31, 0x01	; 1
    2672:	03 c0       	rjmp	.+6      	; 0x267a <log+0x4a>
    2674:	0b dd       	rcall	.-1514   	; 0x208c <__addsf3>
    2676:	e9 e3       	ldi	r30, 0x39	; 57
    2678:	f1 e0       	ldi	r31, 0x01	; 1
    267a:	73 df       	rcall	.-282    	; 0x2562 <__fp_powser>
    267c:	8b 01       	movw	r16, r22
    267e:	be 01       	movw	r22, r28
    2680:	ec 01       	movw	r28, r24
    2682:	fb 2e       	mov	r15, r27
    2684:	6f 57       	subi	r22, 0x7F	; 127
    2686:	71 09       	sbc	r23, r1
    2688:	75 95       	asr	r23
    268a:	77 1f       	adc	r23, r23
    268c:	88 0b       	sbc	r24, r24
    268e:	99 0b       	sbc	r25, r25
    2690:	fc dd       	rcall	.-1032   	; 0x228a <__floatsisf>
    2692:	28 e1       	ldi	r18, 0x18	; 24
    2694:	32 e7       	ldi	r19, 0x72	; 114
    2696:	41 e3       	ldi	r20, 0x31	; 49
    2698:	5f e3       	ldi	r21, 0x3F	; 63
    269a:	8f de       	rcall	.-738    	; 0x23ba <__mulsf3x>
    269c:	af 2d       	mov	r26, r15
    269e:	98 01       	movw	r18, r16
    26a0:	ae 01       	movw	r20, r28
    26a2:	ff 90       	pop	r15
    26a4:	0f 91       	pop	r16
    26a6:	1f 91       	pop	r17
    26a8:	cf 91       	pop	r28
    26aa:	df 91       	pop	r29
    26ac:	00 dd       	rcall	.-1536   	; 0x20ae <__addsf3x>
    26ae:	3f ce       	rjmp	.-898    	; 0x232e <__fp_round>

000026b0 <modf>:
    26b0:	fa 01       	movw	r30, r20
    26b2:	dc 01       	movw	r26, r24
    26b4:	aa 0f       	add	r26, r26
    26b6:	bb 1f       	adc	r27, r27
    26b8:	9b 01       	movw	r18, r22
    26ba:	ac 01       	movw	r20, r24
    26bc:	bf 57       	subi	r27, 0x7F	; 127
    26be:	28 f4       	brcc	.+10     	; 0x26ca <modf+0x1a>
    26c0:	22 27       	eor	r18, r18
    26c2:	33 27       	eor	r19, r19
    26c4:	44 27       	eor	r20, r20
    26c6:	50 78       	andi	r21, 0x80	; 128
    26c8:	1f c0       	rjmp	.+62     	; 0x2708 <modf+0x58>
    26ca:	b7 51       	subi	r27, 0x17	; 23
    26cc:	88 f4       	brcc	.+34     	; 0x26f0 <modf+0x40>
    26ce:	ab 2f       	mov	r26, r27
    26d0:	00 24       	eor	r0, r0
    26d2:	46 95       	lsr	r20
    26d4:	37 95       	ror	r19
    26d6:	27 95       	ror	r18
    26d8:	01 1c       	adc	r0, r1
    26da:	a3 95       	inc	r26
    26dc:	d2 f3       	brmi	.-12     	; 0x26d2 <modf+0x22>
    26de:	00 20       	and	r0, r0
    26e0:	69 f0       	breq	.+26     	; 0x26fc <modf+0x4c>
    26e2:	22 0f       	add	r18, r18
    26e4:	33 1f       	adc	r19, r19
    26e6:	44 1f       	adc	r20, r20
    26e8:	b3 95       	inc	r27
    26ea:	da f3       	brmi	.-10     	; 0x26e2 <modf+0x32>
    26ec:	0d d0       	rcall	.+26     	; 0x2708 <modf+0x58>
    26ee:	cd cc       	rjmp	.-1638   	; 0x208a <__subsf3>
    26f0:	61 30       	cpi	r22, 0x01	; 1
    26f2:	71 05       	cpc	r23, r1
    26f4:	a0 e8       	ldi	r26, 0x80	; 128
    26f6:	8a 07       	cpc	r24, r26
    26f8:	b9 46       	sbci	r27, 0x69	; 105
    26fa:	30 f4       	brcc	.+12     	; 0x2708 <modf+0x58>
    26fc:	9b 01       	movw	r18, r22
    26fe:	ac 01       	movw	r20, r24
    2700:	66 27       	eor	r22, r22
    2702:	77 27       	eor	r23, r23
    2704:	88 27       	eor	r24, r24
    2706:	90 78       	andi	r25, 0x80	; 128
    2708:	30 96       	adiw	r30, 0x00	; 0
    270a:	21 f0       	breq	.+8      	; 0x2714 <modf+0x64>
    270c:	20 83       	st	Z, r18
    270e:	31 83       	std	Z+1, r19	; 0x01
    2710:	42 83       	std	Z+2, r20	; 0x02
    2712:	53 83       	std	Z+3, r21	; 0x03
    2714:	08 95       	ret

00002716 <__fp_mpack>:
    2716:	9f 3f       	cpi	r25, 0xFF	; 255
    2718:	31 f0       	breq	.+12     	; 0x2726 <__fp_mpack_finite+0xc>

0000271a <__fp_mpack_finite>:
    271a:	91 50       	subi	r25, 0x01	; 1
    271c:	20 f4       	brcc	.+8      	; 0x2726 <__fp_mpack_finite+0xc>
    271e:	87 95       	ror	r24
    2720:	77 95       	ror	r23
    2722:	67 95       	ror	r22
    2724:	b7 95       	ror	r27
    2726:	88 0f       	add	r24, r24
    2728:	91 1d       	adc	r25, r1
    272a:	96 95       	lsr	r25
    272c:	87 95       	ror	r24
    272e:	97 f9       	bld	r25, 7
    2730:	08 95       	ret

00002732 <__udivmodhi4>:
    2732:	aa 1b       	sub	r26, r26
    2734:	bb 1b       	sub	r27, r27
    2736:	51 e1       	ldi	r21, 0x11	; 17
    2738:	07 c0       	rjmp	.+14     	; 0x2748 <__udivmodhi4_ep>

0000273a <__udivmodhi4_loop>:
    273a:	aa 1f       	adc	r26, r26
    273c:	bb 1f       	adc	r27, r27
    273e:	a6 17       	cp	r26, r22
    2740:	b7 07       	cpc	r27, r23
    2742:	10 f0       	brcs	.+4      	; 0x2748 <__udivmodhi4_ep>
    2744:	a6 1b       	sub	r26, r22
    2746:	b7 0b       	sbc	r27, r23

00002748 <__udivmodhi4_ep>:
    2748:	88 1f       	adc	r24, r24
    274a:	99 1f       	adc	r25, r25
    274c:	5a 95       	dec	r21
    274e:	a9 f7       	brne	.-22     	; 0x273a <__udivmodhi4_loop>
    2750:	80 95       	com	r24
    2752:	90 95       	com	r25
    2754:	bc 01       	movw	r22, r24
    2756:	cd 01       	movw	r24, r26
    2758:	08 95       	ret

0000275a <__divmodhi4>:
    275a:	97 fb       	bst	r25, 7
    275c:	09 2e       	mov	r0, r25
    275e:	07 26       	eor	r0, r23
    2760:	0a d0       	rcall	.+20     	; 0x2776 <__divmodhi4_neg1>
    2762:	77 fd       	sbrc	r23, 7
    2764:	04 d0       	rcall	.+8      	; 0x276e <__divmodhi4_neg2>
    2766:	e5 df       	rcall	.-54     	; 0x2732 <__udivmodhi4>
    2768:	06 d0       	rcall	.+12     	; 0x2776 <__divmodhi4_neg1>
    276a:	00 20       	and	r0, r0
    276c:	1a f4       	brpl	.+6      	; 0x2774 <__divmodhi4_exit>

0000276e <__divmodhi4_neg2>:
    276e:	70 95       	com	r23
    2770:	61 95       	neg	r22
    2772:	7f 4f       	sbci	r23, 0xFF	; 255

00002774 <__divmodhi4_exit>:
    2774:	08 95       	ret

00002776 <__divmodhi4_neg1>:
    2776:	f6 f7       	brtc	.-4      	; 0x2774 <__divmodhi4_exit>
    2778:	90 95       	com	r25
    277a:	81 95       	neg	r24
    277c:	9f 4f       	sbci	r25, 0xFF	; 255
    277e:	08 95       	ret

00002780 <_exit>:
    2780:	f8 94       	cli

00002782 <__stop_program>:
    2782:	ff cf       	rjmp	.-2      	; 0x2782 <__stop_program>
